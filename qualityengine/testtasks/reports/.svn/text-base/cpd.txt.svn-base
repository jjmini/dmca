Found a 662 line (2919 tokens) duplication in the following files: 
Starting at line 40 of D:\home\eCora_PM\PM\network\TerminalConnection.cpp
Starting at line 40 of D:\home\eCora_PM\PM\network\network\TerminalConnection.cpp

using namespace smuggle;

namespace network {    
    
TerminalConnection* 
makeTerminalConnection(const LoginParameters*const device)
{
    if (device->getProtocol() == ssh)
    {
	return establishSshConnection(device);
    }
    else if (device->getProtocol() == telnet)
    {
	return establishTelnetConnection(device);
    }
    else
    {
	wstring message = L"Terminal protocol is not supported" +
	    device->getProtocol();
	
        throw GenericException(__FILE__, __LINE__, L"TerminalConnection", 
                                L"", message);
    }
}

TerminalConnection::TerminalConnection()
{
}

TerminalConnection::~TerminalConnection()
{
}


void
TerminalConnection::setUmask(const wstring& mask)
{
    log(L"TerminalConnection::setUmask", Log::Info, mask);

    // Set the umask...
    bstring command = "/usr/bin/umask " + ws2ansi(mask);
    ShellResponse sR = sendAndReceive(command, 1);
    if (sR.status == ShellResponse::FAIL)
    {
        throw network::ExecutionError(__FILE__, __LINE__, 
                           L"setUmask", mask, sR.command,
                           sR.response, L"");
    }
}

void
TerminalConnection::initShell(void)
{
    log(L"TerminalConnection::initShell", Log::Info,
	    L"Initialize a unix connection.");
    try
    {
	//  Start a shell and init PS1 so we have a basis to work from.
        m_host->initUnix();
        
        m_hostType = shFilterCrLf("uname");

        wstring logMessage = L"Host type: " + m_hostType;
        log(L"TerminalConnection::initShell", Log::Debug, logMessage);
    
	if (m_hostType == L"AIX")
	    m_host->initAix();
	else if (m_hostType == L"SunOS")
	    m_host->initSolaris();
	else if (m_hostType == L"HP-UX")
	    m_host->initHpux();
        else if (m_hostType == L"Linux")
	    m_host->initLinux();
    }
    catch (network::ExecutionError& e)
    {
        log(L"TerminalConnection::initShell", Log::Debug,
	    L"shFilterCrLf failed for uname. Response: " + e.response());

        throw GenericException(__FILE__, __LINE__, 
            L"initShell", L"", 
            qs2ws(QObject::tr("shFilterCrLf failed for uname. Response: ")) + 
            e.response());
    }
    catch (Timeout&)
    { 
        log(L"TerminalConnection::initShell", Log::Debug,
	    L"Init Unix commnad Timeout.");

        throw GenericException(__FILE__, __LINE__, 
            L"initShell", L"", 
            qs2ws(QObject::tr("Init shell timeout.  Possible login failure.")));
    }
}

bool
TerminalConnection::beRoot(const wstring& password, const int delay,
			   const wstring& prompt)
{
    log(L"TerminalConnection::beRoot", Log::Info,
	L"Attempt to be root.");

    //  FIXME:  There are several cases where we log in with
    //  a user account and then call beRoot(); after doing what
    //  we need to as root we "exit".  If we do a return here
    //  that exit will cause the terminal connecion to shut
    //  itself down.
    //  If uid=0 already we're done.
    if (hostIdIsRoot())
        return true;

    m_host->setTimeout(TWENTY_SECOND_TIMEOUT);
    
    //  Use the proper command depending on os type.
    if (m_hostType == L"Linux")
        m_host->send("/bin/su -\n");
    else
        m_host->send("/usr/bin/su -\n");
 
    // Various ways of prompting for a password:
    vector<pair<bstring, int> > possible;
    possible.push_back(pair<bstring, int>("word:", PASSWORD));
    possible.push_back(pair<bstring, int>("WORD:", PASSWORD));
    possible.push_back(pair<bstring, int>("phrase:", PASSWORD));
    possible.push_back(pair<bstring, int>("PHRASE:", PASSWORD));
    
    try
    { 
        if (m_host->match(possible) == PASSWORD)
        {
          
            m_host->sendPassword(ws2ansi(password) + '\n');
            if (delay)
	    {
		Sleep(delay);
	    }
  
            if (!prompt.empty())
            {
                possible.clear();
                possible.push_back(pair<bstring, int>(ws2ansi(prompt),
						      PROMPT));
                m_host->match(possible);
	    }
	}
    }
    catch (Timeout&)
    { 
        wstring logMessage =
	    L"Failed to receive a root Password prompt.  Assume success.";
        log(L"TerminalConnection::beRoot", Log::Debug, logMessage);
    }

    initShell();
    return (hostIdIsRoot());
}

bool
TerminalConnection::hostIdIsRoot()
{
    log(L"TerminalConnection::hostIdIsRoot", Log::Info,
	    L"Send: /usr/bin/id");
    
    if (m_hostType == L"Linux")
        m_host->send("/usr/bin/id\n");
    else
        m_host->send("/bin/id\n");

    vector<pair<bstring, int> > possible;
    possible.push_back(pair<bstring, int> ("uid=", UID));

    try
    { 
	if (m_host->match(possible) == UID)
        {	    
            bstring response = m_host->data();
            if (response.find("uid=0") != bstring::npos)
            {
                log(L"TerminalConnection::hostIdIsRoot", Log::Debug,
                    L"Root uid found.");
	        return true;
            }
            else
            {
                wstring logMessage = L"Root uid was not found. \nResponse: " +
                    bstring2wstring(m_host->data());

                log(L"TerminalConnection::hostIdIsRoot", Log::Debug,
                    logMessage);
	        return false;
            }
        }
    }
    catch (Timeout&)
    {
        wstring logMessage = L"Uid command timeout.  \nResponse: " +
            bstring2wstring(m_host->data());

	log(L"TerminalConnection::hostIdIsRoot", Log::Debug, logMessage);
	return false;
    }
    log(L"TerminalConnection::hostIdIsRoot", Log::Debug,
            L"You are not root.  uid is not 0.");
    return false;
}

ShellResponse
TerminalConnection::sh(const bstring& message, const wchar_t filter)
{
    wstring logMessage = bstring2wstring(message) +
        L" Filter: " + filter;
    log(L"TerminalConnection::sh", Log::Info, logMessage);

    wstring returnThis;
    ShellResponse sR = sendAndReceive(message, 1);

    for (size_t i = 0; i < sR.response.size(); ++i)
    {
	if (sR.response[i] != filter)
	    returnThis += sR.response[i];
    }
    
    return sR;
}

void
TerminalConnection::shNoResponse(const bstring& command)
{
    log(L"TerminalConnection::shNoResponse", Log::Info, 
        bstring2wstring(command));

    ShellResponse sR = sendAndReceive(command, 1);
    if (sR.status == ShellResponse::FAIL)
    {
        throw network::ExecutionError(__FILE__, __LINE__, 
                           L"shNoResponse", L"", sR.command,
                           sR.response, L"");
    }
}

wstring 
TerminalConnection::shFilterCrLf(const bstring& message)
{
    log(L"TerminalConnection::shFilterCrLf", Log::Info, 
        bstring2wstring(message));

    wstring returnThis;
    ShellResponse sR = sendAndReceive(message, 2);
    if (sR.status == ShellResponse::FAIL)
    {
        throw network::ExecutionError(__FILE__, __LINE__, 
                           L"shFilterCrLf", L"", sR.command,
                           sR.response, L"");
    }

    for (size_t i = 0; i < sR.response.size(); ++i)
    {
        if ((sR.response[i] != L'\r') && (sR.response[i] != L'\n'))
            returnThis += sR.response[i];
    }

    return returnThis;
}

ShellResponse
TerminalConnection::sendAndReceive(const bstring& command, 
				       const int retryCount)
{     
    log(L"TerminalConnection::sendAndReceive", Log::Info, 
        bstring2wstring(command));

    struct ShellResponse sR;

    sR.command = bstring2wstring(command);

    bstring response;
    try
    { 
        response = m_host->execute(command, retryCount);    
        if (response.find("smuggle_failed_execution") != bstring::npos)
        {
            sR.response = L"Command failed: smuggle_failed_execution ";
            sR.status = ShellResponse::FAIL;
        }
        else 
        {
            sR.response = bstring2wstring(response);
            sR.status = ShellResponse::SUCCESS;
        }

    }
    catch (smuggle::Error& e)
    {
	sR.response = L"Command failed: " + e.message();
        sR.status = ShellResponse::FAIL;
    }
    catch (smuggle::ExecutionError& e)
    { 
        sR.response = L"Command failed: " + e.userMessage();
        sR.status = ShellResponse::FAIL;
    }
    catch (smuggle::Timeout& e)
    { 
        sR.response = L"Command failed: " + e.userMessage();
        sR.status = ShellResponse::FAIL;
    }
    
    return sR;
}

void 
TerminalConnection::makeAbsPath(const wstring& path)
{

    //  Due to the potential for a "long" pathname, this command
    //  is sent to the target in pieces and then executed.
    log(L"TerminalConnection::makeAbsPath", Log::Info, path);

    if (fileExists(path))
        return;

    //  If the directory already exists, return.
    bstring thisPath = convertName(path, false);
    thisPath = "\\\"" + thisPath + "\\\"";

    //  Create the directory and its parents.
    shNoResponse("ECMD=\"/usr/bin/mkdir -p -m 755 \"");
    shNoResponse("ECMD=\"$ECMD" + thisPath + "\"");
    shNoResponse("/usr/bin/echo $ECMD | /bin/sh");

    //  Test to be sure it is there.
    if (!fileExists(path))
    {
        wstring message = L"Directory is not visible: " + path;
        throw GenericException(__FILE__, __LINE__, 
                               L"TerminalConnection::makeAbsPath", 
                               L"", message);
    }
}

bool 
TerminalConnection::fileExists(const wstring& filename)
{

    log(L"TerminalConnection::fileExist", Log::Info, filename);

    bstring bsFilename = convertName(filename, false);
    bsFilename = "\\\"" + bsFilename + "\\\"";

    shNoResponse("ECMD=\"/usr/bin/file \"");
    shNoResponse("ECMD=\"$ECMD" + bsFilename + "\"");
    ShellResponse sR = sh("/usr/bin/echo $ECMD | /bin/sh");
    if ((sR.status == ShellResponse::FAIL) || 
        (sR.response.find(L"No such file") != wstring::npos))
    {
        return false;
    }
    else 
    {
        return true;
    }
}

void
TerminalConnection::fileRemove(const wstring& filename)
{
    bstring bsFilename = convertName(filename, false);
    bsFilename = "\\\"" + bsFilename + "\\\"";

    shNoResponse("ECMD=\"/usr/bin/rm -r \"");
    shNoResponse("ECMD=\"$ECMD" + bsFilename + "\"");
    shNoResponse("/usr/bin/echo $ECMD | /bin/sh");
}

vector<wstring>
TerminalConnection::getDirNamesOnly(const wstring& dirPath)
{
    bstring bsFilename = convertName(dirPath, false);
    bsFilename = "\\\"" + bsFilename + "\\\"";

    
    shNoResponse("ECMD=\"/usr/bin/ls -Al \"");
    shNoResponse("ECMD=\"$ECMD " + bsFilename + "\"");
    shNoResponse("ECMD=\"$ECMD | /usr/bin/grep \\^d \"");
    shNoResponse("ECMD=\"$ECMD | /usr/bin/awk '{print \\$9}'\"");

    wstring logMessage = L"/usr/bin/ls -Al " + bstring2wstring(bsFilename) +
        L" | /usr/bin/grep ^d | /usr/bin/awk '{print \\$9}'";

    return executeDirectoryListing(logMessage);
}

vector<wstring>
TerminalConnection::getFileNamesOnly(const wstring& dirPath)
{
    bstring bsFilename = convertName(dirPath, false);
    bsFilename = "\\\"" + bsFilename + "\\\"";

    shNoResponse("ECMD=\"/usr/bin/ls -Al \"");
    shNoResponse("ECMD=\"$ECMD " + bsFilename + "\"");
    shNoResponse("ECMD=\"$ECMD | /usr/bin/grep \\^- \"");
    shNoResponse("ECMD=\"$ECMD | /usr/bin/awk '{print \\$9}'\"");

    wstring logMessage = L"/usr/bin/ls -Al " + bstring2wstring(bsFilename) +
        L" | /usr/bin/grep ^- | /usr/bin/awk '{print \\$9}'";

    return executeDirectoryListing(logMessage);
}

vector<wstring>
TerminalConnection::getDirectoryContent(const wstring& dirPath)
{
    bstring bsFilename = convertName(dirPath, false);
    bsFilename = "\\\"" + bsFilename + "\\\"";

    shNoResponse("ECMD=\"/usr/bin/ls -Al \"");
    shNoResponse("ECMD=\"$ECMD " + bsFilename + "\"");
    shNoResponse("ECMD=\"$ECMD | /usr/bin/awk '{print \\$9}'\"");

    wstring logMessage = L"/usr/bin/ls -Al " + bstring2wstring(bsFilename) +
        L" | /usr/bin/awk '{print \\$9}'";

    return executeDirectoryListing(logMessage);
}

vector<wstring>
TerminalConnection::executeDirectoryListing(wstring logMessage)
{
    log(L"TerminalConnection::executeDirectoryListing", Log::Debug, logMessage);

    ShellResponse sR = sh("echo $ECMD | /bin/sh");

    if (sR.status == ShellResponse::FAIL)
    {
        throw network::ExecutionError(__FILE__, __LINE__, 
                           L"executeDirectoryListing", L"", sR.command,
                           sR.response, L"");
    }

    size_t i = 0;
    size_t j = i;

    vector<wstring> listing;
    while (i != wstring::npos)
    {
        wstring name;

        j = sR.response.find(L"\r\n", i);
        if (j != 0)
        {
            name = sR.response.substr(i, j - i);
        }

        if (j != wstring::npos)
            i = j + 2;
        else
            i = wstring::npos;

        if (!name.empty())
            listing.push_back(name);

    }
    return listing;
}

void
TerminalConnection::setPermissions(const wstring& filePath, 
                            const wstring& permissions)
{
    wstring logMessage = filePath + L"  Permissions: " +  permissions;
    log(L"TerminalConnection::setPermissions", Log::Info, logMessage);

    bstring bsFilename = convertName(filePath, false);
    bsFilename = "\\\"" + bsFilename + "\\\"";

    shNoResponse("ECMD=\"/usr/bin/chmod  " + ws2ansi(permissions) + "\"");
    shNoResponse("ECMD=\"$ECMD " + bsFilename + "\"");
    shNoResponse("echo $ECMD | /bin/sh");

}

void
TerminalConnection::setOwner(const wstring& filePath, 
                      const wstring& owner)
{
    wstring logMessage = filePath + L"  Owner: " +  owner;
    log(L"TerminalConnection::setOwner", Log::Info, logMessage);

    bstring bsFilename = convertName(filePath, false);
    bsFilename = "\\\"" + bsFilename + "\\\"";

    shNoResponse("ECMD=\"/usr/bin/chown " + ws2ansi(owner) + "\"");
    shNoResponse("ECMD=\"$ECMD " + bsFilename + "\"");
    shNoResponse("echo $ECMD | /bin/sh");
}

wstring 
TerminalConnection::checkSum(const wstring& filePath)
{
    wstring logMessage = L"Checksum: " + filePath;
    log(L"TerminalConnection::checkSum", Log::Info, logMessage);

    bstring bsFilename = convertName(filePath, false);
    bsFilename = "\\\"" + bsFilename + "\\\"";

    shNoResponse("ECMD=\"/usr/bin/sum \"");
    shNoResponse("ECMD=\"$ECMD " + bsFilename + "\"");
    shNoResponse("ECMD=\"$ECMD | /usr/bin/awk '{print $1$2}'\"");
    ShellResponse sR = sh("echo $ECMD | /bin/sh");
    if (sR.status == ShellResponse::FAIL)
    {
	wstring message = L"Failed to execute: /usr/bin/sum " + filePath +
            L" | /usr/bin/awk '{print $1$2}'";

        throw network::ExecutionError(__FILE__, __LINE__, 
                           L"checkSum", filePath, sR.command,
                           sR.response, message);
    }
    return sR.response;
}

unsigned long
TerminalConnection::fsSpaceAvailable(const wstring& path)
{
    //  Filesystem              avail
    //  /home/john            13949645

    // We are only interested in the second field of the second line.
    shNoResponse("ECMD=\"/usr/bin/df -b \"");
    shNoResponse("ECMD=\"$ECMD " + ws2ansi(path) + "\"");

    ShellResponse sR = sh("echo $ECMD | /bin/sh");
    if (sR.status == ShellResponse::FAIL)
    {
        wstring message = L"Failed to execute: /usr/bin/df -b " + path;
        throw network::ExecutionError(__FILE__, __LINE__, 
                           L"fsSpaceAvailable", path, sR.command,
                           sR.response, message);

    }
 
    wstring logMessage = L"Path: " + path + L" Response: " + sR.response;
    log(L"TerminalConnection::fsSpaceAvailable", Log::Info, logMessage);
    
    bstring bsAvailable = ws2ansi(sR.response);

    // Get the second line.  
    bsAvailable = bsAvailable.substr(bsAvailable.find("\n") + 1);

    //  Read until you get a space or a tab and then start copying.
    size_t i = 0;
    while ((bsAvailable[i] != ' ') && 
           (bsAvailable[i] != '\t'))
    {
        ++i;
        if (i >= bsAvailable.size())
            break;
    }

    bstring diskSpace;
    if (i < bsAvailable.size())
    {
        while ((bsAvailable[i] == ' ') || (bsAvailable[i] == '\t'))
        {
            ++i;
            if (i >= bsAvailable.size())
                break;
        }

        if (i < bsAvailable.size())
        {
            while (i < bsAvailable.size())
            {
                if ((bsAvailable[i] == '\r') || (bsAvailable[i] == '\n'))
                    break;

                diskSpace += bsAvailable[i];
                ++i;
            }
        }
    }       


    // Convert the value to a long...  This is the number of "kilo-bytes" available.
    unsigned long convertedValue = 0;
    if (!diskSpace.empty())
        convertedValue = atol(diskSpace.c_str());

    return convertedValue;
}

unsigned long 
TerminalConnection::fileSize(const wstring& filePath)
{
    shNoResponse("ECMD=\"/usr/bin/ls -al \"");
    shNoResponse("ECMD=\"$ECMD " + ws2ansi(filePath) + "\"");
    shNoResponse("ECMD=\"$ECMD  | /usr/bin/awk '{ print $5 }'\"");

    ShellResponse sR = sh("echo $ECMD | /bin/sh");

    if (sR.status == ShellResponse::FAIL)
    {
        wstring message = L"Failed to execute: /usr/bin/ls -al " +
            filePath + L" | /usr/bin/awk '{ print $5 }'";
        throw network::ExecutionError(__FILE__, __LINE__, 
                           L"fileSize", filePath, sR.command,
                           sR.response, message);
    }

    wstring logMessage = L"File: " + filePath + L" Response: " + sR.response;
    log(L"TerminalConnection::fileSize", Log::Info, logMessage);

    return atol(ws2ansi(sR.response).c_str());
}

wstring
TerminalConnection::wConvertName(const wstring& name, bool addQuotes)
{
    wstring logMessage = name;
    if (addQuotes)
        logMessage += L"  Add quotes = true";
    log(L"TerminalConnection::convertName", Log::Info, logMessage);

    wstring newName;

    if (addQuotes)
        newName = L"\"" + name + L"\"";
    else
        newName = name;
    
    for (size_t i = 0; i < newName.length(); i++)
    {
	if (newName[i] == L'\\')
	    newName[i] = L'/';
    }    
    return newName;
}

bstring
TerminalConnection::convertName(const wstring& name, bool addQuotes)
{
    wstring logMessage = name;
    if (addQuotes)
        logMessage += L"  Add quotes = true";
    log(L"TerminalConnection::convertName", Log::Info, logMessage);

    bstring newName;

    if (addQuotes)
        newName = "\"" + ws2ansi(name) + "\"";
    else
        newName = ws2ansi(name);
    
    for (size_t i = 0; i < newName.length(); i++)
    {
	if (newName[i] == '\\')
	    newName[i] = '/';
    }    
    return newName;
}

}  // End namespace connections
=====================================================================
Found a 502 line (2571 tokens) duplication in the following files: 
Starting at line 1620 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 261 of D:\home\eCora_PM\PM\patchRepository\WinSolRepoSettings.cpp

    tips.setHelp(m_solWidget->m_unixFTProtocol, L"Unix FTP Connection Protocol");

    if (m_services)
    {
        m_services->QueryInterface(IID_ISettings, (void**)&m_pISettings);
        HRESULT hr = m_services->QueryInterface(IID_IRepositoryManager,
            (void**)&m_pIRepositoryManager);

        if (!m_pISettings || !m_pIRepositoryManager)
        {
            wstring message = L"Unable to get repository settings.";
            throw GenericException(__FILE__, __LINE__, L"RepositorySettings",
                                L"", message);
        }
    }
    else
    {
        wstring message = L"Unable to get repository settings - services not available.";
        throw GenericException(__FILE__, __LINE__, L"RepositorySettings",
                                L"", message);
    }

    m_winWidget->m_windowsPassword->setEchoMode(QLineEdit::Password);
    //m_winWidget->m_windowsConfirmPass->setEchoMode(QLineEdit::Password);

    m_solWidget->m_unixTPassword->setEchoMode(QLineEdit::Password);
    m_solWidget->m_unixTRootPass->setEchoMode(QLineEdit::Password);
    m_solWidget->m_unixFTPassword->setEchoMode(QLineEdit::Password);
    //m_solWidget->m_unixTConfirmPass->setEchoMode(QLineEdit::Password);
    //m_solWidget->m_unixTConfirmRootPass->setEchoMode(QLineEdit::Password);
    //m_solWidget->m_unixFTConfirmPass->setEchoMode(QLineEdit::Password);

    m_solWidget->m_unixTProtocol->insertItem("ssh");
    m_solWidget->m_unixTProtocol->insertItem("telnet");

    m_solWidget->m_unixFTProtocol->insertItem("ftp");
    m_solWidget->m_unixFTProtocol->insertItem("scp");
    m_solWidget->m_unixFTProtocol->insertItem("sftp");

    init();

    // signals and slots connections
    connect(m_winWidget->m_enableWindows, SIGNAL(clicked()), this, SLOT(onWindows()));
    connect(m_winWidget->m_browseWindowsRepo, SIGNAL(clicked()), this, SLOT(onBrowse()));
    connect(m_winWidget->m_browseForDownloadDir, SIGNAL(clicked()), this, SLOT(onDownloadBrowse()));

    connect(m_solWidget->m_enableUnix, SIGNAL(clicked()), this, SLOT(onUnix()));
    connect(m_solWidget->m_unixAdvancedButton, SIGNAL(clicked()), this, SLOT(onAdvanced()));

    /*
    if (!m_dialog)
    {
        m_okButton->hide();
        m_cancelButton->hide();
    }
    else
    {
        connect(m_okButton, SIGNAL(clicked()), this, SLOT(onOk()));
        connect(m_cancelButton, SIGNAL(clicked()), this, SLOT(onCancel()));
        m_okButton->setDefault(true);
    }
    */

}

WinSolRepoSettings::~WinSolRepoSettings()
{
    if (m_pISettings)
        m_pISettings->Release();
    if (m_pIRepositoryManager)
        m_pIRepositoryManager->Release();
}

void WinSolRepoSettings::init()
{
    bool originalWindowsSettings = (m_originalWindowsSettings != 0);
    bool originalUnixSettings = (m_originalUnixSettings != 0);

    if (m_originalWindowsSettings)
    {
        delete m_originalWindowsSettings;
        m_originalWindowsSettings = 0;
    }
    if (m_originalUnixSettings)
    {
        delete m_originalUnixSettings;
        m_originalUnixSettings = 0;
    }

    vector<RepositorySettings*> repositories;
    try
    {
        RepositoryQuery rq(m_services);
        repositories = rq.select();
    }
    catch (GenericException& e)
    {
        log (L"patchRepository", Log::Error, L"Warning: No data source specified: "
            << e.userMessage());
    }

    // FIXME only allow two repositories for now (one for windows, one for unix)
    WindowsRepositorySettings* windowsSettings = 0;
    for (int i = 0; i < repositories.size(); ++i)
    {
        if (repositories[i]->systemType() == L"windows")
        {
            windowsSettings = static_cast<WindowsRepositorySettings*> (repositories[i]);
            if (m_originalWindowsSettings == 0)
            m_originalWindowsSettings = windowsSettings;
            break;
        }
    }

    if (windowsSettings)
    {
        m_winWidget->m_enableWindows->setChecked(true);
        m_winWidget->m_windowsRepository->setText(ws2qs(windowsSettings->path()));
        m_winWidget->m_windowsLogin->setText(ws2qs(windowsSettings->username()));

        // checks storeCredentials option and looks up in shared memory if needed
        Credentials cred(m_services);
        cred.getCredentials(windowsSettings);

        m_winWidget->m_windowsPassword->setText(ws2qs(windowsSettings->password()));
        //m_winWidget->m_windowsConfirmPass->setText(ws2qs(windowsSettings->password()));

        patchRepositoryUpgrade::Upgrade u(m_services, m_pIRepositoryManager);
        if (u.repository20Exists() && m_pISettings->setting(L"upgrade20Repository") == L"1")
            m_winWidget->m_upgrade20Repo->setChecked(true);
    }
    else if (!originalWindowsSettings)
    {
        // user changing databases.  If there are no repository settings in the new database
        // keep the settings they had for the original database (bug 6616)
        m_winWidget->m_enableWindows->setChecked(false);
        m_winWidget->m_windowsRepository->setText("");
        m_winWidget->m_upgrade20Repo->setChecked(false);
    }

    UnixRepositorySettings* unixSettings = 0;
    for (i = 0; i < repositories.size(); ++i)
    {
        if (repositories[i]->systemType() == L"solaris")
        {
            unixSettings = static_cast<UnixRepositorySettings*> (repositories[i]);
            if (m_originalUnixSettings == 0)
            m_originalUnixSettings = unixSettings;
            break;
        }
    }

    if (unixSettings)
    {
        m_solWidget->m_enableUnix->setChecked(true);
        m_solWidget->m_unixRepository->setText(ws2qs(unixSettings->path()));
        m_solWidget->m_unixHostname->setText(ws2qs(unixSettings->hostname()));
        m_solWidget->m_unixDNSDomain->setText(ws2qs(unixSettings->dnsDomain()));
        m_solWidget->m_unixIPAddress->setText(ws2qs(unixSettings->ipAddress()));

        //m_unixMd5->setText(ws2qs(unixSettings->md5Path()));


        m_solWidget->m_unixTUsername->setText(ws2qs(unixSettings->tUsername()));

        int index = 0;
        for (int i = 0; i < m_solWidget->m_unixTProtocol->count(); ++i)
        {
            if (qs2ws(m_solWidget->m_unixTProtocol->text(i)) == unixSettings->tProtocol())
            {
                index = i;
            }
        }

        m_solWidget->m_unixTProtocol->setCurrentItem(index);

        m_solWidget->m_unixFTUsername->setText(ws2qs(unixSettings->ftUsername()));

        index = 0;
        for (i = 0; i < m_solWidget->m_unixFTProtocol->count(); ++i)
        {
            if (qs2ws(m_solWidget->m_unixFTProtocol->text(i)) == unixSettings->ftProtocol())
            {
                index = i;
            }
        }

        m_solWidget->m_unixFTProtocol->setCurrentItem(index);

    m_advancedUnix = new UnixRepositorySettings(m_services, L"");
    m_advancedUnix->setTConnectionDelay(unixSettings->tConnectionDelay());
    m_advancedUnix->setTLoginPrompt(unixSettings->tLoginPrompt());
    m_advancedUnix->setTRootConnectionDelay(unixSettings->tRootConnectionDelay());
    m_advancedUnix->setTRootLoginPrompt(unixSettings->tRootLoginPrompt());
    m_advancedUnix->setTPort(unixSettings->tPort());

    m_advancedUnix->setFtPort(unixSettings->ftPort());

    // checks storeCredentials option and looks up in shared memory if needed
    Credentials cred(m_services);
    cred.getCredentials(unixSettings);

        m_solWidget->m_unixTPassword->setText(ws2qs(unixSettings->tPassword()));
    m_solWidget->m_unixTRootPass->setText(ws2qs(unixSettings->tRootPassword()));
    //m_solWidget->m_unixTConfirmPass->setText(ws2qs(unixSettings->tPassword()));
    //m_solWidget->m_unixTConfirmRootPass->setText(ws2qs(unixSettings->tRootPassword()));

    m_solWidget->m_unixFTPassword->setText(ws2qs(unixSettings->ftPassword()));
    //m_solWidget->m_unixFTConfirmPass->setText(ws2qs(unixSettings->ftPassword()));
    }
    else if (!originalWindowsSettings)
    {
        // user changing databases.  If there are no repository settings in the new database
        // keep the settings they had for the original database (bug 6616)
        m_solWidget->m_enableUnix->setChecked(false);
        m_solWidget->m_unixRepository->setText("");
        m_solWidget->m_unixHostname->setText("");
        m_solWidget->m_unixDNSDomain->setText("");
        m_solWidget->m_unixIPAddress->setText("");
        //m_unixMd5->setText("");
    }

    m_winWidget->m_downloadDir->setText(ws2qs(m_pISettings->setting(L"repositoryDownloadDirectory")));
    m_winWidget->m_removeUnusedStatus->setChecked(
        m_pISettings->setting(L"repositoryDatabaseCleanup") == L"false" ? false : true);

    // enable/disable SNMP and SMTP edit fields
    onWindows();
    onUnix();

    /* Axel?
    if (!m_winWidget->m_enableWindows->isChecked() && m_winWidget->m_enableUnix->isChecked())
    {
        m_repositoryTab->setCurrentPage(1);
    }
    */
}

void WinSolRepoSettings::onOk()
{
    if (!checkValidity())
        return;
    if (!m_winWidget->m_enableWindows->isChecked() && !m_solWidget->m_enableUnix->isChecked())
    {
        QMessageBox::warning(m_parent, tr("Warning"),
        tr("Please configure a repository."), QObject::tr("&OK"));
        return;
    }

    if (!save())
        return;

    //m_pDialog->done(1);
}

void WinSolRepoSettings::onCancel()
{
    //m_pDialog->reject();
}

void WinSolRepoSettings::onWindows()
{
    if (m_winWidget->m_enableWindows->isChecked())
    {
        m_winWidget->m_windowsRepository->setEnabled(true);
        m_winWidget->m_browseWindowsRepo->setEnabled(true);
        m_winWidget->m_windowsLogin->setEnabled(true);
        m_winWidget->m_windowsPassword->setEnabled(true);
        //m_winWidget->m_windowsConfirmPass->setEnabled(true);

        patchRepositoryUpgrade::Upgrade u(m_services, m_pIRepositoryManager);
        if (u.repository20Exists())
            m_winWidget->m_upgrade20Repo->setEnabled(true);
        else
            m_winWidget->m_upgrade20Repo->setEnabled(false);
        m_winWidget->m_enableWindows->setFocus();
    }
    else
    {
        m_winWidget->m_windowsRepository->setEnabled(false);
        m_winWidget->m_browseWindowsRepo->setEnabled(false);
        m_winWidget->m_windowsLogin->setEnabled(false);
        m_winWidget->m_windowsPassword->setEnabled(false);
        //m_winWidget->m_windowsConfirmPass->setEnabled(false);
        m_winWidget->m_upgrade20Repo->setEnabled(false);
    }
}

void WinSolRepoSettings::onUnix()
{
    if (m_solWidget->m_enableUnix->isChecked())
    {
        m_solWidget->m_unixRepository->setEnabled(true);
        m_solWidget->m_unixHostname->setEnabled(true);
        m_solWidget->m_unixDNSDomain->setEnabled(true);
        m_solWidget->m_unixIPAddress->setEnabled(true);
        //m_solWidget->m_unixMd5->setEnabled(true);

        m_solWidget->m_unixTUsername->setEnabled(true);
        m_solWidget->m_unixTPassword->setEnabled(true);
        m_solWidget->m_unixTRootPass->setEnabled(true);
        m_solWidget->m_unixTProtocol->setEnabled(true);

        m_solWidget->m_unixFTUsername->setEnabled(true);
        m_solWidget->m_unixFTPassword->setEnabled(true);
        m_solWidget->m_unixFTProtocol->setEnabled(true);
        m_solWidget->m_unixAdvancedButton->setEnabled(true);

        //m_solWidget->m_unixTConfirmPass->setEnabled(true);
        //m_solWidget->m_unixTConfirmRootPass->setEnabled(true);
        //m_solWidget->m_unixFTConfirmPass->setEnabled(true);

        m_solWidget->m_enableUnix->setFocus();
    }
    else
    {
        m_solWidget->m_unixRepository->setEnabled(false);
        m_solWidget->m_unixHostname->setEnabled(false);
        m_solWidget->m_unixDNSDomain->setEnabled(false);
        m_solWidget->m_unixIPAddress->setEnabled(false);
        //m_solWidget->m_unixMd5->setEnabled(false);

        m_solWidget->m_unixTUsername->setEnabled(false);
        m_solWidget->m_unixTPassword->setEnabled(false);
        m_solWidget->m_unixTRootPass->setEnabled(false);
        m_solWidget->m_unixTProtocol->setEnabled(false);

        m_solWidget->m_unixFTUsername->setEnabled(false);
        m_solWidget->m_unixFTPassword->setEnabled(false);
        m_solWidget->m_unixFTProtocol->setEnabled(false);
        m_solWidget->m_unixAdvancedButton->setEnabled(false);

        //m_solWidget->m_unixTConfirmPass->setEnabled(false);
        //m_solWidget->m_unixTConfirmRootPass->setEnabled(false);
        //m_solWidget->m_unixFTConfirmPass->setEnabled(false);
    }
}

void WinSolRepoSettings::onAdvanced()
{
    if (!m_advancedUnix)
        m_advancedUnix = new UnixRepositorySettings(m_services, L"");
    AdvancedUnixSettingsQT us(m_parent, m_advancedUnix);
    us.exec();
}

void WinSolRepoSettings::onBrowse()
{
    log(L"patchRepository", Log::Debug, L"Enter WinSolRepoSettings::onBrowse");
    QString caption = tr("Choose Repository UNC path");
    wstring path = qs2ws(m_winWidget->m_windowsRepository->text());
    log(L"patchRepository", Log::Debug, L"initial path " << path);

    do
    {
        path = qs2ws(QFileDialog::getExistingDirectory(
            ws2qs(path), m_parent, "browseForDataDir", caption, true));

        // user cancelled
        if (path.empty())
        {
            log(L"patchRepository", Log::Debug, L"User cancelled - path not altered");
            return;
        }

        // qt322 returns all slashes as '/'
        // WNetGetUnversalName doesn't like this so convert them to '\\'
        path = convertSlashes(path);
        log(L"patchRepository", Log::Debug, L"user selected path " << path);

        // this will convert mapped drives to UNC format
        DWORD len = 2048;
        WCHAR buff[2048];
        UNIVERSAL_NAME_INFO* info = (UNIVERSAL_NAME_INFO*)&buff;
        DWORD result;
        if ((result = WNetGetUniversalName((LPWSTR)path.c_str(), UNIVERSAL_NAME_INFO_LEVEL, &info, &len)) == NO_ERROR)
        {
            path = buff;
            log(L"patchRepository", Log::Debug, L"Path was mapped drive " << path);
        }

        // if we still have a local path, try to see if any sub-directories are shared
        // and convert to UNC format
        if (isLocalPath(path))
        {
            path = determineUNCPath(path);
            log(L"patchRepository", Log::Debug, L"Path was local " << path);
        }

        // if we still have a local path, show error message
        // FIXME in future should allow repository to be local, but then must make sure
        // that push cannot use the "execute directly from repository" option
        if (isLocalPath(path))
        {
            QMessageBox::warning(m_parent, tr("Warning"),
            tr("Windows repository path must be UNC path.  Please select a local directory that is shared."),
            QObject::tr("&OK"));
        }
    }
    while (isLocalPath(path));

    if (!path.empty())
    m_winWidget->m_windowsRepository->setText(ws2qs(path));
    log(L"patchRepository", Log::Debug, L"Exit WinSolRepoSettings::onBrowse");
}

wstring WinSolRepoSettings::determineUNCPath(const wstring& path)
{
    log(L"patchRepository", Log::Debug, L"Enter WinSolRepoSettings::determineUNCPath");
    wstring uncPath = path;

    try
    {
        auto_ptr<CRegConnectRegistry> pRemoteKey;
        pRemoteKey = auto_ptr<CRegConnectRegistry>(
            new CRegConnectRegistry(L"", HKEY_LOCAL_MACHINE));

        if (0 == pRemoteKey.get() || 0 == pRemoteKey->GetHKEY())
        {
            log(L"patchRepository", Log::Error,
            L"Error trying to convert local path to UNC: Unable to connect to registry");
            return path;
        }

        HKEY hkeyRemote = pRemoteKey->GetHKEY();

        wstring sKey;
        sKey = _T("SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Shares");

        KeyValues kv(hkeyRemote, sKey.c_str());
        kv.Read();

        map<tstring, KeyData>::iterator it;
        for (it = kv.begin(); it != kv.end(); it++)
        {
            wstring shareName = it->first;
            BYTE value[2048];
            DWORD len = 2048;

                HKEY openKeyMatch;
            if (RegOpenKeyEx(hkeyRemote, sKey.c_str(),
                       0, KEY_ALL_ACCESS, &openKeyMatch) != ERROR_SUCCESS)
            continue;

            if (RegQueryValueEx(openKeyMatch, shareName.c_str(), 0, 0, value, &len) == ERROR_SUCCESS)
            {
                log(L"patchRepository", Log::Debug, L"Found share " << shareName);
                // the value returned from registry has multiple strings separated by "\0"
                wstring shareValue = wstring((LPWSTR)value);
                while (shareValue.size() < len / 2 - 2)
                    shareValue += L" " + wstring((LPWSTR)&value[(shareValue.size() + 1) * 2]);
                log(L"patchRepository", Log::Debug, L"Share value " << shareValue);

                wstring sharePath = shareValue.substr(shareValue.find(L"Path=") + 5);
                sharePath = sharePath.substr(0, sharePath.find(L"Permissions=") - 1);
                log(L"patchRepository", Log::Debug, L"Share path " << sharePath);

                // now we've got the local path for the share, see if it's part of the path the user chose
                if (_wcsicmp(sharePath.c_str(), path.substr(0, sharePath.size()).c_str()) == 0)
                {
                    uncPath = L"\\\\" + getHostName() + L"\\" + shareName;
                    if (path.size() > sharePath.size())
                    uncPath += path.substr(sharePath.size());

                    log(L"patchRepository", Log::Debug,
                    L"Exit WinSolRepoSettings::determineUNCPath - path converted " << uncPath);
                    RegCloseKey(openKeyMatch);
                    return uncPath;
                }
            }
            RegCloseKey(openKeyMatch);
        }
    }
    catch (GenericException& e)
    {
        log(L"patchRepository", Log::Error,
        L"Error trying to convert local path to UNC: "  << e.userMessage());
    }

    log(L"patchRepository", Log::Debug,
    L"Exit WinSolRepoSettings::determineUNCPath - unable to convert");
    return path;
}


wstring WinSolRepoSettings::getHostName()
{
    char hostname[256];
    hostname[0] = '\0';
    gethostname(hostname, 256);
    return bstring2wstring(hostname);
}

void WinSolRepoSettings::onDownloadBrowse()
{
    QString caption = tr("Choose temporary download path");
    QString path = m_winWidget->m_downloadDir->text();

    path = QFileDialog::getExistingDirectory(
        path, m_parent, "browseForDownloadDir", caption, true);
    if (path != QString::null)
    m_winWidget->m_downloadDir->setText(path);
=====================================================================
Found a 275 line (2101 tokens) duplication in the following files: 
Starting at line 21 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\BlowfishKeys.h
Starting at line 21 of D:\home\eCora_PM\PM\utils\BlowfishKeys.h

static unsigned long bf_P[NPASS + 2] = 
{
    0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,
    0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,
    0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,
    0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,
    0x9216d5d9, 0x8979fb1b
};


static unsigned long bf_S[4][256] = 
{
    { 
	0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7,
        0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
        0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,
        0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
        0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,
        0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
        0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef,
        0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
        0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,
        0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
        0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce,
        0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
        0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e,
        0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
        0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
        0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
        0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88,
        0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
        0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e,
        0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
        0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,
        0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,
        0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88,
        0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
        0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,
        0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,
        0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,
        0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
        0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba,
        0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
        0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f,
        0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
        0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,
        0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,
        0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,
        0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
        0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab,
        0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,
        0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,
        0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
        0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0,
        0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
        0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790,
        0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,
        0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
        0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
        0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7,
        0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
        0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad,
        0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
        0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,
        0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
        0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477,
        0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
        0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,
        0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
        0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,
        0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
        0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41,
        0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
        0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400,
        0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915
    },
    {
	0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,
        0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a,
        0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,
        0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
        0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,
        0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
        0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6,
        0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
        0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e,
        0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
        0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,
        0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
        0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,
        0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
        0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701,
        0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
        0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,
        0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
        0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf,
        0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
        0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e,
        0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
        0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
        0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,
        0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16,
        0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
        0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b,
        0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
        0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,
        0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,
        0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f,
        0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
        0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,
        0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,
        0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,
        0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
        0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802,
        0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
        0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510,
        0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
        0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,
        0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,
        0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,
        0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
        0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8,
        0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,
        0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,
        0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
        0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128,
        0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
        0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0,
        0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,
        0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
        0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
        0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3,
        0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
        0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00,
        0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
        0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,
        0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
        0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735,
        0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
        0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,
        0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340
    },
    {
	0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,
        0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7,
        0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934,
        0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
        0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,
        0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
        0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45,
        0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
        0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,
        0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
        0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,
        0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
        0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42,
        0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
        0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2,
        0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
        0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,
        0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
        0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,
        0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
        0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3,
        0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
        0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,
        0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
        0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b,
        0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
        0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922,
        0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
        0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
        0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
        0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37,
        0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
        0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804,
        0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
        0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,
        0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
        0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d,
        0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
        0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,
        0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
        0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,
        0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
        0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d,
        0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
        0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f,
        0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
        0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,
        0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
        0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,
        0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
        0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e,
        0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,
        0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,
        0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
        0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52,
        0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
        0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5,
        0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
        0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
        0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
        0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24,
        0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
        0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4,
        0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c
    },
    {
	0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,
        0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0,
        0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b,
        0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
        0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
        0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
        0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8,
        0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
        0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304,
        0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
        0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,
        0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,
        0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9,
        0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
        0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,
        0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
        0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,
        0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,
        0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b,
        0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
        0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c,
        0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,
        0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,
        0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
        0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,
        0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
        0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991,
        0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,
        0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,
        0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
        0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae,
        0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
        0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5,
        0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
        0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
        0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,
        0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84,
        0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
        0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8,
        0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
        0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,
        0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,
        0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38,
        0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
        0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,
        0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,
        0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,
        0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
        0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964,
        0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
        0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8,
        0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
        0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,
        0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,
        0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,
        0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
        0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614,
        0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,
        0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,
        0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
        0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0,
        0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
        0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e,
        0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9
    }
};
=====================================================================
Found a 356 line (2089 tokens) duplication in the following files: 
Starting at line 27 of D:\home\eCora_PM\PM\network\CurlImpl.cc
Starting at line 27 of D:\home\eCora_PM\PM\network\network\CurlImpl.cc

namespace network {

static int
progressCallback(
    void* clientp, double dltotal, double dlnow, double ultotal, double ulnow)
{
    CurlImpl* ci = reinterpret_cast<CurlImpl*>(clientp);
    if (ci != 0)
    {
        ci->progress(dltotal, dlnow, ultotal, ulnow);
        return ci->aborted() ? 1 : 0;
    }
    return 0;
}

static int
loggingFunction(CURL* curlHandle, curl_infotype infoType, char* message,
                                        size_t messageSize, void* debugData)
{
    wstring logMessage;

    switch (infoType)
    {
        case CURLINFO_TEXT:
            logMessage = L"TEXT:  ";
            break;
        case CURLINFO_HEADER_OUT:
            logMessage = L"HEADER_OUT:  ";
            break;
        case CURLINFO_HEADER_IN:
            logMessage = L"HEADER_IN:  ";
            break;
        case CURLINFO_DATA_IN:
            logMessage = L"DATA_IN:  ";
            /*DO NOT log curl binary data */
            return 0;
            break;
        case CURLINFO_DATA_OUT:
            logMessage = L"DATA_OUT:  ";
            break;
        default: /* nada */
            logMessage = L"UNKNOWN_TYPE:  ";
          break;
    }

    bstring tmpString;
    for (size_t i = 0; i < messageSize; ++i)
        tmpString += message[i];

    logMessage += bstring2wstring(tmpString);

    log(L"CurlImpl::loggingFunction", Log::Debug, logMessage);
    return 0;
}

CurlImpl::CurlImpl(const wstring& userAgentLocation)
{
    m_aborted = false;

    m_handle = curl_easy_init();

    curl_easy_setopt(m_handle, CURLOPT_NOPROGRESS, 0);
    curl_easy_setopt(m_handle, CURLOPT_PROGRESSFUNCTION, progressCallback);
    curl_easy_setopt(m_handle, CURLOPT_PROGRESSDATA, this);
    curl_easy_setopt(m_handle, CURLOPT_SSL_VERIFYPEER, 0);
    curl_easy_setopt(m_handle, CURLOPT_SSL_VERIFYHOST, 0);

    //  FIXME:  11-13-03 JM I don't think that this is necessary anymore.
    //curl_easy_setopt(m_handle, CURLOPT_FRESH_CONNECT, 1);

    //  Don't let curl do this by itself.  We'll handle it.
    curl_easy_setopt(m_handle, CURLOPT_FOLLOWLOCATION, 0);

    //  Even though we don't FOLLOW we need to set this for those
    //  cases where we use MS NTLM and NTLM is failing.
    curl_easy_setopt(m_handle, CURLOPT_MAXREDIRS, 5);

    curl_easy_setopt(m_handle, CURLOPT_DEBUGFUNCTION, loggingFunction);
    curl_easy_setopt(m_handle, CURLOPT_VERBOSE, 1);

    if (!userAgentLocation.empty())
    {
        wstring userAgent;
        try {
            userAgent = Registry::value(userAgentLocation);
        }
        catch (GenericException&)
        {
            userAgent = L"EcoraSoftware/1.1";
            Registry::setValue(userAgentLocation, userAgent);
        }

        const char* arg = strdup(ws2utf8s(userAgent).c_str());
        curl_easy_setopt(m_handle, CURLOPT_USERAGENT, arg);
        m_garbage.push_back(arg);
    }

    m_curlVersion = curl_version_info(CURLVERSION_NOW);
}

CurlImpl::~CurlImpl()
{
    curl_easy_cleanup(m_handle);

    vector<const char*>::iterator it;
    for (it = m_garbage.begin(); it != m_garbage.end(); ++it)
        free(const_cast<char*>(*it));

}

void
CurlImpl::progress(
    double dltotal, double dlnow, double ultotal, double ulnow)
{
    set<com::NetworkListener*>::iterator it;
    for (it = m_listeners.begin(); it != m_listeners.end(); ++it)
    {
        (*it)->downloadProgress(dlnow, dltotal);
        (*it)->uploadProgress(ulnow, ultotal);
    }
}

void
CurlImpl::useProxy(const wstring& proxy, const wstring& user,
                   const wstring& password, const bool useNTLM)
{
    m_proxy = proxy;

    if (proxy.empty())
        curl_easy_setopt(m_handle, CURLOPT_PROXY, 0);
    else
    {
        const char* arg = strdup(ws2utf8s(proxy).c_str());
        curl_easy_setopt(m_handle, CURLOPT_PROXY, arg);
        m_garbage.push_back(arg);
    }

    if (user.empty() && password.empty())
    {
        curl_easy_setopt(m_handle, CURLOPT_PROXYUSERPWD, 0);
    }
    else
    {
        if (user.empty() && !useNTLM)
        {
            char sBufName[256];
            unsigned long nNameSize = 255;
            GetUserNameA(sBufName, &nNameSize);
            m_proxyUser = utf8s2ws(sBufName);
        }
        else
        {
            m_proxyUser = user;
        }

        m_proxyPassword = password;

        wstring usrpw = m_proxyUser;
        if (!password.empty())
           usrpw += L":" + password;

        const char* arg2 = strdup(ws2utf8s(usrpw).c_str());
        curl_easy_setopt(m_handle, CURLOPT_PROXYUSERPWD, arg2);
        m_garbage.push_back(arg2);
    }


    //  Clear the bit map before setting NTLM or basic...
    curl_easy_setopt(m_handle, CURLOPT_PROXYAUTH, CURLAUTH_NONE);
    if (useNTLM)
        curl_easy_setopt(m_handle, CURLOPT_PROXYAUTH, CURLAUTH_NTLM);
    else
        curl_easy_setopt(m_handle, CURLOPT_PROXYAUTH, CURLAUTH_BASIC);
}

void
CurlImpl::addListener(com::NetworkListener* listener)
{
    m_listeners.insert(listener);
}

void
CurlImpl::removeListener(com::NetworkListener* listener)
{
    m_listeners.erase(listener);
}

void
CurlImpl::setCredentials(const wstring& login, const wstring& pass)
{
    m_login = login;
    m_password = pass;
}

bool
CurlImpl::aborted() const
{
    return m_aborted;
}

void
CurlImpl::setAborted(bool yes)
{
    m_aborted = yes;
}

void
CurlImpl::setConnectionTimeout(int timeInSeconds)
{
    curl_easy_setopt(m_handle, CURLOPT_CONNECTTIMEOUT, timeInSeconds);
}

void
CurlImpl::setOperationTimeout(int timeInSeconds)
{
    curl_easy_setopt(m_handle, CURLOPT_TIMEOUT, timeInSeconds);
}

wstring
CurlImpl::mapErrorMessage(int code)
{
    if (code == CURLE_OK)
        return L"Ok";
    else if (code == CURLE_UNSUPPORTED_PROTOCOL)
        return qs2ws(QObject::tr("Unsupported protocol"));
    else if (code == CURLE_FAILED_INIT)
        return qs2ws(QObject::tr("Failed initialization"));
    else if (code == CURLE_URL_MALFORMAT)
        return qs2ws(QObject::tr("Badly formatted URL"));
    else if (code == CURLE_URL_MALFORMAT_USER)
        return qs2ws(QObject::tr("Badly formatted user URL"));
    else if (code == CURLE_COULDNT_RESOLVE_PROXY)
        return qs2ws(QObject::tr("Could not resolve proxy address"));
    else if (code == CURLE_COULDNT_RESOLVE_HOST)
        return qs2ws(QObject::tr("Could not resolve host address"));
    else if (code == CURLE_COULDNT_CONNECT)
        return qs2ws(QObject::tr("Could not connect to host"));
    else if (code == CURLE_FTP_WEIRD_SERVER_REPLY)
        return qs2ws(QObject::tr("FTP server reply unexpected"));
    else if (code == CURLE_FTP_ACCESS_DENIED)
        return qs2ws(QObject::tr("Access denied"));
    else if (code == CURLE_FTP_USER_PASSWORD_INCORRECT)
        return qs2ws(QObject::tr("Incorrect password"));
    else if (code == CURLE_FTP_WEIRD_PASS_REPLY)
        return qs2ws(QObject::tr("FTP server password reply unexpected"));
    else if (code == CURLE_FTP_WEIRD_USER_REPLY)
        return qs2ws(QObject::tr("FTP server user reply unexpected"));
    else if (code == CURLE_FTP_WEIRD_PASV_REPLY)
        return qs2ws(QObject::tr("FTP server PASV reply unexpected"));
    else if (code == CURLE_FTP_WEIRD_227_FORMAT)
        return qs2ws(QObject::tr("FTP server 227 format error"));
    else if (code == CURLE_FTP_CANT_GET_HOST)
        return qs2ws(QObject::tr("Could not get the FTP host"));
    else if (code == CURLE_FTP_CANT_RECONNECT)
        return qs2ws(QObject::tr("Could not reconnect to FTP host"));
    else if (code == CURLE_FTP_COULDNT_SET_BINARY)
        return qs2ws(QObject::tr("Could not set binary mode on FTP server"));
    else if (code == CURLE_PARTIAL_FILE)
        return qs2ws(QObject::tr("Only recieved a partial file"));
    else if (code == CURLE_FTP_COULDNT_RETR_FILE)
        return qs2ws(QObject::tr("Could not retrieve file"));
    else if (code == CURLE_FTP_WRITE_ERROR)
        return qs2ws(QObject::tr("FTP write error"));
    else if (code == CURLE_FTP_QUOTE_ERROR)
        return qs2ws(QObject::tr("FTP quote error"));
    else if (code == CURLE_HTTP_NOT_FOUND)
        return qs2ws(QObject::tr("HTTP not found"));
    else if (code == CURLE_WRITE_ERROR)
        return qs2ws(QObject::tr("Write error"));
    else if (code == CURLE_MALFORMAT_USER)
        return qs2ws(QObject::tr("Username illegally specified."));
    else if (code == CURLE_FTP_COULDNT_STOR_FILE)
        return qs2ws(QObject::tr("Failed FTP file upload"));
    else if (code == CURLE_READ_ERROR)
        return qs2ws(QObject::tr("Could not read file"));
    else if (code == CURLE_OUT_OF_MEMORY)
        return qs2ws(QObject::tr("Out of memory"));
    else if (code == CURLE_OPERATION_TIMEOUTED)
        return qs2ws(QObject::tr("Operation timeout"));
    else if (code == CURLE_FTP_COULDNT_SET_ASCII)
        return qs2ws(QObject::tr("Could not set ASCII mode"));
    else if (code == CURLE_FTP_PORT_FAILED)
        return qs2ws(QObject::tr("FTP PORT opration failed."));
    else if (code == CURLE_FTP_COULDNT_USE_REST)
        return qs2ws(QObject::tr("FTP REST operation failed."));
    else if (code == CURLE_FTP_COULDNT_GET_SIZE)
        return qs2ws(QObject::tr("FTP SIZE operation failed."));
    else if (code == CURLE_HTTP_RANGE_ERROR)
        return qs2ws(QObject::tr("HTTP RANGE operation failed."));
    else if (code == CURLE_HTTP_POST_ERROR)
        return qs2ws(QObject::tr("HTTP POST error"));
    else if (code == CURLE_SSL_CONNECT_ERROR)
        return qs2ws(QObject::tr("SSL connect error"));
    else if (code == CURLE_FTP_BAD_DOWNLOAD_RESUME)
        return qs2ws(QObject::tr("Could not resume download"));
    else if (code == CURLE_FILE_COULDNT_READ_FILE)
        return qs2ws(QObject::tr("Could not read file"));
    else if (code == CURLE_LDAP_CANNOT_BIND)
        return qs2ws(QObject::tr("Could not bind to LDAP server"));
    else if (code == CURLE_LDAP_SEARCH_FAILED)
        return qs2ws(QObject::tr("LDAP search failed"));
    else if (code == CURLE_LIBRARY_NOT_FOUND)
        return qs2ws(QObject::tr("Library not found"));
    else if (code == CURLE_FUNCTION_NOT_FOUND)
        return qs2ws(QObject::tr("Function not found"));
    else if (code == CURLE_ABORTED_BY_CALLBACK)
        return qs2ws(QObject::tr("Aborted"));
    else if (code == CURLE_BAD_FUNCTION_ARGUMENT)
        return qs2ws(QObject::tr("Bad function argument"));
    else if (code == CURLE_BAD_CALLING_ORDER)
        return qs2ws(QObject::tr("Bad calling order"));
    else if (code == CURLE_HTTP_PORT_FAILED)
        return qs2ws(QObject::tr("HTTP Interface operation failed"));
    else if (code == CURLE_BAD_PASSWORD_ENTERED)
        return qs2ws(QObject::tr("Bad password entered."));
    else if (code == CURLE_TOO_MANY_REDIRECTS)
        return qs2ws(QObject::tr("Too many redirects"));
    else if (code == CURLE_UNKNOWN_TELNET_OPTION)
        return qs2ws(QObject::tr("Unknown telnet option"));
    else if (code == CURLE_TELNET_OPTION_SYNTAX)
        return qs2ws(QObject::tr("Malformed telent option"));
    else if (code == CURLE_OBSOLETE)
        return qs2ws(QObject::tr("Obselete feature"));
    else if (code == CURLE_SSL_PEER_CERTIFICATE)
        return qs2ws(QObject::tr("Error with peer's certificate"));
    else if (code == CURLE_GOT_NOTHING)
        return qs2ws(QObject::tr("Recieved no data"));
    else if (code == CURLE_SSL_ENGINE_NOTFOUND)
        return qs2ws(QObject::tr("SSL engine was not found."));
    else if (code == CURLE_SSL_ENGINE_SETFAILED)
        return qs2ws(QObject::tr("Could not setup SSL engine"));
    else if (code == CURLE_SEND_ERROR)
        return qs2ws(QObject::tr("Failed sending network data"));
    else if (code == CURLE_RECV_ERROR)
        return qs2ws(QObject::tr("Failure in receiving network data"));
    else if (code == CURLE_SHARE_IN_USE)
        return qs2ws(QObject::tr("Share is in use"));
    else if (code == CURLE_SSL_CERTPROBLEM)
        return qs2ws(QObject::tr("Problem with the local certificate"));
    else if (code == CURLE_SSL_CIPHER)
        return qs2ws(QObject::tr("Couldn't use specified cipher"));
    else if (code == CURLE_SSL_CACERT)
        return qs2ws(QObject::tr("Problem with the CA cert"));
    else if (code == CURLE_BAD_CONTENT_ENCODING)
        return qs2ws(QObject::tr("Unrecognized transfer encoding"));
    else if (code == CURLE_LDAP_INVALID_URL)
        return qs2ws(QObject::tr("Invalid LDAP URL"));
    else if (code == CURLE_FILESIZE_EXCEEDED)
        return qs2ws(QObject::tr("Maximum file size exceeded"));
    else if (code == CURLE_PROXY_AUTHENTICATION_ERROR)
        return qs2ws(QObject::tr("Proxy authentication error"));
    else
        return qs2ws(QObject::tr("Unrecognized error code"));
}

} // namespace network
=====================================================================
Found a 227 line (1805 tokens) duplication in the following files: 
Starting at line 163 of D:\home\eCora_PM\PM\customPatch\ExportWizard.cpp
Starting at line 101 of D:\home\eCora_PM\PM\customPatch\ImportWizard.cpp

void ImportWizard::onItemClick(QListViewItem *item)
{
    QCheckListItem* selItem = (QCheckListItem*)item;
    if (selItem == 0)
    {
        selItem = (QCheckListItem *)m_listTree->selectedItem();
    }
    if (0 == selItem)
        return;
    saveConfigTable();  // T: BUGFIX #24478
    m_table->setNumRows(0);
    m_table->setUpdatesEnabled(false);
    if (selItem->text(0) == tr("Custom applications"))
    {
        selItem->setTristate(true);
        QCheckListItem::ToggleState state = selItem->state();
        selItem->setTristate(false);
        if (state != QCheckListItem::NoChange)
        {
            bool selected = selItem->isOn();
            map<QString, CustomApplication*>::iterator it;
            for (it = m_apps.begin(); it != m_apps.end(); ++it)
                unSelectApp(it->second, selected);
            QCheckListItem* child = (QCheckListItem*)selItem->firstChild();
            for (int i = 0; i < selItem->childCount(); i++)
            {
                unSelectChild(child, selected);
                child = (QCheckListItem*)child->nextSibling();
            }
        }
        m_table->setNumCols(1);
        m_table->setNumRows(0);
        m_table->horizontalHeader()->setLabel(0, tr("Product"));
        map<QString, CustomApplication*>::iterator it;
        int num = 0;
        QString name = "";
        bool allChecked = false;
        ESCheckTableItem* itm = 0;
        for (it = m_apps.begin(); it != m_apps.end(); ++it)
        {
            if (it->second->m_name != name)
            {
                if (itm != 0)
                    itm->setChecked(allChecked);
                name = it->second->m_name;
                m_table->setNumRows(num + 1);
                itm = new ESCheckTableItem(m_table, name, this);
                allChecked = it->second->m_isSelected;
                m_table->setItem(num, 0, itm);
                num++;
            }
            else if (!it->second->m_isSelected)
                allChecked = false;
        }
        itm->setChecked(allChecked);
    }
    else if (selItem->parent()->text(0) == tr("Custom applications"))
    {
        selItem->setTristate(true);
        QCheckListItem::ToggleState state = selItem->state();
        selItem->setTristate(false);
        QString product = selItem->text(0);
        if (state != QCheckListItem::NoChange)
        //if (m_allSelected != selItem->isOn())
        {
            bool selected = (state == QCheckListItem::On);
            map<QString, CustomApplication*>::iterator it;
            for (it = m_apps.begin(); it != m_apps.end(); ++it)
                if (it->second->m_name == product)
                    unSelectApp(it->second, selected);
            QCheckListItem* child = (QCheckListItem*)selItem->firstChild();
            for (int i = 0; i < selItem->childCount(); i++)
            {
                unSelectChild(child, selected);
                child = (QCheckListItem*)child->nextSibling();
            }
            bool allChecked = true;
            bool allUnchecked = true;
            child = (QCheckListItem*)selItem->parent()->firstChild();
            while (child != 0)
            {
                if (child->isOn())
                    allUnchecked = false;
                else
                    allChecked = false;
                child = (QCheckListItem*)child->nextSibling();
            }
            child = (QCheckListItem*)selItem->parent();
            if (allUnchecked)
                child->setOn(false);
            else if (allChecked)
                child->setOn(false);
            else
            {
                //child->setTristate(true);
                child->setState(QCheckListItem::NoChange);
                //child->setTristate(false);
            }
        }
        m_table->setNumCols(4);
        m_table->setNumRows(0);
        m_table->horizontalHeader()->setLabel(0, tr("Application"));
        m_table->horizontalHeader()->setLabel(1, tr("Language"));
        m_table->setColumnReadOnly(1, true);
        m_table->horizontalHeader()->setLabel(2, tr("Version"));
        m_table->setColumnReadOnly(2, true);
        m_table->horizontalHeader()->setLabel(3, tr("Description"));
        m_table->setColumnReadOnly(3, true);
        map<QString, CustomApplication*>::iterator it;
        int num = 0;
        for (it = m_apps.begin(); it != m_apps.end(); ++it)
        {
            if (it->second->m_name == product)
            {
                m_table->setNumRows(num + 1);
                ESCheckTableItem* itm = new ESCheckTableItem(m_table, it->second->m_id, this);
                itm->setChecked(it->second->m_isSelected);
                m_table->setItem(num, 0, itm);
                m_table->setText(num, 1, m_info->m_languages[(int)it->second->m_language]);
                ESTableItem* item = new ESTableItem(m_table, QTableItem::Never,
                    it->second->m_version);
                m_table->setItem(num, 2, item);
                QString desc = it->second->m_descr;
                desc = desc.replace('\n', ' ');
                item = new ESTableItem(m_table, QTableItem::Never, desc);
                m_table->setItem(num, 3, item);
                num++;
            }
        }
        checkParents((QCheckListItem*)selItem->parent());
        m_listTree->repaintItem(m_listTree->firstChild());
    }
    else if (selItem->parent()->parent()->text(0) == tr("Custom applications"))
    {
        m_patchSelected = false;
        m_appName = selItem->text(0);
        QString appName = m_appName;
        CustomApplication* app = m_apps.find(appName)->second;
        bool checked = selItem->isOn();
        if (app->m_isSelected != checked)
        {
            unSelectApp(app, checked);
            unSelectChild(selItem, checked);
            //checkRoot();
        }
        checkParents((QCheckListItem*)selItem->parent());
        m_table->setNumCols(4);
        m_table->setNumRows(0);
        m_table->horizontalHeader()->setLabel(0, tr("Patch"));
        m_table->horizontalHeader()->setLabel(1, tr("Language"));
        m_table->setColumnReadOnly(1, true);
        m_table->horizontalHeader()->setLabel(2, tr("Risk"));
        m_table->setColumnReadOnly(2, true);
        m_table->horizontalHeader()->setLabel(3, tr("Description"));
        m_table->setColumnReadOnly(3, true);
        map<QString, CustomPatch*>::iterator it;
        int num = 0;
        for (it = app->m_patches.begin(); it != app->m_patches.end(); ++it)
        {
            m_table->setNumRows(num + 1);
            ESCheckTableItem* itm = new ESCheckTableItem(m_table, it->second->m_name, this);
            itm->setChecked(it->second->m_isSelected);
            m_table->setItem(num, 0, itm);
            m_table->setText(num, 1, m_info->m_languages[(int)it->second->m_app->m_language]);
            if (it->second->m_isServicePack)
            {
                m_table->setText(num, 2, "");
            }
            else
            {
                m_table->setText(num, 2, m_info->m_risks[(int)it->second->m_risk]);
            }
            QString desc = it->second->m_descr;
            desc = desc.replace('\n', ' ');
            ESTableItem* item = new ESTableItem(m_table, QTableItem::Never, desc);
            m_table->setItem(num, 3, item);
            num++;
        }
    }
    else
    {
        m_appName = selItem->parent()->text(0);
        QString appName = m_appName;
        QString name = selItem->text(0);
        CustomApplication* app = m_apps.find(appName)->second;
        bool checked = selItem->isOn();
        CustomPatch* patch = app->m_patches.find(name)->second;
        /*if (patch->m_isSelected != checked)
        {
            checkApp((QCheckListItem*)selItem->parent(), app);
        }*/
        checkParents((QCheckListItem*)selItem->parent());
        patch->m_isSelected = checked;
        m_table->setNumCols(4);
        m_table->setNumRows(1);
        m_table->horizontalHeader()->setLabel(0, tr("Patch"));
        m_table->horizontalHeader()->setLabel(1, tr("Language"));
        m_table->setColumnReadOnly(1, true);
        m_table->horizontalHeader()->setLabel(2, tr("Risk"));
        m_table->setColumnReadOnly(2, true);
        m_table->horizontalHeader()->setLabel(3, tr("Description"));
        m_table->setColumnReadOnly(3, true);
        ESCheckTableItem* itm = new ESCheckTableItem(m_table, patch->m_name, this);
        itm->setChecked(patch->m_isSelected);
        m_table->setItem(0, 0, itm);
        m_table->setText(0, 1, m_info->m_languages[(int)patch->m_app->m_language]);
        if (patch->m_isServicePack)
        {
            m_table->setText(0, 2, "");
        }
        else
        {
            m_table->setText(0, 2, m_info->m_risks[(int)patch->m_risk]);
        }
        QString desc = patch->m_descr;
        desc = desc.replace('\n', ' ');
        ESTableItem* item = new ESTableItem(m_table, QTableItem::Never, desc);
        m_table->setItem(0, 3, item);
        //m_currentPatch = patch;
        m_patchSelected = true;
    }
    restoreConfigTable();  // T: BUGFIX #24478
    m_table->setUpdatesEnabled(true);
    m_table->repaint();
}

void ImportWizard::onValueChanged(int row, int col)
=====================================================================
Found a 358 line (1693 tokens) duplication in the following files: 
Starting at line 217 of D:\home\eCora_PM\PM\network\Http.cc
Starting at line 213 of D:\home\eCora_PM\PM\network\network\Http.cc

            return redirect(locationUrl, url, content, outputFile, httpRes);
        }
    }
    
    Result::Status status = 
        (result == 0 && code == 200) ? Result::Success : Result::Error;

    if (m_aborted == true)
        status = Result::Cancelled;
    
    if (status == Result::Success)
    {
        //long time;
        CURLcode res = curl_easy_getinfo(m_handle, CURLINFO_FILETIME, &fileTime);
        if (res != CURLE_OK)
            fileTime = 0;
    }
    
    if (httpRes != 0)
        *httpRes = new HttpResult(code, status, desc, fileTime);
    
    if (outputFile.empty() && content != 0)
    {
        fseek(bodyHandle, 0L, SEEK_SET);
        
        // Read the body of the file in the provided string.
        struct io_stat buf;
        io_fstat(fileno(bodyHandle), &buf);
        content->resize(buf.st_size);
        
        fread(&((*content)[0]), buf.st_size, 1, bodyHandle);
    }
    
    curl_easy_setopt(m_handle, CURLOPT_URL, 0);
    curl_easy_setopt(m_handle, CURLOPT_ERRORBUFFER, 0);
    
    return (status == Result::Success);
}

bool
HttpPrivate::redirect(
    const wstring& locationUrl, const wstring& url, bstring* content, 
    const wstring& file, com::NetworkResult** result)
{
    // find out the host from the initial url and append it if necessary
    wstring protocolHost;
    if (locationUrl.find(L"://") == wstring::npos)
    {
        //we need the host
        wstring::size_type end;
        end = url.find(L"://");
        end = url.find(L"/", end + 3);
        protocolHost = url.substr(0, end);
    }
    return doUrl(protocolHost + locationUrl, content, file, result);
}

int
HttpPrivate::decodeHeader(FILE* headerHandle, wstring& description, wstring& locationUrl,
                          AuthenticationType& authType)
{
    authType = NONE;

    fseek(headerHandle, 0L, SEEK_END);
    int headerSize = ftell(headerHandle);
    auto_ptr<char> buf(new char[headerSize + 1]);
    
    fseek(headerHandle, 0L, SEEK_SET);
    size_t n = fread(buf.get(), 1, headerSize, headerHandle);
    buf.get()[n] = '\0';
    wstring line = utf8s2ws(buf.get());
    
    if ((line.length() < 15) || (line.substr(0, 7) != L"HTTP/1."))
    {
        description = L"";
        return 0;
    }
    
    // Find the location of the first newline.
    wstring::size_type nlpos = min(line.find(L'\n'), line.find(L'\r'));
    description = line.substr(13, nlpos - 13);
    int code = wstring2int(line.substr(9, 3));


    //  If the proxy authentication code shows up and we are using
    //  NTLM authentication, we should probaby look for a "second" 
    //  header...

    if (code == 407)
    {
        wstring::size_type nextHttp = line.find(L"HTTP/1.", 7);
        if (nextHttp != wstring::npos)
        {
            //  Forget about the first header...
            line = line.substr(nextHttp);
            nlpos = min(line.find(L'\n'), line.find(L'\r'));
            description = line.substr(13, nlpos - 13);
            code = wstring2int(line.substr(9, 3));
        }
    }

    if (code == 302)
    {
        // find the line that starts with "Location: " and read the 
        // locationUrl
        wstring::size_type begin, end;
        const wstring location(L"Location: ");
        begin = line.find(location);
        if (begin == wstring::npos)
        {
            description = L"";
            return 0;
        }
        end = min(line.find(L"\n", begin + location.size()),
                  line.find(L"\r", begin + location.size()));
        locationUrl = line.substr(begin + location.size(), 
                                  end - begin - location.size());
    }

    return code;
}

bool 
HttpPrivate::callLoginAgent(HttpLogin* login, const wstring& url)
{
    return login->login(m_client, url);
}

bool
HttpPrivate::url2wstring(
    const wstring& url, wstring* content, 
    com::NetworkResult** result, bool tryLogin)
{
    using namespace intercept;
    
    bstring bcontent;
    HttpResult* myres;
    
    m_bTryNTLM = false;
    bool ret = doUrl(
        url, &bcontent, L"", reinterpret_cast<com::NetworkResult**>(&myres));
    
    if (content != 0)
        *content = bstring2wstring(bcontent);
    
    if (result != 0)
        *result = myres;
    
    if (myres->code() == 401 && tryLogin)
    {
        // Call the login callbacks
        set<HttpLogin*>::iterator it;
        for (it = m_loginAgents.begin(); it != m_loginAgents.end(); ++it)
        {
            bool tryAgain = inGuiThread<bool>(memberFunction<bool>(
                *this, &HttpPrivate::callLoginAgent, *it, url));
            
            //BUG FIX #13993
            if (m_aborted) 
            {
                myres->setStatus(Result::Cancelled);
            }

            if (tryAgain && 
                (ret = url2wstring(url, content, result, false)) == true)
                break;
        }
    }
    
    return ret;
}


bool
HttpPrivate::url2file(
    const wstring& url, const wstring& file, 
    com::NetworkResult** result, bool tryLogin)
{
    using namespace intercept;
    
    HttpResult* myres;
    
    int ret = doUrl(
        url, 0, file, reinterpret_cast<com::NetworkResult**>(&myres));
    
    if (result != 0)
        *result = myres;
    
    if (myres->code() == 401 && tryLogin)
    {
        // Call the login callbacks
        set<HttpLogin*>::iterator it;
        for (it = m_loginAgents.begin(); it != m_loginAgents.end(); ++it)
        {
            bool tryAgain = inGuiThread<bool>(memberFunction<bool>(
                *this, &HttpPrivate::callLoginAgent, *it, url));
            
            if (tryAgain && 
                (ret = url2file(url, file, result, false)) == true)
                break;
        }
    }
    
    return ret;
}

Http::Http(const wstring& cookies, const wstring& userAgentLocation, 
           IUnknown* pUnkOuter) 
{
    p = new HttpPrivate(this, cookies, userAgentLocation, pUnkOuter);
}

Http::~Http()
{
    delete p;
}

HRESULT
Http::QueryInterface(const GUID& iid, void** iface)
{
    IUnknown* outer = p->m_comBase.getUnkOuter();
    if (outer != 0)
    {
        return outer->QueryInterface(iid, iface);
    }
    else if (iid == IID_IUnknown)
    {
        *iface = (IUnknown*)this;
        AddRef();
        return NO_ERROR;
    }
    else if (iid == IID_INetwork)
    {
        *iface = (com::INetwork*)this;
        AddRef();
        return NO_ERROR;
    }
    else
    {
        *iface = 0;
        return E_NOINTERFACE;
    }
}

unsigned long
Http::AddRef()
{
    return p->m_comBase.addRef();
}

unsigned long
Http::Release()
{
    return p->m_comBase.release(this);
}

bool
Http::url2wstring(
    const wstring& url, wstring* content, bool runInThread, 
    com::NetworkResult** result)
{
    using namespace intercept;
    
    p->setAborted(false);
    int ret = 0;
    
    if (runInThread)
        ret = inThread<int>(memberFunction<int>(
            *p, &HttpPrivate::url2wstring, url, content, result, true));
    else
        ret = p->url2wstring(url, content, result, true);
    
    return ret;
}

bool
Http::url2file(
    const wstring& url, const wstring& file, bool runInThread, 
    com::NetworkResult** result)
{
    using namespace intercept;
    
    p->setAborted(false);
    int ret = 0;
    
    if (runInThread)
        return inThread<int>(memberFunction<int>(
            *p, &HttpPrivate::url2file, url, file, result, true));
    else
        return p->url2file(url, file, result, true);
    
    return ret;
}

void
Http::useProxy(
    const wstring& addr, const wstring& login, const wstring& pass,
    const bool useNTLM)
{
    p->useProxy(addr, login, pass, useNTLM);
}

void
Http::setCredentials(
    const wstring& login, const wstring& pass)
{
    p->setCredentials(login, pass);
}

void
Http::addListener(com::NetworkListener* listener)
{
    p->addListener(listener);
}

void
Http::removeListener(com::NetworkListener* listener)
{
    p->removeListener(listener);
}

void
Http::addLoginAgent(HttpLogin* login)
{
    p->m_loginAgents.insert(login);
}

void
Http::removeLoginAgent(HttpLogin* login)
{
    p->m_loginAgents.erase(login);
}

void
Http::setConnectionTimeout(int timeInSeconds)
{
    p->setConnectionTimeout(timeInSeconds);
}

void
Http::setOperationTimeout(int timeInSeconds)
{
    p->setOperationTimeout(timeInSeconds);
}

void
Http::abort()
{
    p->setAborted(true);
}

void
Http::freeResult(com::NetworkResult* result) const
{
    delete result;
}

} // namespace network
=====================================================================
Found a 331 line (1682 tokens) duplication in the following files: 
Starting at line 37 of D:\home\eCora_PM\PM\network\PtyConnection.cpp
Starting at line 37 of D:\home\eCora_PM\PM\network\network\PtyConnection.cpp

using namespace smuggle;

namespace network {    
    
PtyConnection::PtyConnection(IUnknown* appIf) :
    m_appIface(appIf),
    m_host(NULL),
    m_installationDirectory(L"."),
    m_connected(false)
{ 
    m_binDirectory = m_installationDirectory + L"/bin";
}

PtyConnection::~PtyConnection()
{
}

void
PtyConnection::login(const bstring& userName, const bstring& password)
{
    log(L"PtyConnection::login", Log::Debug,
	L"Login to remote server.");
	
    vector<pair<bstring, int> > possible;
    possible.push_back(pair<bstring, int>("(yes/no)? ", QUESTION));
    possible.push_back(pair<bstring, int>("(yes/no)?", QUESTION));
    possible.push_back(pair<bstring, int>("(y/n)?", QUESTION));
    possible.push_back(pair<bstring, int>("? (y/n)", QUESTION));
    possible.push_back(pair<bstring, int>("? (yes/no)", QUESTION));
    
    // Various ways of prompting for a user name:
    possible.push_back(pair<bstring, int>("ogin:", USER));
    possible.push_back(pair<bstring, int>("login as:", USER));
    possible.push_back(pair<bstring, int>("OGIN:", USER));
    possible.push_back(pair<bstring, int>("ame:", USER));
    possible.push_back(pair<bstring, int>("AME:", USER));
    possible.push_back(pair<bstring, int>("Name (", USER));
 
    // Various ways of prompting for a password:
    possible.push_back(pair<bstring, int>("word:", PASSWORD));
    possible.push_back(pair<bstring, int>("WORD:", PASSWORD));
    possible.push_back(pair<bstring, int>("phrase:", PASSWORD));
    possible.push_back(pair<bstring, int>("PHRASE:", PASSWORD));
    possible.push_back(pair<bstring, int>("passphrase", PASSWORD));

    possible.push_back(pair<bstring, int>("ogin incorr", FAILURE));
    possible.push_back(pair<bstring, int>("Connection refused", FAILURE));
    possible.push_back(pair<bstring, int>("Unknown host", FAILURE));
    possible.push_back(pair<bstring, int>("Authentication refused", FAILURE));
    m_host->setTimeout(THIRTY_SECOND_TIMEOUT);

    while (true)
    { 
	try
	{
            int code = m_host->match(possible);
            if (code == QUESTION)
	    {
 	        wstring response = bstring2wstring(m_host->data());
		wstring logMessage = L"Received question:  " + response +
		    L"   :   Send 'yes'";
		log(L"Connection::login", Log::Debug, logMessage);
#ifdef WIN32
                m_host->send("y\r\n");
#else
                m_host->send("yes\r\n");
#endif
 	    }
            else if (code == USER)
	    {
		wstring logMessage = L"Send username: " +
		    bstring2wstring(userName);
		
                log(L"PtyConnection::login", Log::Debug, logMessage);
                m_host->send(userName + "\r\n");
	    }
            else if (code == PASSWORD)
            {
                log(L"PtyConnection::login", Log::Debug, L"Sending password, cleaning stuff remained...");
                m_host->cleanupData();//23733
                log(L"PtyConnection::login", Log::Debug, L"Cleaned....");
                m_host->sendPassword(password + "\r\n");
                log(L"PtyConnection::login", Log::Debug, L"Password sent.");
                break;
            }
            else if (code == FAILURE)
            {
                throwLoginException(m_host->data());
            }
	}
        catch (Timeout&)
        { 
 	    bstring response = m_host->data();
	    if (response.find("Login incorrect") != bstring::npos)
	        throw RemoteLoginError(__FILE__, __LINE__,
			    L"PtyConnection::login()",
			    m_connectionString,
			    L"Remote login failed. Sending user/password. "
                            L"Host Response:\n" + 
                                bstring2wstring(m_host->data()));
	    
            //  We have a timeout but we don't know why.  At this point
            //  we will try to continue thinking that we may already be
            //  in.
 	    break;
        }
    }
    
    return;
}

void
PtyConnection::loginWithoutUsernamePassword()
{
    log(L"PtyConnection::loginWithoutUsernamePassword", Log::Info, L"");

    vector<pair<bstring, int> > possible;

    // Potential prompts...
    possible.push_back(pair<bstring, int>("#", PROMPT));
    possible.push_back(pair<bstring, int>("$", PROMPT));
    possible.push_back(pair<bstring, int>("%", PROMPT));
    possible.push_back(pair<bstring, int>(">", PROMPT));

    // Putty will send these messages after connecting and before
    // starting the shell...  We're close enough at this point.
    possible.push_back(pair<bstring, int>("Started a shell", ALMOST));
    possible.push_back(pair<bstring, int>("Started session", ALMOST));
    

    // Potential Questions...
    possible.push_back(pair<bstring, int>("(yes/no)?", QUESTION));
    possible.push_back(pair<bstring, int>("(y/n)?", QUESTION));
    possible.push_back(pair<bstring, int>("? (y/n)", QUESTION));
    possible.push_back(pair<bstring, int>("? (yes/no)", QUESTION));
    possible.push_back(pair<bstring, int>("Store key in cache? (y/n)",
					  QUESTION));
    possible.push_back(pair<bstring, int>("ontinue connecting",
                       QUESTION));

    possible.push_back(pair<bstring, int>("FATAL ERROR", FAILURE));
	    
    //  Every 10 seconds check to see if someone has hit the stop button
    //  and return if they have.  Allow up to a total of 100 seconds to 
    //  get the proper response back from the remote system.  
    m_host->setTimeout(TEN_SECOND_TIMEOUT);
    int doItTenTimes = 10;

    while (true)
    {
        try
        {
            int code = m_host->match(possible);

            //  In this case your done...
            if (code == PROMPT)
                return;

            //  Give the profile time to run...
            if (code == ALMOST)
            {
                Sleep(5000);
                return;
            }

            //  This is most likely a fingerprint problem and is asking
            //  if we would like to continue.   In this case we would.
            if (code == QUESTION)
            {
                log(L"PtyConnection::connectTo", Log::Debug,
		        L"Host key was not cached.  Send 'y'");
		
                m_host->send("y\n");
            }

            if (code == FAILURE)
            {
                throw RemoteLoginError(__FILE__, __LINE__,
                    L"PtyConnection::loginWithoutUsernamePassword()",
	            m_connectionString,
	            L"Remote connection failed.  "
                    L"Host response:\n" + bstring2wstring(m_host->data()));
            }
        }

        catch (Timeout&)
        {
            if (--doItTenTimes > 0)
            {
                //  if (m_collector->checkCancel())
                //      return;
            }
            else
            {
                //   Not sure what is happening.   Looks like smuggle may not
                //   be getting the entire message.  
 	        wstring logMessage =
		    L"SSH login no prompt: Host response is: " +
		    bstring2wstring(m_host->data()) +
		    L".  Assume we are connected.";
	        log(L"PtyConnection::loginWithoutUsernamePassword", Log::Debug, logMessage);
                return;
            }
        }
    } //  End while true...
}

void 
PtyConnection::delayAndWaitForPrompt(const int delay, 
                                     const bstring& prompt,
                                     const int timeout)
{
    wstring logMessage = L" Delay: " + int2wstring(delay) +
        L"  Prompt: " + bstring2wstring(prompt) + 
        L"  Timeout: " + int2wstring(timeout);
    log(L"PtyConnection::delayAndWaitForPrompt", Log::Debug, logMessage);

    m_host->setTimeout(timeout);
 
    if (delay)
        Sleep(delay * 1000);

    bstring afterLogin = m_host->dataPlusBuffer();
    if ((afterLogin.find("ogin incorr") != bstring::npos) ||
        (afterLogin.find("onnection refused") != bstring::npos) ||
        (afterLogin.find("nknown host") != bstring::npos) ||
        (afterLogin.find("Authentication refused") != bstring::npos) ||
        (afterLogin.find("ccess denied") != bstring::npos))
    {
        throwLoginException(afterLogin);
    }

    if (!prompt.empty())
    {
        m_host->setTimeout(timeout);
        vector<pair<bstring, int> > possible;

        if (afterLogin.find(prompt) == bstring::npos)
        {

        // Potential prompts...
            possible.push_back(pair<bstring, int>(prompt, PROMPT));

            possible.push_back(pair<bstring, int>("ogin incorr", FAILURE));
            possible.push_back(pair<bstring, int>("onnection refused", FAILURE));
            possible.push_back(pair<bstring, int>("Authentication refused", FAILURE));
            possible.push_back(pair<bstring, int>("nknown host", FAILURE));
            possible.push_back(pair<bstring, int>("ccess denied", FAILURE));

            try
            {
                int code = m_host->match(possible);

                if (code == FAILURE)
                {
                    throwLoginException(m_host->data());
                }

            }
            catch (Timeout&)
            {
                throw RemoteLoginError(__FILE__, __LINE__,
                    L"PtyConnection::delayAndWaitForPrompt()",
	            m_connectionString,
	            L"Remote connection failed.  Failed to identify prompt: " + 
                    bstring2wstring(prompt) +
                    L"  Host response:" + L"\n" + bstring2wstring(m_host->data()));
            }
        }
    }
}


void
PtyConnection::setTimeout(const int seconds)
{
    m_host->setTimeout(seconds);
}

void
PtyConnection::send(const bstring message)
{
    m_host->send(message);
}

bstring
PtyConnection::getBuffer()
{
    return m_host->data();
}

void 
PtyConnection::setInstallationDirectory(wstring installationDirectory)
{
    m_installationDirectory = installationDirectory;
}

void
PtyConnection::deleteHost()
{
    if (m_host != NULL)
        delete m_host;
    m_host = NULL;
}

void
PtyConnection::throwLoginException(const bstring& failureString)
{
    wstring failure = L"Remote connection failed.  ";

    if (failureString.find("ogin incorr") != bstring::npos)
        failure += L"Login incorrect";
    else if (failureString.find("ccess denied") != bstring::npos)
        failure += L"Access denied";
    else if (failureString.find("Authentication refused") != bstring::npos)
        failure += L"Authentication refused";
    else if (failureString.find("onnection refused") != bstring::npos)
        failure += L"Connection refused";
    else if (failureString.find("nknown host") != bstring::npos)
        failure += L"Unknown host";
    else 
        failure += L"Host response was:\n" + bstring2wstring(failureString);
                    
    throw RemoteLoginError(__FILE__, __LINE__,
            L"PtyConnection::throwLoginException()",
	    m_connectionString, failure);

}


}  // End namespace connections
=====================================================================
Found a 265 line (1588 tokens) duplication in the following files: 
Starting at line 564 of D:\home\eCora_PM\PM\pmDaoDbImpl\DaoDbImplUnitTest.h
Starting at line 727 of D:\home\eCora_PM\PM\pmDaoXmlImpl\DaoXmlImplUnitTest.h

        iProduct->setLanguage(L"ENU");
        iProduct->setStatus(0);
    }

    void iterateForwardThroughSystemObjectGraph(pmDaoInterfaces::ISystem* iSystem)
    {
        bool moreSystems = iSystem->first();
        while (moreSystems)
        {
            wstring scanId = iSystem->getScanId();
            wstring systemScanId = iSystem->getSystemScanId();
            wstring systemId = iSystem->getSystemId();
            wstring computerName = iSystem->getName();
            wstring ipAddress = iSystem->getIpAddress();
            wstring os = iSystem->getOs();
            wstring osVersionId = iSystem->getOsVersionId();
            wstring osLanguage = iSystem->getOsLanguage();
            wstring status = iSystem->getStatus();
            int isServer = iSystem->getServer();

            pmDaoInterfaces::IWindowsSystemExtension* iWindowsSystemExtension = iSystem->getWindowsSystemExtension();

            TS_ASSERT(iWindowsSystemExtension->first());

            TS_ASSERT(iWindowsSystemExtension->getDomain() == L"BSP");
            TS_ASSERT(iWindowsSystemExtension->getWinDir() == L"C:\\WINNT40");
            TS_ASSERT(iWindowsSystemExtension->getSqlDir() == L"C:\\Program Files\\Microsoft SQL Server\\MSSQL");
            TS_ASSERT(iWindowsSystemExtension->getSqlSharedCodeDir() ==
                L"C:\\Program Files\\Microsoft SQL Server\\80\\COM\\");
            TS_ASSERT(iWindowsSystemExtension->getExchangeDir() == L"C:\\Program Files\\Exchange 2000\\");
            TS_ASSERT(iWindowsSystemExtension->getProgramFilesDir() == L"C:\\Program Files");
            TS_ASSERT(iWindowsSystemExtension->getCommonFilesDir() == L"C:\\Program Files\\Common Files");

            TS_ASSERT(!iWindowsSystemExtension->next());

            pmDaoInterfaces::IActivity* iActivity = iSystem->getActivities();

            bool moreActivities = iActivity->first();
            while (moreActivities)
            {
                wstring productInstance = iActivity->getProductInstance();
                wstring patchId = iActivity->getPatchId();
                wstring versionId = iActivity->getProductVersionId();
                wstring source = iActivity->getSource();
                wstring status = iActivity->getStatus();
                wstring comment = iActivity->getComment();

                moreActivities = iActivity->next();
            }

            pmDaoInterfaces::IProduct* iProduct = iSystem->getProducts();

            bool moreProducts = iProduct->first();
            while (moreProducts)
            {
                wstring versionId = iProduct->getVersionId();
                wstring systemScanId = iProduct->getSystemScanId();
                wstring name = iProduct->getName();
                wstring version = iProduct->getVersion();
                wstring instance = iProduct->getInstance();
                wstring location = iProduct->getLocation();
                wstring language = iProduct->getLanguage();
                //int status = iProduct->getStatus();

                pmDaoInterfaces::IPatch* iPatch = iProduct->getPatches();

                bool morePatches = iPatch->first();
                while (morePatches)
                {
                    wstring systemScanId = iPatch->getSystemScanId();
                    wstring patchId = iPatch->getPatchId();
                    wstring instance = iPatch->getInstance();
                    wstring comment = iPatch->getComment();
                    wstring status = iPatch->getStatus();
                    wstring uninstallString = iPatch->getUninstallData();

                    morePatches = iPatch->next();
                }

                moreProducts = iProduct->next();
            }

            moreSystems = iSystem->next();
        }
    }

    void iterateBackwardsThroughSystemObjectGraph(pmDaoInterfaces::ISystem* iSystem)
    {
        bool moreSystems = iSystem->last();
        while (moreSystems)
        {
            wstring scanId = iSystem->getScanId();
            wstring systemScanId = iSystem->getSystemScanId();
            wstring systemId = iSystem->getSystemId();
            wstring computerName = iSystem->getName();
            wstring ipAddress = iSystem->getIpAddress();
            wstring os = iSystem->getOs();
            wstring osVersionId = iSystem->getOsVersionId();
            wstring osLanguage = iSystem->getOsLanguage();
            wstring status = iSystem->getStatus();
            int isServer = iSystem->getServer();

            pmDaoInterfaces::IWindowsSystemExtension* iWindowsSystemExtension = iSystem->getWindowsSystemExtension();

            TS_ASSERT(iWindowsSystemExtension->first());

            TS_ASSERT(iWindowsSystemExtension->getDomain() == L"BSP");
            TS_ASSERT(iWindowsSystemExtension->getWinDir() == L"C:\\WINNT40");
            TS_ASSERT(iWindowsSystemExtension->getSqlDir() == L"C:\\Program Files\\Microsoft SQL Server\\MSSQL");
            TS_ASSERT(iWindowsSystemExtension->getSqlSharedCodeDir() ==
                L"C:\\Program Files\\Microsoft SQL Server\\80\\COM\\");
            TS_ASSERT(iWindowsSystemExtension->getExchangeDir() == L"C:\\Program Files\\Exchange 2000\\");
            TS_ASSERT(iWindowsSystemExtension->getProgramFilesDir() == L"C:\\Program Files");
            TS_ASSERT(iWindowsSystemExtension->getCommonFilesDir() == L"C:\\Program Files\\Common Files");

            TS_ASSERT(!iWindowsSystemExtension->next());

            pmDaoInterfaces::IActivity* iActivity = iSystem->getActivities();

            bool moreActivities = iActivity->last();
            while (moreActivities)
            {
                wstring productInstance = iActivity->getProductInstance();
                wstring patchId = iActivity->getPatchId();
                wstring versionId = iActivity->getProductVersionId();
                wstring source = iActivity->getSource();
                wstring status = iActivity->getStatus();
                wstring comment = iActivity->getComment();

                moreActivities = iActivity->prev();
            }

            pmDaoInterfaces::IProduct* iProduct = iSystem->getProducts();

            bool moreProducts = iProduct->last();
            while (moreProducts)
            {
                wstring versionId = iProduct->getVersionId();
                wstring systemScanId = iProduct->getSystemScanId();
                wstring name = iProduct->getName();
                wstring version = iProduct->getVersion();
                wstring instance = iProduct->getInstance();
                wstring location = iProduct->getLocation();
                wstring language = iProduct->getLanguage();
                //int status = iProduct->getStatus();

                pmDaoInterfaces::IPatch* iPatch = iProduct->getPatches();

                bool morePatches = iPatch->last();
                while (morePatches)
                {
                    wstring systemScanId = iPatch->getSystemScanId();
                    wstring patchId = iPatch->getPatchId();
                    wstring instance = iPatch->getInstance();
                    wstring comment = iPatch->getComment();
                    wstring status = iPatch->getStatus();
                    wstring uninstallString = iPatch->getUninstallData();

                    morePatches = iPatch->prev();
                }

                moreProducts = iProduct->prev();
            }

            moreSystems = iSystem->prev();
        }
    }

    void recursivelyLoadSystemObjectGraph(pmDaoInterfaces::ISystem* iSystem)
    {
        bool moreSystems = iSystem->first();
        while (moreSystems)
        {
            wstring scanId = iSystem->getScanId();
            wstring systemScanId = iSystem->getSystemScanId();
            wstring systemId = iSystem->getSystemId();
            wstring computerName = iSystem->getName();
            wstring ipAddress = iSystem->getIpAddress();
            wstring os = iSystem->getOs();
            wstring osVersionId = iSystem->getOsVersionId();
            wstring osLanguage = iSystem->getOsLanguage();
            wstring status = iSystem->getStatus();
            int isServer = iSystem->getServer();

            iSystem->loadRelatedEntities();

            pmDaoInterfaces::IWindowsSystemExtension* iWindowsSystemExtension = iSystem->getWindowsSystemExtension();

            TS_ASSERT(iWindowsSystemExtension->first());

            TS_ASSERT(iWindowsSystemExtension->getDomain() == L"BSP");
            TS_ASSERT(iWindowsSystemExtension->getWinDir() == L"C:\\WINNT40");
            TS_ASSERT(iWindowsSystemExtension->getSqlDir() == L"C:\\Program Files\\Microsoft SQL Server\\MSSQL");
            TS_ASSERT(iWindowsSystemExtension->getSqlSharedCodeDir() ==
                L"C:\\Program Files\\Microsoft SQL Server\\80\\COM\\");
            TS_ASSERT(iWindowsSystemExtension->getExchangeDir() == L"C:\\Program Files\\Exchange 2000\\");
            TS_ASSERT(iWindowsSystemExtension->getProgramFilesDir() == L"C:\\Program Files");
            TS_ASSERT(iWindowsSystemExtension->getCommonFilesDir() == L"C:\\Program Files\\Common Files");

            TS_ASSERT(!iWindowsSystemExtension->next());

            pmDaoInterfaces::IActivity* iActivity = iSystem->getActivities();

            TS_ASSERT(iActivity->count() == 3);

            bool moreActivities = iActivity->first();
            while (moreActivities)
            {
                wstring productInstance = iActivity->getProductInstance();
                wstring patchId = iActivity->getPatchId();
                wstring versionId = iActivity->getProductVersionId();
                wstring source = iActivity->getSource();
                wstring status = iActivity->getStatus();
                wstring comment = iActivity->getComment();
                
                moreActivities = iActivity->next();
            }

            pmDaoInterfaces::IProduct* iProduct = iSystem->getProducts();

            TS_ASSERT(iProduct->count() == 2);

            bool moreProducts = iProduct->first();
            while (moreProducts)
            {
                wstring versionId = iProduct->getVersionId();
                wstring systemScanId = iProduct->getSystemScanId();
                wstring name = iProduct->getName();
                wstring version = iProduct->getVersion();
                wstring instance = iProduct->getInstance();
                wstring location = iProduct->getLocation();
                wstring language = iProduct->getLanguage();
                //int status = iProduct->getStatus();
                
                iProduct->loadRelatedEntities();
                
                pmDaoInterfaces::IPatch* iPatch = iProduct->getPatches();
                
                TS_ASSERT(iPatch->count() == 2);
                
                bool morePatches = iPatch->first();
                while (morePatches)
                {
                    wstring systemScanId = iPatch->getSystemScanId();
                    wstring patchId = iPatch->getPatchId();
                    wstring instance = iPatch->getInstance();
                    wstring comment = iPatch->getComment();
                    wstring status = iPatch->getStatus();
                    wstring uninstallString = iPatch->getUninstallData();
                    
                    morePatches = iPatch->next();
                }
                
                moreProducts = iProduct->next();
            }
            
            moreSystems = iSystem->next();
        }
    }

  private:
    static int m_trigger;
};

static DaoXmlImplUnitTest DaoXmlImplUnitTestTrigger;
=====================================================================
Found a 302 line (1402 tokens) duplication in the following files: 
Starting at line 30 of D:\home\eCora_PM\PM\network\Ftp.cc
Starting at line 30 of D:\home\eCora_PM\PM\network\network\Ftp.cc

namespace network {

class FtpPrivate : public CurlImpl
{
  public:

    FtpPrivate(IUnknown* pUnkOuter);
    ~FtpPrivate();

    bool url2wstring(
	const wstring& url, wstring* content, com::NetworkResult** result);
    bool url2file(
	const wstring& url, const wstring& file, com::NetworkResult** result);
    bool doUrl(
	const wstring& url, bstring* content, 
	const wstring& outputFile, com::NetworkResult** result);

    com::BaseObject m_comBase;
};

FtpPrivate::FtpPrivate(IUnknown* pUnkOuter)
    : CurlImpl(L""), m_comBase(pUnkOuter, false)
{
}

FtpPrivate::~FtpPrivate()
{
}

static void
closeAndUnlink(FILE* fp, const wstring& filename)
{
    fclose(fp);
    unlink(ws2utf8s(filename).c_str());
}

bool
FtpPrivate::doUrl(
    const wstring& in_url, bstring* content, 
    const wstring& outputFile, com::NetworkResult** result)
{
    m_aborted = false;

    int code = 0;
    auto_ptr<char> url_cstr;
    auto_ptr<char> userpass_cstr;

    FILE* bodyHandle = 0;
    FILE* headerHandle = 0;

    // Be ready to receive an error message.
    char error[CURL_ERROR_SIZE + 1];
    memset(error, 0, CURL_ERROR_SIZE);
    curl_easy_setopt(m_handle, CURLOPT_ERRORBUFFER, error);

    wstring username = m_login;
    wstring password = m_password;
    wstring url = in_url;

    if (username.empty())
	username = L"anonymous";
    if (password.empty())
	password = L"info@ecora.com";

    wstring::size_type loginIndex = url.rfind(L"@");
    if (loginIndex != wstring::npos)
    {
	wstring::size_type loginSep = url.find(L":", 6);
	username = url.substr(6, loginSep - 6);
	password = url.substr(loginSep + 1, loginIndex - loginSep - 1);
	url = L"ftp://" + url.substr(loginIndex + 1);
    }
    
    url_cstr = auto_ptr<char>(strdup(ws2utf8s(url).c_str()));
    curl_easy_setopt(m_handle, CURLOPT_URL, url_cstr.get());

    wstring userpass = username + L":" + password;
    userpass_cstr = auto_ptr<char>(strdup(ws2utf8s(userpass).c_str()));
    curl_easy_setopt(m_handle, CURLOPT_USERPWD, userpass_cstr.get());
    
    // Setup the file to capture the content information
    char bodyfilename[L_tmpnam + 1];
    strcpy(bodyfilename, tmpnam(NULL));
    wstring bodyFile = utf8s2ws(utf8string(bodyfilename));

    wstring outFile = outputFile;
    if (outFile.empty())
	outFile = bodyFile;
    
    bodyHandle = fopen(ws2utf8s(outFile).c_str(), "w+b");

    if (bodyHandle == 0)
	throw GenericException(
	    __FILE__, __LINE__, L"FtpPrivate::doUrl", L"",
	    L"Could not open: " + outputFile + L" for writing.");

    // Only one of these guards should be executed
    ScopeGuard delContent = makeGuard(closeAndUnlink, bodyHandle, outFile);
    ScopeGuard closeContent = makeGuard(fclose, bodyHandle);

    if (outputFile.empty())
	closeContent.dismiss();
    else
	delContent.dismiss();

    curl_easy_setopt(m_handle, CURLOPT_FILE, bodyHandle);
    curl_easy_setopt(m_handle, CURLOPT_FTPPORT, "-");
    long fileTime;
    curl_easy_setopt(m_handle, CURLOPT_FILETIME, &fileTime);

    CURLcode curl_result = curl_easy_perform(m_handle);

    wstring resultMessage;
    Result::Status status;

    if (curl_result == 0)
    {
	status = Result::Success;
	resultMessage = utf8s2ws(utf8string(error));
    }
    else
    {
	status = Result::Error;
	resultMessage = mapErrorMessage(curl_result);
    }
    if (m_aborted == true)
	status = Result::Cancelled;

    if (status == Result::Success)
    {
	CURLcode res = curl_easy_getinfo(m_handle, CURLINFO_FILETIME, &fileTime);
	if (res != CURLE_OK)
	    fileTime = 0;
    }

    if (*result != 0)
	*result = new Result(status, resultMessage, fileTime);

    if (outputFile.empty() && content != 0)
    {
	fseek(bodyHandle, 0L, SEEK_SET);
	
	// Read the body of the file in the provided string.
	struct io_stat buf;
	io_fstat(fileno(bodyHandle), &buf);
	content->resize(buf.st_size);
	
	fread(&((*content)[0]), buf.st_size, 1, bodyHandle);
    }
   
    curl_easy_setopt(m_handle, CURLOPT_URL, 0);
    curl_easy_setopt(m_handle, CURLOPT_ERRORBUFFER, 0);

    return (status == Result::Success);
}

bool
FtpPrivate::url2wstring(
    const wstring& url, wstring* content, com::NetworkResult** result)
{
    bstring bcontent;

    bool ret = doUrl(url, &bcontent, L"", result);
    
    if (content != 0)
	*content = bstring2wstring(bcontent);
    
    return ret;
}


bool
FtpPrivate::url2file(
    const wstring& url, const wstring& file, com::NetworkResult** result)
{
    return doUrl(url, 0, file, result);
}

Ftp::Ftp(IUnknown* pUnkOuter) 
{
    p = new FtpPrivate(pUnkOuter);
}

Ftp::~Ftp()
{
    delete p;
}

HRESULT
Ftp::QueryInterface(const GUID& iid, void** iface)
{
    IUnknown* outer = p->m_comBase.getUnkOuter();
    if (outer != 0)
	return outer->QueryInterface(iid, iface);
    else if (iid == IID_IUnknown)
    {
	*iface = (IUnknown*)this;
	AddRef();
	return NO_ERROR;
    }
    else if (iid == IID_INetwork)
    {
	*iface = (com::INetwork*)this;
	AddRef();
	return NO_ERROR;
    }
    else
    {
	*iface = 0;
	return E_NOINTERFACE;
    }
}

unsigned long
Ftp::AddRef()
{
    return p->m_comBase.addRef();
}

unsigned long
Ftp::Release()
{
    return p->m_comBase.release(this);
}

bool
Ftp::url2wstring(
    const wstring& url, wstring* content, 
    bool runInThread, com::NetworkResult** result)
{
    using namespace intercept;

    p->setAborted(false);
    int ret = 0;

    if (runInThread)
	ret = inThread<int>(memberFunction<int>(
            *p, &FtpPrivate::url2wstring, url, content, result));
    else
	ret = p->url2wstring(url, content, result);

    return ret;
}

bool
Ftp::url2file(
    const wstring& url, const wstring& file, 
    bool runInThread, com::NetworkResult** result)
{
    using namespace intercept;

    p->setAborted(false);
    int ret = 0;

    if (runInThread)
	return inThread<int>(memberFunction<int>(
            *p, &FtpPrivate::url2file, url, file, result));
    else
	return p->url2file(url, file, result);

    return ret;
}

void
Ftp::useProxy(
    const wstring& addr, const wstring& login, 
    const wstring& pass, const bool useNTLM)
{
    p->useProxy(addr, login, pass, useNTLM);
}

void
Ftp::addListener(com::NetworkListener* listener)
{
    p->addListener(listener);
}

void
Ftp::removeListener(com::NetworkListener* listener)
{
    p->removeListener(listener);
}

void
Ftp::abort()
{
    p->setAborted(true);
}

void
Ftp::freeResult(com::NetworkResult* result) const
{
    delete result;
}

void
Ftp::setCredentials(const wstring& login, const wstring& pass)
{
    p->setCredentials(login, pass);
}

} // namespace network
=====================================================================
Found a 272 line (1361 tokens) duplication in the following files: 
Starting at line 161 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\Blowfish.cpp
Starting at line 270 of D:\home\eCora_PM\PM\utils\Blowfish.cc

    return ret;
}


Blowfish::~Blowfish()
{
    delete m_PArray;
    delete [] m_SBoxes;
}


// The low level (private) encryption function.
void
Blowfish::encipher(unsigned long *xl, unsigned long *xr)
{
    union aword  Xl, Xr;

    Xl.dword = *xl;
    Xr.dword = *xr;

    Xl.dword ^= m_PArray [0];
    ROUND(Xr, Xl, 1);
    ROUND(Xl, Xr, 2);
    ROUND(Xr, Xl, 3);
    ROUND(Xl, Xr, 4);
    ROUND(Xr, Xl, 5);
    ROUND(Xl, Xr, 6);
    ROUND(Xr, Xl, 7);
    ROUND(Xl, Xr, 8);
    ROUND(Xr, Xl, 9);
    ROUND(Xl, Xr, 10);
    ROUND(Xr, Xl, 11);
    ROUND(Xl, Xr, 12);
    ROUND(Xr, Xl, 13);
    ROUND(Xl, Xr, 14);
    ROUND(Xr, Xl, 15);
    ROUND(Xl, Xr, 16);
    Xr.dword ^= m_PArray[17];

    *xr = Xl.dword;
    *xl = Xr.dword;
}


// The low level (private) decryption function.
void
Blowfish::decipher (unsigned long *xl, unsigned long *xr)
{
    union aword  Xl;
    union aword  Xr;

    Xl.dword = *xl;
    Xr.dword = *xr;

    Xl.dword ^= m_PArray[17];
    ROUND (Xr, Xl, 16);
    ROUND (Xl, Xr, 15);
    ROUND (Xr, Xl, 14);
    ROUND (Xl, Xr, 13);
    ROUND (Xr, Xl, 12);
    ROUND (Xl, Xr, 11);
    ROUND (Xr, Xl, 10);
    ROUND (Xl, Xr, 9);
    ROUND (Xr, Xl, 8);
    ROUND (Xl, Xr, 7);
    ROUND (Xr, Xl, 6);
    ROUND (Xl, Xr, 5);
    ROUND (Xr, Xl, 4);
    ROUND (Xl, Xr, 3);
    ROUND (Xr, Xl, 2);
    ROUND (Xl, Xr, 1);
    Xr.dword ^= m_PArray[0];

    *xl = Xr.dword;
    *xr = Xl.dword;
}


// Constructs the encryption sieve.
void
Blowfish::initialize(unsigned char key[], int keybytes)
{
    int i;
    int j;
    unsigned long data;
    unsigned long datal;
    unsigned long datar;
    union aword temp;

    m_PArray = new unsigned long[18];
    m_SBoxes = new unsigned long[4][256];

    // First fill arrays from data tables.
    for (i = 0; i < 18; i++)
	m_PArray[i] = bf_P[i];

    for (i = 0; i < 4; i++)
	for (j = 0; j < 256; j++)
	    m_SBoxes[i][j] = bf_S[i][j];

    j = 0;
    for (i = 0; i < NPASS + 2; ++i)
    {
	temp.dword = 0;
	temp.w.byte0 = key[j];
	temp.w.byte1 = key[(j + 1) % keybytes];
	temp.w.byte2 = key[(j + 2) % keybytes];
	temp.w.byte3 = key[(j + 3) % keybytes];
	data = temp.dword;
	m_PArray [i] ^= data;
	j = (j + 4) % keybytes;
    }

    datal = 0;
    datar = 0;

    for (i = 0; i < NPASS + 2; i += 2)
    {
	encipher(&datal, &datar);
	m_PArray[i] = datal;
	m_PArray[i + 1] = datar;
    }

    for (i = 0; i < 4; ++i)
    {
	for (j = 0; j < 256; j += 2)
	{
	    encipher(&datal, &datar);
	    m_SBoxes[i][j] = datal;
	    m_SBoxes[i][j + 1] = datar;
	}
    }
}


// Get output length, which must be even MOD 8.
unsigned long
Blowfish::getOutputLength(unsigned long lInputLong)
{
    unsigned long lVal;

    // Find out if uneven number of bytes at the end.
    lVal = lInputLong % 8;
    if (lVal != 0)
	return lInputLong + 8 - lVal;
    else
	return lInputLong;
}


// Encode pIntput into pOutput.  Input length in lSize.  Returned
// value is length of output which will be even MOD 8 bytes.  Input
// buffer and output buffer can be the same, but be sure buffer length
// is even MOD 8.
unsigned long
Blowfish::encode(
    unsigned char * pInput,
    unsigned char * pOutput,
    unsigned long lSize)
{
    unsigned long lCount;
    unsigned long lOutSize;
    unsigned long lGoodBytes;
    unsigned char* pi;
    unsigned char* po;
    int i;
    int j;

    int SameDest = (pInput == pOutput ? 1 : 0);

    lOutSize = getOutputLength(lSize);
    for (lCount = 0; lCount < lOutSize; lCount += 8)
    {
	if (SameDest)
	{
	    // Encoded data is being written into input buffer.
	    if (lCount < lSize - 7)
	    {
		// Not dealing with uneven bytes at end.
		encipher(reinterpret_cast<unsigned long*>(pInput),
			 reinterpret_cast<unsigned long*>(pInput + 4));
	    }
	    else
	    {
		// Pad end of data with null bytes to complete encryption.
		// Point at byte past the end of actual data.
		po = pInput + lSize;

		// Number of bytes to set to null.
		j = static_cast<int>((lOutSize - lSize));
		for (i = 0; i < j;  i++)
		    *po++ = 0;
		encipher(reinterpret_cast<unsigned long*>(pInput),
			 reinterpret_cast<unsigned long*>(pInput + 4));
	    }
	    pInput += 8;
	}
	else
	{
	    // Output buffer not equal to input buffer, so must copy
	    // input to output buffer prior to encrypting.
	    if (lCount < lSize - 7)
	    {
		// Not dealing with uneven bytes at end.
		pi = pInput;
		po = pOutput;

		// Copy bytes to output.
		for (i = 0; i < 8; i++)
		    *po++ = *pi++;
		// Now encrypt them.
		encipher(reinterpret_cast<unsigned long*>(pOutput),
			 reinterpret_cast<unsigned long*>(pOutput + 4));
	    }
	    else
	    {
		// Pad end of data with null bytes to complete encryption.
		lGoodBytes = lSize - lCount; // number of remaining data bytes
		po = pOutput;
		for (i = 0; i < static_cast<int>(lGoodBytes); i++)
		    *po++ = *pInput++;
		for (j = i; j < 8; j++)
		    *po++ = 0;
		encipher(reinterpret_cast<unsigned long*>(pOutput),
			 reinterpret_cast<unsigned long*>(pOutput + 4));
	    }
	    pInput += 8;
	    pOutput += 8;
	}
    }
    return lOutSize;
}


// Decode pInput into pOutput.  Input length in lSize.  Input buffer and
// output buffer can be the same, but be sure buffer length is even MOD 8.
void
Blowfish::decode(
    unsigned char * pInput,
    unsigned char * pOutput,
    unsigned long lSize)
{
    unsigned long lCount;
    unsigned char *pi;
    unsigned char *po;
    int i;
    int SameDest = (pInput == pOutput ? 1 : 0);

    for (lCount = 0; lCount < lSize; lCount += 8)
    {
	if (SameDest)
	{
	    // Encoded data is being written into input buffer.
	    decipher(reinterpret_cast<unsigned long*>(pInput),
		     reinterpret_cast<unsigned long*>(pInput + 4));
	    pInput += 8;
	}
	else 
	{
	    // Output buffer not equal to input buffer so copy input
            // to output before decoding.
	    pi = pInput;
	    po = pOutput;
	    for (i = 0; i < 8; i++)
		*po++ = *pi++;
	    decipher(reinterpret_cast<unsigned long*>(pOutput),
		     reinterpret_cast<unsigned long*>(pOutput + 4));
	    pInput += 8;
	    pOutput += 8;
	}
    }
}
=====================================================================
Found a 255 line (1194 tokens) duplication in the following files: 
Starting at line 23 of D:\home\eCora_PM\PM\hostManager\HostManagerUnitTest.h
Starting at line 23 of D:\home\eCora_PM\PM\idb\IdbUnitTest.h

    IdbUnitTest()
    {
        m_trigger = 1;
    }

    // add a group and two windows systems
    void testAddObjects()
    {
        CComQIPtr<com::IAppDatabase> pDatabase(m_pServices);
        if (!pDatabase)
        {
            TS_FAIL("Unable to get the database pointer");
        }

        CComPtr<com::IDbContainer> pDbContainer;
        HRESULT hr = pDatabase->getDbContainer(&pDbContainer);

        if (FAILED(hr))
        {
            TS_FAIL("Unable to get the database container");
        }

        hr = pDbContainer->registerObjectType(&idb::GroupObject());
        if (FAILED(hr))
        {
            TS_FAIL("Unable to register container for groups");
        }

        idb::GroupObject newGroup(QString("TestGroup"));

        hr = pDbContainer->addObject(&newGroup);
        if (FAILED(hr))
        {
            TS_FAIL("Unable to add group");
        }

        hr = pDbContainer->registerObjectType(&idb::WindowsDevice());
        if (FAILED(hr))
        {
            TS_FAIL("Unable to register container for devices");
        }

        idb::WindowsDevice deviceOne(m_pServices);
        deviceOne.setFieldValue(idb::WindowsDevice::DeviceName, QString("DeviceOne"));
        deviceOne.setFieldValue(idb::WindowsDevice::DomainName, QString("DomainOne"));
        deviceOne.setFieldValue(idb::WindowsDevice::IpAddress, QString("IpOne"));
        deviceOne.setFieldValue(idb::WindowsDevice::UserName, QString("UserNameOne"));

        hr = pDbContainer->addObject(&deviceOne);
        if (FAILED(hr))
        {
            TS_FAIL("Unable to add system object");
        }

        deviceOne.setFieldValue(idb::WindowsDevice::DeviceName, QString("DeviceTwo"));
        deviceOne.setFieldValue(idb::WindowsDevice::DomainName, QString("DomainTwo"));
        deviceOne.setFieldValue(idb::WindowsDevice::IpAddress, QString("IpTwo"));
        deviceOne.setFieldValue(idb::WindowsDevice::UserName, QString("UserNameTwo"));

        hr = pDbContainer->addObject(&deviceOne);
        if (FAILED(hr))
        {
            TS_FAIL("Unable to add system object");
        }
    }

    // update a system
    void testSetRelation()
    {
        CComQIPtr<com::IAppDatabase> pDatabase(m_pServices);
        if (!pDatabase)
        {
            TS_FAIL("Unable to get the database pointer");
        }

        CComPtr<com::IDbRelation> pDbRelation;
        HRESULT hr = pDatabase->getDbRelation(&pDbRelation);

        if (FAILED(hr))
        {
            TS_FAIL("Unable to get the database relation");
        }

        idb::GroupObject group(QString("TestGroup"));
        idb::WindowsDevice deviceOne(QString("DeviceOne"), QString("DomainOne"), m_pServices);
        idb::WindowsDevice deviceTwo(QString("DeviceTwo"), QString("DomainTwo"), m_pServices);

        hr = pDbRelation->setRelation(&group, &deviceOne);
        if (FAILED(hr))
        {
            TS_FAIL("Unable to set relation");
        }

        hr = pDbRelation->setRelation(&group, &deviceTwo);
        if (FAILED(hr))
        {
            TS_FAIL("Unable to set relation");
        }

        QPtrVector<IUnknown> result;
        hr = pDbRelation->getRelatedObjects(&group, result);
        if (FAILED(hr))
        {
            TS_FAIL("Unable to retrieve related objects");
        }

        if (2 != result.count())
        {
            TS_FAIL("The relations are not set properly");
        }
    }

    // update a system
    void testUpdateSystem()
    {
        CComQIPtr<com::IAppDatabase> pDatabase(m_pServices);
        if (!pDatabase)
        {
            TS_FAIL("Unable to get the database pointer");
        }

        CComPtr<com::IDbContainer> pDbContainer;
        HRESULT hr = pDatabase->getDbContainer(&pDbContainer);

        if (FAILED(hr))
        {
            TS_FAIL("Unable to get the database pointer");
        }

        hr = pDbContainer->registerObjectType(&idb::WindowsDevice());
        if (FAILED(hr))
        {
            TS_FAIL("Unable to register container for systems");
        }

        idb::WindowsDevice device(m_pServices);
        device.setFieldValue(idb::WindowsDevice::DeviceName, QString("DeviceOne"));
        device.setFieldValue(idb::WindowsDevice::DomainName, QString("DomainOne"));

        hr = pDbContainer->retrieveObject(&device);
        if (FAILED(hr))
        {
            TS_FAIL("Unable to retrieve device");
        }

        device.setFieldValue(idb::WindowsDevice::IpAddress, QString("IpTest"));
        device.setFieldValue(idb::WindowsDevice::UserName, QString("UserTest"));

        hr = pDbContainer->updateObject(&device);
        if (FAILED(hr))
        {
            TS_FAIL("Unable to update device");
        }

        idb::WindowsDevice deviceTest(QString("DeviceOne"), QString("DomainOne"), m_pServices);

        hr = pDbContainer->retrieveObject(&deviceTest);
        if (FAILED(hr))
        {
            TS_FAIL("Unable to retrieve test device");
        }

        QString qsIp;
        deviceTest.getFieldValue(idb::WindowsDevice::IpAddress, qsIp);
        if (qsIp != "IpTest")
        {
            TS_FAIL("The test IP does not match");
        }

        QString qsUserName;
        deviceTest.getFieldValue(idb::WindowsDevice::UserName, qsUserName);
        if (qsUserName != "UserTest")
        {
            TS_FAIL("The test user does not match");
        }
    }

    // delete the group
    void testDeleteObjects()
    {
        CComQIPtr<com::IAppDatabase> pDatabase(m_pServices);
        if (!pDatabase)
        {
            TS_FAIL("Unable to get the database pointer");
        }

        CComPtr<com::IDbContainer> pDbContainer;
        HRESULT hr = pDatabase->getDbContainer(&pDbContainer);

        if (FAILED(hr))
        {
            TS_FAIL("Unable to get the database container");
        }

        hr = pDbContainer->registerObjectType(&idb::WindowsDevice());
        if (FAILED(hr))
        {
            TS_FAIL("Unable to register container for devices");
        }

        idb::WindowsDevice deviceOne(QString("DeviceOne"), QString("DomainOne"), m_pServices);
        idb::WindowsDevice deviceTwo(QString("DeviceTwo"), QString("DomainTwo"), m_pServices);

        hr = pDbContainer->deleteObject(&deviceOne);
        if (FAILED(hr))
        {
            TS_FAIL("Unable to delete device one");
        }

        hr = pDbContainer->deleteObject(&deviceTwo);
        if (FAILED(hr))
        {
            TS_FAIL("Unable to delete device two");
        }

        CComPtr<com::IDbRelation> pDbRelation;
        hr = pDatabase->getDbRelation(&pDbRelation);

        if (FAILED(hr))
        {
            TS_FAIL("Unable to get the database relation");
        }

        idb::GroupObject newGroup(QString("TestGroup"));

        QPtrVector<IUnknown> result;
        hr = pDbRelation->getRelatedObjects(&newGroup, result);
        if (FAILED(hr))
        {
            TS_FAIL("Unable to retrieve related objects");
        }

        if (0 != result.count())
        {
            TS_FAIL("The system relations were not deleted");
        }

        hr = pDbContainer->registerObjectType(&idb::GroupObject());
        if (FAILED(hr))
        {
            TS_FAIL("Unable to register container for groups");
        }

        hr = pDbContainer->deleteObject(&newGroup);
        if (FAILED(hr))
        {
            TS_FAIL("Unable to delete group");
        }
    }

  private:
    static int m_trigger;
};

static IdbUnitTest IdbUnitTestTrigger;
=====================================================================
Found a 232 line (1104 tokens) duplication in the following files: 
Starting at line 283 of D:\home\eCora_PM\PM\agent\agent\apps\Setup\Win32\Msi\CustomActions\CustomActionsDLL\CustomActions.cpp
Starting at line 256 of D:\home\eCora_PM\PM\agent\agent\apps\Setup\Win32\Msi\CustomActions\UpgradeCheck\UpgradeCheck.cpp

        szServiceName = L"\"AgentSvc\"";
    #endif
#endif

    if (startAgentService)
    {
        szCmd += L"/q /C \"net start ";
    }
    else
    {
        szCmd += L"/q /C \"net stop ";
    }
    szCmd = szCmd + szServiceName + L"\"";

    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    memset(&si, 0, sizeof(si));
    si.cb = sizeof(STARTUPINFO);
    si.lpDesktop = 0;
    si.dwFlags = 1; //STARTF_USESHOWWINDOW
    si.wShowWindow = SW_HIDE;
    

    BOOL retval = CreateProcess(0L,
        (wchar_t*)szCmd.GetString(), 0L, 0L, true,
        NORMAL_PRIORITY_CLASS, 0L, (wchar_t*)strPath.GetString(), &si, &pi);
    if (retval)
    {
        WaitForSingleObject(pi.hProcess, INFINITE);  // block until child done
    }
    else
    {
        return ReportInstallError(hInstall, L"Cannot stop the Agent Service!");
    }

    return ERROR_SUCCESS;
}


extern "C" __declspec(dllexport) UINT __stdcall StartAgentService(MSIHANDLE hInstall)
{
    return HandleAgentService(hInstall, true);
}
extern "C" __declspec(dllexport) UINT __stdcall StopAgentService(MSIHANDLE hInstall)
{
    return HandleAgentService(hInstall, false);
}


extern "C" __declspec(dllexport) UINT __stdcall UpdateConfigurationFiles(MSIHANDLE hInstall)
{
    UINT res;
    HRESULT hres;
    CAtlFile file;
    DWORD dwBuff = 1024;
    TCHAR szBuff[1024];
    CString strProductVersion;
    CString strInstallPath;
    DWORD dw = 0;
    
    USES_CONVERSION;

    res = MsiGetProperty(hInstall, L"ECORA_CLIENT_INSTALLATION_PATH", szBuff, &dwBuff);
    if (res != ERROR_SUCCESS)
    {
        return ReportInstallError(hInstall, L"ECORA_CLIENT_INSTALLATION_PATH parameter was not found");
    }

    strInstallPath = szBuff;

    ::ZeroMemory(szBuff, 1024);

    res = MsiGetProperty(hInstall, L"ProductVersion", szBuff, &dwBuff);
    if (res != ERROR_SUCCESS)
    {
        return ReportInstallError(hInstall, L"ProductVersion parameter was not found");
    }
    strProductVersion = szBuff;

    CString strFiles[3] = { strInstallPath + L"\\etc\\CoreConfig.conf", 
        strInstallPath + L"\\etc\\ConnectorConfig.conf", strInstallPath  + L"\\etc\\InstallConfig.conf" };
    

    for (int i = 0; i < 3; i++)
    {
        //save configuration files before modification
        ::CopyFile(strFiles[i], strFiles[i] + L".bak", false);
        hres = file.Create(strFiles[i], GENERIC_READ | GENERIC_WRITE, 
            FILE_SHARE_READ | FILE_SHARE_WRITE, OPEN_EXISTING);
        if (FAILED(hres))
        {
            return ReportInstallError(hInstall, CString(L"Could not open file ") + strFiles[i]);
        }

        ULONGLONG nLength;
        file.GetSize(nLength);
        CAutoVectorPtr<BYTE> pBuff(new BYTE[(size_t)(nLength + 11)]);
        ::ZeroMemory(pBuff, (nLength + 11));
        file.Read(pBuff, (DWORD)nLength);
        CString strConfig = (char*)(LPBYTE)pBuff;

        SetAttributeValue(strConfig, L"SystemVersion", strProductVersion);
        file.Seek(0, FILE_BEGIN);
        LPCSTR lpsz = W2A(strConfig);
        file.Write(lpsz, (DWORD)strlen(lpsz), &dw);
        file.Flush();
        ::SetEndOfFile(file.m_h);
        file.Close();
        pBuff.Free();
    }

    return ERROR_SUCCESS;
}

extern "C" __declspec(dllexport) UINT __stdcall RollbackUpdateConfigurationFiles(MSIHANDLE hInstall)
{
    UINT res;
    DWORD dwBuff = 1024;
    TCHAR szBuff[1024];
    CString strInstallPath;

    res = MsiGetProperty(hInstall, L"CustomActionData", szBuff, &dwBuff);
    if (res != ERROR_SUCCESS)
    {
        return ReportInstallError(hInstall, L"CustomActionData parameter was not found");
    }
    strInstallPath = szBuff;

    CString strFiles[3] = { strInstallPath + L"\\etc\\CoreConfig.conf", 
        strInstallPath + L"\\etc\\ConnectorConfig.conf", strInstallPath  + L"\\etc\\InstallConfig.conf" };
    for (int i = 0; i < 3; i++)
    {
        ::MoveFileEx(strFiles[i] + L".bak", strFiles[i], MOVEFILE_REPLACE_EXISTING);
    }
    return ERROR_SUCCESS;
}

extern "C" __declspec(dllexport) UINT __stdcall CommitUpdateConfigurationFiles(MSIHANDLE hInstall)
{
    UINT res;
    DWORD dwBuff = 1024;
    TCHAR szBuff[1024];
    CString strInstallPath;

    res = MsiGetProperty(hInstall, L"CustomActionData", szBuff, &dwBuff);
    if (res != ERROR_SUCCESS)
    {
        return ReportInstallError(hInstall, L"CustomActionData parameter was not found");
    }
    strInstallPath = szBuff;

    CString strOldFiles[3] = { strInstallPath + L"\\etc\\CoreConfig.conf.bak", 
        strInstallPath + L"\\etc\\ConnectorConfig.conf.bak", strInstallPath  + L"\\etc\\InstallConfig.conf.bak" };

    for (int i = 0; i < 3; i++)
    {
        ::DeleteFile(strOldFiles[i]);
    }

    return ERROR_SUCCESS;
}

extern "C" __declspec(dllexport) UINT __stdcall CheckProductVersion(MSIHANDLE hInstall)
{
    UINT res;
    DWORD dwBuff = 1024;
    TCHAR szBuff[1024];
    CString strProductVersion;
    CString strInstallPath;
    
    ::ZeroMemory(szBuff, 1024 * sizeof(wchar_t));
    res = MsiGetProperty(hInstall, L"ECORA_CLIENT_INSTALLATION_PATH", szBuff, &dwBuff);
    if (res != ERROR_SUCCESS)
    {
        return ReportInstallError(hInstall, L"ECORA_CLIENT_INSTALLATION_PATH parameter was not found");
    }
    strInstallPath = szBuff;

    ::ZeroMemory(szBuff, 1024 * sizeof(wchar_t));

    res = MsiGetProperty(hInstall, L"ProductVersion", szBuff, &dwBuff);
    if (res != ERROR_SUCCESS)
    {
        return ReportInstallError(hInstall, L"ProductVersion parameter was not found");
    }
    strProductVersion = szBuff;
    

    CString strFileName = strInstallPath + L"\\etc\\CoreConfig.conf";
    FILE* fd = _wfopen(strFileName.GetString(), L"rb");
    if (fd == 0)
    {
        return ReportInstallError(hInstall, CString(L"Could not open file ") + strFileName);
    }

    CString strConfig = readFromFile(fd);
    fclose(fd);

    CString strSystemVersion = GetAttributeValue(strConfig, L"SystemVersion");

    bool upgrade = false;
    
    int result = compare2Versions(strProductVersion, strSystemVersion);
    if (result > 0)
    {
        upgrade = true;
    }
    if (result == -2)
    {
        return ReportInstallError(hInstall, CString(L"Invalid upgrade product Version: ") + strProductVersion);
    }
    if (result == -3)
    {
        return ReportInstallError(hInstall, CString(L"Invalid installed product Version: ") + strSystemVersion);
    }

    if (upgrade)
    {
        MsiSetProperty(hInstall, L"ECORA_UPGRADE_CLIENT", L"TRUE");
    }
    else
    {
        MsiSetProperty(hInstall, L"ECORA_UPGRADE_CLIENT", L"FALSE");
    }

    if (!upgrade)
    {
        return ReportInstallError(hInstall, L"A product with a newer version is already installed!");
    }
    return ERROR_SUCCESS;
}
=====================================================================
Found a 252 line (1071 tokens) duplication in the following files: 
Starting at line 37 of D:\home\eCora_PM\PM\network\SftpConnection.cpp
Starting at line 37 of D:\home\eCora_PM\PM\network\network\SftpConnection.cpp

namespace network {

SftpConnection::SftpConnection()
{
}

SftpConnection::~SftpConnection()
{
    //  There are at least two shells created when the connection
    //  is made.   Kill them all now.
    try {
        send("quit\n");
    }

    catch (...)
    {
        log(L"TelnetConnection::~TelnetConnection()", Log::Debug,
            L"Error condition detected while killing shells.");
    }

    deleteHost();
}        

void
SftpConnection::connect(const LoginParameters*const device)
{
    log(L"SftpConnection::connect", Log::Info, device->hostname());
    m_prompt = "ecora-psftp>";
    
    m_hostName = device->hostname();
    m_userName = device->username();
    
    wstring connectionMethod = device->clientDir() + L"/psftp.exe";

    vector<wstring> baseArguments;


    baseArguments.push_back(device->hostname());

    //  Save the string that gets sent for future reference.    
    m_connectionString = L"Connecting using: " + connectionMethod + 
                         L" " + device->hostname();

    wstring::size_type end = 0;
    wstring::size_type start = 0;
    if (!device->arguments().empty())
    {
        while (end != wstring::npos)
        {
            end = device->arguments().find(L" ");
            wstring::size_type n = wstring::npos;
            if (end != wstring::npos)
                n = end - start;

            wstring token = device->arguments().substr(start, n);
            if (end != wstring::npos)
                start = end + 1;

            if (!token.empty())
            {
	        m_connectionString += L" ";
	        m_connectionString += token;

	        baseArguments.push_back(token); 
            }
        }
    }

    //  FIXME:  We need a default for when the user does not want
    //    to enter a port.
    if (device->port() != 0)
    {
        baseArguments.push_back(L"-P");
        baseArguments.push_back(int2wstring(device->port()));
    }

    if (getenv("ECORA_SMUGGLE_DUMP") != NULL)
    {
        //  Connect using verbose mode.
        baseArguments.push_back(L"-v");
    }
	    
    log(L"SftpConnection::connect", Log::Debug, m_connectionString);
    
    m_host = new Smuggler(m_driver, connectionMethod, baseArguments);
    m_host->setTimeout(TWENTY_SECOND_TIMEOUT);

    m_connected = true;

    if (!device->username().empty())
    {
        login(ws2ansi(device->username()), ws2ansi(device->password()));
    }

    delayAndWaitForPrompt(device->loginDelay(), ws2ansi(device->loginPrompt()),
        TWENTY_SECOND_TIMEOUT);

    //  Try and sync up with the application. 
    send("\n");
    getData(TWENTY_SECOND_TIMEOUT);
}

void
SftpConnection::quit()
{
    log(L"SftpConnection::quit", Log::Info, L"quit");
    checkConnection(L"quit");
    send("quit\n");
    deleteHost();
    m_connected = false;
}
       
void
SftpConnection::put(const wstring& localFilename,
		   const wstring& remotePath)
{
    wstring logMessage = localFilename + L" " + m_userName + 
        L"@" + m_hostName + L":" + remotePath;    
    log(L"SftpConnection::put", Log::Info, logMessage);

    wstring remoteFilename = remotePath + L"/" + returnFilename(localFilename);

    wstring executeThis = L"put \"" + localFilename + L"\" \"" + 
        remoteFilename + L"\"";
    executeCommand(executeThis, TWO_MINUTE_TIMEOUT);
}

void
SftpConnection::get(const wstring& remoteFilename,
		   const wstring& localPath)
{
    wstring logMessage = localPath + L" " + m_userName + L"@" + m_hostName +
	L":" + remoteFilename;    
    log(L"SftpConnection::get", Log::Info, logMessage);

    wstring localFilename = localPath + L"/" + returnFilename(remoteFilename);

    wstring executeThis = L"get \"" + remoteFilename + 
        L"\" \"" + localFilename + L"\"";
    executeCommand(executeThis, TWO_MINUTE_TIMEOUT);
}

wstring
SftpConnection::executeCommand(wstring command, int timeout)
{
    wstring logMessage = command + L"  Timeout: " + int2wstring(timeout);
    log(L"SftpConnection::executeCommand", Log::Debug, logMessage);

    checkConnection(command);
    send(ws2ansi(command) + "\n");

    vector<bstring> errorPrompts;
    errorPrompts.push_back("Fatal:");
    errorPrompts.push_back("Command failed:");

    vector<bstring> successPrompts;
    successPrompts.push_back("Success:");

    bstring response = waitForTransfer(successPrompts, errorPrompts);
    if (response.find("Command failed:") != bstring::npos)
    {
        wstring errorMessage = L"File transfer timeout:  Command: " + command +
            L" Host response: " + bstring2wstring(response);

        throw GenericException(__FILE__, __LINE__, L"SftpConnection::executeCommand", 
                                L"", errorMessage);
    }

    return bstring2wstring(response);
}

void
SftpConnection::checkConnection(wstring calledBy)
{
    wstring logMessage = L" for " + calledBy;
    log(L"SftpConnection::checkConnection", Log::Info, logMessage);

    if (!m_connected)
    {
	wstring errorMessage = L"Cannot execute " + calledBy +
	    L".  Not connected to a remote host.";
	
	throw NoConnectionError(__FILE__, __LINE__,
				L"SftpConnection::checkConnection",
	    m_connectionString,
	    errorMessage);
    }
    else
    {
	wstring logMessage = userName() + L"@" + hostName() +
	    L" ... Execute: " + calledBy;
	log(L"SftpConnection::checkConnection", Log::Debug, logMessage);
    }
}

bstring
SftpConnection::getData(int timeout)
{
    wstring logMessage = L" timeout: " + int2wstring(timeout);
    log(L"SftpConnection::getData", Log::Info, logMessage);

    vector<pair<bstring, int> > possible;

    // Potential prompts...
    possible.push_back(pair<bstring, int>(m_prompt, 0));

    m_host->setTimeout(timeout);

    bstring returnMessage = "";

    try {

        int code = m_host->match(possible);
        if (code == 0)
        {
            returnMessage = m_host->data();
        }
        else
        {
            bstring returnMessage = "Command failed: No prompt identified. ";
            returnMessage += " Host match returned: " + m_host->data();
	    log(L"SftpConnection::getData()", Log::Debug, 
                bstring2wstring(returnMessage));
        }
    }
    catch (Timeout&)
    {
        //   Not sure what is happening.   Looks like smuggle may not
        //   be getting the entire message.  
        bstring returnMessage =
	    "Command failed: No prompt identified. Host data available: ";
	
        returnMessage += m_host->data();
	log(L"SftpConnection::getData()", Log::Debug, 
            bstring2wstring(returnMessage));
    }

    return returnMessage; 
}

SftpConnection* 
establishSftpConnection(const LoginParameters*const device)
{
    wstring logMessage = device->username() + L"@" + device->hostname();
    log(L"establishSftpConnection", Log::Info, logMessage);
	
    SftpConnection* fC = new SftpConnection();
    fC->connect(device);
    return fC;
}

} // End namespace connections
=====================================================================
Found a 214 line (1028 tokens) duplication in the following files: 
Starting at line 14 of D:\home\eCora_PM\PM\network\CurlHttpTestInterpreter.cpp
Starting at line 14 of D:\home\eCora_PM\PM\network\network\CurlHttpTestInterpreter.cpp

namespace network {

CurlHttpTestInterpreter::~CurlHttpTestInterpreter()
{

    for (size_t i = 0; i < m_httpTestDescriptors.size(); ++i)
        delete m_httpTestDescriptors[i];
}

void
CurlHttpTestInterpreter::run()
{
    try 
    {
        //  FIXME:  We should find a better place for this file and where
        //          a better technique for finding it.
        m_testDocument = new xml::Document(L"./curlTestDriver.xml");

        if (m_testDocument == 0)
        {
            //  Create a testDiscriptor (0) that indicates the problem:
            //  Test number = 0;
            //  Description "Open ./curlTestDriver.xml"
            //  PassFail = fail;
            //  ErrorMessage it didn't want to open."
            //  Save it and return.
            CurlTestDescriptor* thisTest = 
                new CurlTestDescriptor(0, L"Open ./curlTestDriver.xml");

            thisTest->setPassFail(false);
            thisTest->setErrorMessage(L"Failed to open ./curlTestDriver.xml");
            m_httpTestDescriptors.push_back(thisTest);
            return;
        }

        m_testNode = m_testDocument->node(L"CurlTest");

        //  Find all HttpTest nodes.
        xml::Node::iterator it;
        for (it = m_testNode->begin(); it != m_testNode->end(); ++it)
        {
            xml::Node* test = dynamic_cast<xml::Node*>(*it);
            if (test->name() == L"HttpTest")
                runTest(test);
        }
    }
    catch (xml::Error& e)
    {
        CurlTestDescriptor* thisTest = 
                new CurlTestDescriptor(0, L"Open ./curlTestDriver.xml");

        thisTest->setPassFail(false);
        thisTest->setErrorMessage(e.message());
        m_httpTestDescriptors.push_back(thisTest);
        return;
    }
    catch (GenericException& e)
    {
        CurlTestDescriptor* thisTest = 
                new CurlTestDescriptor(0, L"Open ./curlTestDriver.xml");

        thisTest->setPassFail(false);
        thisTest->setErrorMessage(e.message());
        m_httpTestDescriptors.push_back(thisTest);
        return;
    }
}

void
CurlHttpTestInterpreter::runTest(xml::Node* test)
{



    //  Create a test object and save the pointer to it.
    CurlTestDescriptor* thisTest = 
            new CurlTestDescriptor(
            wstring2int(test->findAttribute(L"testNumber")->value()),
            test->findAttribute(L"testDescription")->value());

    m_httpTestDescriptors.push_back(thisTest);

    bool bUseNTLM = false;
    int iConnectionTimeout = 0;
    int iOperationTimeout = 0;

    if (test->findAttribute(L"url"))
        thisTest->setUrl(test->findAttribute(L"url")->value());
    if (test->findAttribute(L"username"))
        thisTest->setUsername(test->findAttribute(L"username")->value());
    if (test->findAttribute(L"password"))
        thisTest->setPassword(test->findAttribute(L"password")->value());
    if (test->findAttribute(L"cookies"))
        thisTest->setCookies(test->findAttribute(L"cookies")->value());
    if (test->findAttribute(L"userAgentLocation"))
        thisTest->setUserAgentLocation(
            test->findAttribute(L"userAgentLocation")->value());
    if (test->findAttribute(L"proxyAddress"))
        thisTest->setProxyAddress(test->findAttribute(
                L"proxyAddress")->value());
    if (test->findAttribute(L"proxyAuthentication"))
    {
        thisTest->setProxyAuthentication(
            test->findAttribute(L"proxyAuthentication")->value());
        if (thisTest->getProxyAuthentication() == L"NTLM")
        {
            bUseNTLM = true;
        }
        else if ((thisTest->getProxyAuthentication() != L"Basic") && 
                 (thisTest->getProxyAuthentication() != L"None"))
        {
            //  We don't support this type of authentication.  Set an error
            //  message indicating that the problem.
            thisTest->setPassFail(false);
            wstring errorMessage = L"Proxy authentication specified (" +
                thisTest->getProxyAuthentication() + 
                L") is not supported.  Please specify NTLM, Basic or None.";
            thisTest->setErrorMessage(errorMessage);
            return;
        }
    }

    if (test->findAttribute(L"connectionTimeout"))
        thisTest->setConnectionTimeout(
            test->findAttribute(L"connectionTimeout")->value());
    if (!thisTest->getConnectionTimeout().empty())
        iConnectionTimeout = wstring2int(thisTest->getConnectionTimeout());
  
    if (test->findAttribute(L"operationTimeout"))
        thisTest->setOperationTimeout(
            test->findAttribute(L"operationTimeout")->value());
    if (!thisTest->getOperationTimeout().empty())
        iOperationTimeout = wstring2int(thisTest->getOperationTimeout());

    if (test->findAttribute(L"proxyUser"))
        thisTest->setProxyUsername(
            test->findAttribute(L"proxyUsername")->value());
    if (test->findAttribute(L"proxyPassword"))
        thisTest->setProxyPassword(
            test->findAttribute(L"proxyPassword")->value());
    if (test->findAttribute(L"compareAgainst"))
        thisTest->setCompareAgainst(
            test->findAttribute(L"compareAgainst")->value());

    //  Create a CurlImpl object and try to read the url that is specified
    //  using the parameters that are passed.

    wstring content;
    Http* httpObject = 0;
    try 
    {
        //  For now, don't worry about cookies, or the agent.
        Http* httpObject = new Http(L"cookies.txt", 
                                    thisTest->getUserAgentLocation());
        if (!thisTest->getUsername().empty() ||
            !thisTest->getPassword().empty())
        {
            httpObject->setCredentials(thisTest->getUsername(),
                                       thisTest->getPassword());
        }

        if (!thisTest->getProxyAddress().empty())
        {
            // Set up to use a proxy...
            httpObject->useProxy(thisTest->getProxyAddress(), 
                thisTest->getProxyUsername(), 
                thisTest->getProxyPassword(), bUseNTLM);
        }
         
        if (iConnectionTimeout)
            httpObject->setConnectionTimeout(iConnectionTimeout);

        if (iOperationTimeout)
            httpObject->setOperationTimeout(iOperationTimeout);

        if (!thisTest->getUrl().empty())
        {
            // Get a page
            com::NetworkResult* result;
            httpObject->url2wstring(thisTest->getUrl(), &content, true, 
                                                                 &result);
            httpObject->freeResult(result);
        }

        if (!thisTest->getCompareAgainst().empty())
        {
            compareResultsToFile(content, thisTest->getCompareAgainst());
        }
    }
    catch (GenericException& e)
    {
        thisTest->setPassFail(false);
        thisTest->setErrorMessage(e.message());
        if (httpObject)
            delete httpObject;
        return;
    }

    if (httpObject)
        delete httpObject;
    thisTest->setPassFail(true);
}

void
CurlHttpTestInterpreter::compareResultsToFile(const wstring& results, 
                                              const wstring& file)
{
    //  Do a line by line comparison of the returned string and the content of
    //  the file.

}


} // End namespace network
=====================================================================
Found a 203 line (971 tokens) duplication in the following files: 
Starting at line 2122 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 762 of D:\home\eCora_PM\PM\patchRepository\WinSolRepoSettings.cpp

    m_winWidget->m_downloadDir->setText(path);
}

bool WinSolRepoSettings::checkValidity()
{
    if (m_winWidget->m_enableWindows->isChecked())
    {
        wstring s = qs2ws(m_winWidget->m_windowsRepository->text());

        if (s.size() < 1)
        {
            QMessageBox::warning(m_parent, tr("Warning"),
                tr("Path for Windows repository must be entered."), QObject::tr("&OK"));
            return false;
        }
        // must be UNC path
        if (s.substr(0, 2) != L"\\\\")
        {
            QMessageBox::warning(m_parent, tr("Warning"),
                tr("Path for Windows repository must be a UNC path."), QObject::tr("&OK"));
            return false;
        }

        // bug 6570 - credentials required for service now, so optional here?
        if (qs2ws(m_winWidget->m_windowsLogin->text()).size() < 1)
        {
            QMessageBox::warning(m_parent, tr("Warning"),
                tr("Windows credentials must be entered."), QObject::tr("&OK"));
            return false;
        }

            /*
        if (qs2ws(m_winWidget->m_windowsPassword->text()).size() > 0)
        {
            if (m_winWidget->m_windowsPassword->text() != m_winWidget->m_windowsConfirmPass->text())
            {
            wstring message;
            message = L"Windows passwords do not match.";
            QMessageBox::warning(m_parent, tr("Warning"),
                ws2qs(message), "&OK");
            return false;
            }
        }
            */
    }

    if (m_solWidget->m_enableUnix->isChecked())
    {
        wstring s = qs2ws(m_solWidget->m_unixRepository->text());

        if (s[0] != L'/')
        {
            bool allSpaces = true;
            wstring::size_type x = s.find(L'/');
            if (x != wstring::npos)
            {
                for (int i = 0; i < x; ++i)
                {
                    if (s[i] != L' ')
                    {
                        allSpaces = false;
                        break;
                    }
                }
            }

            if ((x == wstring::npos) || !allSpaces)
            {
                QMessageBox::warning(m_parent, tr("Warning"),
                    tr("Repository path must be complete and start from the root directory (/)."),
                    QObject::tr("&OK"));
                return false;
            }

            //   Shift the text over.  ncftp cannot seem to handle leading spaces
            //   in the pathname.
            if (allSpaces)
            {
                s = s.substr(x);
                m_solWidget->m_unixRepository->setText(ws2qs(s));
            }
        }

    if (s.size() < 1)
    {
        QMessageBox::warning(m_parent, tr("Warning"),
            tr("Path for unix repository must be entered."), QObject::tr("&OK"));
        return false;
    }
    if (s.size() > 60)
    {
        QMessageBox::warning(m_parent, tr("Warning"),
            tr("Ecora can only support a repository path name no greater than 60 characters in length."), QObject::tr("&OK"));
        return false;
    }
    s = qs2ws(m_solWidget->m_unixHostname->text());
    wstring s2 = qs2ws(m_solWidget->m_unixIPAddress->text());
    if (s.size() < 1 && s2.size() < 1)
    {
        QMessageBox::warning(m_parent, tr("Warning"),
            tr("Hostname or ip address for unix repository must be entered."), QObject::tr("&OK"));
        return false;
    }

    //Kulakov: BUGFIX 7407
#if 0
    if (qs2ws(m_solWidget->m_unixTPassword->text()).size() > 0)
    {
        if (m_solWidget->m_unixTPassword->text() != m_solWidget->m_unixTConfirmPass->text())
        {
            QMessageBox::warning(m_parent, tr("Warning"),
                tr("Terminal passwords do not match."), QObject::tr("&OK"));
            return false;
        }
    }
    if (qs2ws(m_solWidget->m_unixTRootPass->text()).size() > 0)
    {
        if (m_solWidget->m_unixTRootPass->text() != m_solWidget->m_unixTConfirmRootPass->text())
        {
            QMessageBox::warning(m_parent, tr("Warning"),
                tr("Terminal root passwords do not match."), QObject::tr("&OK"));
            return false;
        }
    }
    if (qs2ws(m_solWidget->m_unixFTPassword->text()).size() > 0)
    {
        if (m_solWidget->m_unixFTPassword->text() != m_solWidget->m_unixFTConfirmPass->text())
        {
            QMessageBox::warning(m_parent, tr("Warning"),
                tr("File transfer passwords do not match."), QObject::tr("&OK"));
            return false;
        }
    }
#endif
    //Kulakov: END OF 7407

    if (qs2ws(m_solWidget->m_unixTUsername->text()).size() < 1)
    {
        QMessageBox::warning(m_parent, tr("Warning"),
            tr("User for terminal connection must be entered."), QObject::tr("&OK"));
        return false;
    }
    if (qs2ws(m_solWidget->m_unixFTUsername->text()).size() < 1)
    {
        QMessageBox::warning(m_parent, tr("Warning"),
            tr("User for file transfer must be entered."), QObject::tr("&OK"));
        return false;
    }
    /*if (qs2ws(m_solWidget->m_unixTPassword->text()).size() < 1)
    {
        wstring message;
        message = L"No password for terminal connection was entered.";
        QMessageBox::warning(m_parent, tr("Warning"),
        ws2qs(message), "&OK");
    }
    if (qs2ws(m_solWidget->m_unixFTPassword->text()).size() < 1)
    {
        wstring message;
        message = L"No password for file transfer was entered.";
        QMessageBox::warning(m_parent, tr("Warning"),
        ws2qs(message), "&OK");
    }*/
    }

    if (qs2ws(m_winWidget->m_downloadDir->text()).size() > 0)
    {
	wstring s = qs2ws(m_winWidget->m_downloadDir->text());
	if (s.substr(0, 2) == L"\\\\"
            || s.substr(0, 2) == L"//")
	{
	    wstring message;
	    message = L"Please specify a local directory for a temporary download location.";
	    QMessageBox::warning(m_parent, tr("Warning"),
                    ws2qs(message), QObject::tr("&OK"));
	    return false;
	}

	WindowsStorage tempDir(s, m_services);
	if (!tempDir.exists())
    //Kulakov: BUGFIX 15034
    {
        try
        {
            tempDir.create();
        }
        catch (GenericException&) {}
    }
    //Kulakov: END IF 15034
	if (!tempDir.exists())
	{
	    wstring message;
	    message = L"Unable to create temporary download location " + s;
	    QMessageBox::warning(m_parent, tr("Warning"),
                    ws2qs(message), QObject::tr("&OK"));
	    return false;
	}
    }

    return true;
}

bool WinSolRepoSettings::save()
{
=====================================================================
Found a 214 line (966 tokens) duplication in the following files: 
Starting at line 2632 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 1218 of D:\home\eCora_PM\PM\patchRepository\WinSolRepoSettings.cpp

                    unixSettings->setHostname(storage->hostName());
                }
            }
        }
    }
    catch (GenericException& e)
    {
        m_errorMessage = e.userMessage();
        res = false;
    }

    log(L"patchRepository", Log::Debug, L"Exit WinSolRepoSettings::test");
    return res;
}

bool WinSolRepoSettings::checkValidityAfterTest()
{
    UnixRepositorySettings* unixSettings = 0;
    for (int i = 0; i < m_repositories.size(); ++i)
    {
        if (m_repositories[i]->systemType() == L"solaris")
        {
            unixSettings = static_cast<UnixRepositorySettings*> (m_repositories[i]);
            break;
        }
    }

    if (unixSettings && m_solWidget->m_enableUnix->isChecked())
    {
        wstring domainName = unixSettings->dnsDomain();
        wstring hostName = unixSettings->hostname();

        wstring uiDomain = qs2ws(m_solWidget->m_unixDNSDomain->text());
        wstring uiIp = qs2ws(m_solWidget->m_unixIPAddress->text());
        wstring uiHost = qs2ws(m_solWidget->m_unixHostname->text());

        // check for domain mis-match
        if (!uiDomain.empty() && (uiDomain != domainName))
        {
            QString message = tr("Unix Repository: The domain name entered (") + ws2qs(uiDomain) +
                tr(") does not match the domain name found (") + ws2qs(domainName) +
                tr(") returned by /usr/bin/domainname. The connection was made to ") +
                ws2qs(uiIp) + tr(".");
            QMessageBox::warning(m_parent, tr("Warning"),
                message, QObject::tr("&OK"));

            return false;
        }

        if (!uiHost.empty() && (uiHost != uiIp) && (uiHost != hostName))
        {
            QString message = tr("Unix Repository: The hostname named entered (") + ws2qs(uiHost) +
                tr(") does not match the hostname (") + ws2qs(hostName) +
                tr(") returned by /usr/bin/hostname.  The connection was made to ") +
                ws2qs(uiIp) + tr(".");
            QMessageBox::warning(m_parent, tr("Warning"),
                message, QObject::tr("&OK"));

            return false;
        }

    }
    return checkValidityOfTempDownloadDir();
}


bool WinSolRepoSettings::checkValidityOfTempDownloadDir()
{
    WindowsRepositorySettings* wSettings = 0;
    for (int i = 0; i < m_repositories.size(); ++i)
    if (m_repositories[i]->systemType() == L"windows")
    {
        wSettings = static_cast<WindowsRepositorySettings*> (m_repositories[i]);
        break;
    }

    // don't let the user specify same directory for windows repository and temp download path!!!
    // this means everything get downloaded, validated, status table set, and then the patch is deleted
    if (wSettings && m_winWidget->m_enableWindows->isChecked() && qs2ws(m_winWidget->m_downloadDir->text()).size() > 0)
    {
        try
        {
            WindowsStorage repoTest(wSettings, wSettings->path(), m_services);
            WindowsStorage tempDownloadTest(qs2ws(m_winWidget->m_downloadDir->text()), m_services);
                repoTest.connect();
            tempDownloadTest.connect();

            com::ISettings* iSet = 0;
            if (m_services)
            {
                HRESULT hr = m_services->QueryInterface(IID_ISettings, (void**)&iSet);

                wstring source = iSet->setting(L"root") + L"/bin/EcoraRepoTest.txt";
                if (tempDownloadTest.fileExists(L"EcoraRepoTest.txt"))
                    tempDownloadTest.deleteFile(L"EcoraRepoTest.txt");

                repoTest.addFile(source, L"EcoraRepoTest.txt", 0, 0);
                if (tempDownloadTest.fileExists(L"EcoraRepoTest.txt"))
                {
                    QString message = tr("Please enter a different directory for the temporary download location.\n"
                    "The temporary download location must be different than the Windows repository path.");
                    QMessageBox::warning(m_parent, tr("Warning"), message, QObject::tr("&OK"));
                    return false;
                }
            }
        }
        catch (GenericException& e)
        {
            log(L"patchRepository", Log::Error,
            L"Unable to verify windows repository path not same as temp download dir: "
            << e.userMessage());
        }
    }

    // it's valid, save it
    m_pISettings->setSetting(L"repositoryDownloadDirectory", qs2ws(m_winWidget->m_downloadDir->text()));
    return true;
}

bool WinSolRepoSettings::update()
{
    if (m_pIRepositoryManager)
    {
        bool res;
        try
        {
            res = m_pIRepositoryManager->createRepositories(m_repositories,
                m_errorMessage, m_winWidget->m_removeUnusedStatus->isChecked());
        }
        catch (GenericException& e)
        {
            m_errorMessage = e.userMessage();
            res = false;
        }
        return res;
    }
    return false;
}

void WinSolRepoSettings::loadPMAgents()
{
    if (m_pIRepositoryManager)
    {
        m_pIRepositoryManager->loadPMAgents();
    }
}

// FIXME - cleanup needed - now using IDbManager, no longer need dsn info to be passed
/*
void WinSolRepoSettings::dsnChanged(const wstring& dsn, const wstring& username,
                      const wstring& password)
*/
void
WinSolRepoSettings::dsnChanged()
{
    //m_currentDsn = dsn;
    //m_currentUser = username;
    //m_currentPassword = password;
    m_dsnChanged = true;

    try
    {
        PatchQueryHelper qh(m_services);
        qh.reopenDatabase();


        init();

        onWindows();
        onUnix();
    }
    catch (GenericException& e)
    {
        log(L"patchRepository", Log::Error, L"Unable to reopen database after DSN changed.");
        log(L"patchRepository", Log::Error, e.userMessage());
    }
}

bool WinSolRepoSettings::isLocalPath(const wstring& path)
{
    if (path[1] == L':')
    return true;
    return false;
}

//Sergey Sokolov - Fix bug 14378 ->
wstring WinSolRepoSettings::convertBackSlashes(const wstring& path)
{
    wstring convertedPath = path;
    size_t pos = convertedPath.find(L"\\");
    while (pos != wstring::npos)
    {
        convertedPath.replace(pos, 1, L"/");
        pos = convertedPath.find(L"\\", pos + 1);
    }

    return convertedPath;
}
//Sergey Sokolov - Fix bug 14378 <-

wstring WinSolRepoSettings::convertSlashes(const wstring& path)
{
    wstring convertedPath = path;
    size_t pos = convertedPath.find(L"/");
    while (pos != wstring::npos)
    {
        convertedPath.replace(pos, 1, L"\\");
        pos = convertedPath.find(L"/", pos + 1);
    }

    return convertedPath;
}

} // namespace
=====================================================================
Found a 185 line (937 tokens) duplication in the following files: 
Starting at line 28 of D:\home\eCora_PM\PM\network\Http.cc
Starting at line 28 of D:\home\eCora_PM\PM\network\network\Http.cc

namespace network {

class HttpPrivate : public CurlImpl
{
  public:

    HttpPrivate(Http* client, const wstring& cookies, 
                const wstring& userAgentLocation, IUnknown* pUnkOuter);
    ~HttpPrivate();

    bool url2wstring(
        const wstring& url, wstring* content, 
        com::NetworkResult** result, bool tryLogin);
    
    bool url2file(
        const wstring& url, const wstring& file, 
        com::NetworkResult** result, bool tryLogin);
    
    int decodeHeader(
        FILE* headerHandle, wstring& description,
        wstring& locationUrl, AuthenticationType& authType);
    
    bool doUrl(
        const wstring& url, bstring* content, 
        const wstring& outputFile, com::NetworkResult** result);
    
    bool redirect(
        const wstring& redirectUrl, const wstring& url, 
        bstring* content, const wstring& file, 
        com::NetworkResult** res);
    
    bool callLoginAgent(
        HttpLogin* login, const wstring& url);
    
    com::BaseObject m_comBase;
    Http* m_client;
    set<HttpLogin*> m_loginAgents;
  private:
    bool m_bTryNTLM;
};
    
HttpPrivate::HttpPrivate(
    Http* client, const wstring& cookies, 
    const wstring& userAgentLocation, IUnknown* pUnkOuter)
    : CurlImpl(userAgentLocation), m_comBase(pUnkOuter, false)
{
    m_client = client;
    
    const char* cook = strdup(ws2utf8s(cookies).c_str());
    m_garbage.push_back(cook);
    
    curl_easy_setopt(m_handle, CURLOPT_COOKIEFILE, cook);
    m_bTryNTLM = false;
}

HttpPrivate::~HttpPrivate()
{
}

static void
closeAndUnlink(FILE* fp, const wstring& filename)
{
    fclose(fp);
    unlink(ws2utf8s(filename).c_str());
}

bool
HttpPrivate::doUrl(
    const wstring& url, bstring* content, const wstring& outputFile,
    com::NetworkResult** httpRes)
{
    m_aborted = false;

    int code = 0;
    auto_ptr<char> script;
    auto_ptr<char> data;
    auto_ptr<char> userpass_cstr;

    FILE* bodyHandle = 0;
    FILE* headerHandle = 0;

    // Be ready to receive an error message.
    char error[CURL_ERROR_SIZE + 1];
    memset(error, 0, CURL_ERROR_SIZE);
    curl_easy_setopt(m_handle, CURLOPT_ERRORBUFFER, error);

    if (!m_login.empty() && m_password.empty())
    {
        wstring userpass = m_login + L":" + m_password;
        userpass_cstr = auto_ptr<char>(strdup(ws2utf8s(userpass).c_str()));
        curl_easy_setopt(m_handle, CURLOPT_USERPWD, userpass_cstr.get());

    }
    else
        curl_easy_setopt(m_handle, CURLOPT_USERPWD, 0);

    //  Allow basic authentication to the host.
    curl_easy_setopt(m_handle, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
    
    // Find the first '?'.
    bstring::size_type pos = url.find('?');
    if (pos != bstring::npos)
    {
        // Fill in the script arguments
        script = auto_ptr<char>(strdup(ws2utf8s(url.substr(0, pos)).c_str()));
        data = auto_ptr<char>(
            strdup(ws2utf8s(url.substr(pos + 1, bstring::npos)).c_str()));
        
        curl_easy_setopt(m_handle, CURLOPT_POSTFIELDS, data.get());
        curl_easy_setopt(m_handle, CURLOPT_POSTFIELDSIZE, strlen(data.get()));
        
        // shouldn't need this, but it won't work on windows otherwise
        // curl_easy_setopt(m_handle, CURLOPT_CUSTOMREQUEST, "POST");
    }
    else
    {
        // Set back to GET
        curl_easy_setopt(m_handle, CURLOPT_HTTPGET, 1);
        
        // shouldn't need this, HTTPGET doesn't seem to work
 //       curl_easy_setopt(m_handle, CURLOPT_CUSTOMREQUEST, "GET");
        curl_easy_setopt(m_handle, CURLOPT_POSTFIELDS, 0);
        curl_easy_setopt(m_handle, CURLOPT_POSTFIELDSIZE, 0);
        
        script = auto_ptr<char>(strdup(ws2utf8s(url).c_str()));
    }
    
    curl_easy_setopt(m_handle, CURLOPT_URL, script.get());
    
    char tmpfilename[L_tmpnam + 1];
    strcpy(tmpfilename, tmpnam(NULL));
    wstring tmpFile = utf8s2ws(utf8string(tmpfilename));
    
    headerHandle = fopen(ws2utf8s(tmpFile).c_str(), "w+b");
    
    if (headerHandle == 0)
        throw GenericException(
            __FILE__, __LINE__, L"HttpPrivate::doUrl", L"",
            L"Could not open header temp file for writing.");
    
    ON_BLOCK_EXIT(closeAndUnlink, headerHandle, tmpFile);
    
    curl_easy_setopt(m_handle, CURLOPT_WRITEHEADER, headerHandle);
    
    // Setup the file to capture the content information
    char bodyfilename[L_tmpnam + 1];
    strcpy(bodyfilename, tmpnam(NULL));
    wstring bodyFile = utf8s2ws(utf8string(bodyfilename));
    
    wstring outFile = outputFile;
    if (outFile.empty())
        outFile = bodyFile;
    
    bodyHandle = fopen(ws2utf8s(outFile).c_str(), "w+b");
    
    if (bodyHandle == 0)
        throw GenericException(
            __FILE__, __LINE__, L"HttpPrivate::doUrl", L"",
            L"Could not open: " + outputFile + L" for writing.");
    
    // Only one of these guards should be executed
    ScopeGuard delContent = makeGuard(closeAndUnlink, bodyHandle, outFile);
    ScopeGuard closeContent = makeGuard(fclose, bodyHandle);
    
    if (outputFile.empty())
        closeContent.dismiss();
    else
        delContent.dismiss();
    
    curl_easy_setopt(m_handle, CURLOPT_FILE, bodyHandle);
    long fileTime;
    curl_easy_setopt(m_handle, CURLOPT_FILETIME, &fileTime);
    
    CURLcode result = curl_easy_perform(m_handle);
    
    wstring desc = mapErrorMessage(result);

    if (result == CURLE_OK)
    {
        wstring locationUrl;
        AuthenticationType authType;
        code = decodeHeader(headerHandle, desc, locationUrl, authType);

        if (code == 302)
        {
=====================================================================
Found a 138 line (795 tokens) duplication in the following files: 
Starting at line 372 of D:\home\eCora_PM\PM\pmDaoDbImpl\DaoDbImplUnitTest.h
Starting at line 531 of D:\home\eCora_PM\PM\pmDaoXmlImpl\DaoXmlImplUnitTest.h

    void testSeekEntity()
    {
        pmDaoInterfaces::IDaoFactory* iDaoFactory = getDaoFactory();
        if (!iDaoFactory)
        {
            TS_FAIL("Could not get IDaoFactory");
            return;
        }

        pmDaoInterfaces::IScan* iScan = iDaoFactory->getIScan();
        assert(iScan);

        pmDaoInterfaces::ISystem* iSystem = iScan->getSystem();
        TS_ASSERT(iSystem);

        createSystemObjectGraph(iSystem);

        TS_ASSERT(iSystem->first());

        pmDaoInterfaces::IActivity* iActivity = iSystem->getActivities();

        TS_ASSERT(iActivity->first());
        wstring activityId = iActivity->getId();
        wstring productInstance = iActivity->getProductInstance();
        wstring patchId = iActivity->getPatchId();
        wstring versionId = iActivity->getProductVersionId();
        wstring source = iActivity->getSource();
        wstring status = iActivity->getStatus();
        wstring comment = iActivity->getComment();

        TS_ASSERT(iActivity->last());

        TS_ASSERT(iActivity->seek(activityId));

        TS_ASSERT(activityId == iActivity->getId());
        TS_ASSERT(productInstance == iActivity->getProductInstance());
        TS_ASSERT(patchId == iActivity->getPatchId());
        TS_ASSERT(versionId == iActivity->getProductVersionId());
        TS_ASSERT(source == iActivity->getSource());
        TS_ASSERT(status == iActivity->getStatus());
        TS_ASSERT(comment == iActivity->getComment());

        TS_ASSERT(iActivity->last());

        activityId = iActivity->getId();
        productInstance = iActivity->getProductInstance();
        patchId = iActivity->getPatchId();
        versionId = iActivity->getProductVersionId();
        source = iActivity->getSource();
        status = iActivity->getStatus();
        comment = iActivity->getComment();

        TS_ASSERT(iActivity->first());

        TS_ASSERT(iActivity->seek(activityId));

        TS_ASSERT(activityId == iActivity->getId());
        TS_ASSERT(productInstance == iActivity->getProductInstance());
        TS_ASSERT(patchId == iActivity->getPatchId());
        TS_ASSERT(versionId == iActivity->getProductVersionId());
        TS_ASSERT(source == iActivity->getSource());
        TS_ASSERT(status == iActivity->getStatus());
        TS_ASSERT(comment == iActivity->getComment());
    }

    void createSystemObjectGraph(pmDaoInterfaces::ISystem* iSystem)
    {
        assert(iSystem);

        iSystem->setScanId(L"2000");
        iSystem->setSystemScanId(L"2000");
        iSystem->setSystemId(L"BIGMOUNTAIN/BSP");
        iSystem->setName(L"BIGMOUNTAIN");
        iSystem->setIpAddress(L"192.168.0.31");
        iSystem->setOs(L"Windows NT Server 4.0");
        iSystem->setOsVersionId(L"Windows NT Server 4.0 - Windows NT4 Service Pack 6a");
        iSystem->setOsLanguage(L"ENU");
        iSystem->setServer(1);
        iSystem->setStatus(L"Test status");

        pmDaoInterfaces::IWindowsSystemExtension* iWindowsSystemExtension = iSystem->addWindowsSystemExtension();

        iWindowsSystemExtension->setDomain(L"BSP");
        iWindowsSystemExtension->setWinDir(L"C:\\WINNT40");
        iWindowsSystemExtension->setSqlDir(L"C:\\Program Files\\Microsoft SQL Server\\MSSQL");
        iWindowsSystemExtension->setSqlSharedCodeDir(L"C:\\Program Files\\Microsoft SQL Server\\80\\COM\\");
        iWindowsSystemExtension->setExchangeDir(L"C:\\Program Files\\Exchange 2000\\");
        iWindowsSystemExtension->setProgramFilesDir(L"C:\\Program Files");
        iWindowsSystemExtension->setCommonFilesDir(L"C:\\Program Files\\Common Files");

        addTestActivities(iSystem);

        addTestProductsAndPatches(iSystem);
    }

    void addTestActivities(pmDaoInterfaces::ISystem* iSystem)
    {
        assert(iSystem);

        pmDaoInterfaces::IActivity* iActivity = iSystem->addActivity();

        iActivity->setProductInstance(L"Default");
        iActivity->setPatchId(L"CWw0J4JYjH6opqzOYeohVQ==");
        iActivity->setProductVersionId(L"");
        iActivity->setSource(L"SOURCE_PATCH");
        iActivity->setStatus(L"UNINSTALLSTRING_NOTFOUND");
        iActivity->setComment(L"The following registry key has not been found: "
            L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Q317244");

        iActivity = iSystem->addActivity();

        iActivity->setProductInstance(L"Default");
        iActivity->setPatchId(L"");
        iActivity->setProductVersionId(L"Internet Information Server 4.0 - Windows NT4 Service Pack 6a");
        iActivity->setSource(L"SOURCE_PRODUCT");
        iActivity->setStatus(L"A status");
        iActivity->setComment(L"Add IIS product : Internet Information Services 4.0");

        iActivity = iSystem->addActivity();

        iActivity->setProductInstance(L"Default");
        iActivity->setPatchId(L"");
        iActivity->setProductVersionId(L"Internet Information Server 4.0 - Windows NT4 Service Pack 4");
        iActivity->setSource(L"SOURCE_PRODUCT");
        iActivity->setStatus(L"A status");
        iActivity->setComment(L"Add IIS product : Internet Information Services 4.0");
    }

    void addTestProductsAndPatches(pmDaoInterfaces::ISystem* iSystem)
    {
        assert(iSystem);

        pmDaoInterfaces::IProduct* iProduct = iSystem->addProduct();

        iProduct->setVersionId(L"Internet Information Server 4.0 - Windows NT4 Service Pack 6a");
        iProduct->setInstance(L"Test Instance");
        iProduct->setLocation(L"Test Location");
        iProduct->setLanguage(L"ENU");
=====================================================================
Found a 146 line (740 tokens) duplication in the following files: 
Starting at line 18 of D:\home\eCora_PM\PM\agent\agent\Library\Common\ScopeGuard.h
Starting at line 18 of D:\home\eCora_PM\PM\utils\ScopeGuard.h

template<class T>
class ReferenceHolder
{
  public:
    ReferenceHolder(T& reference) : m_reference(reference) {}
    operator T&() const { return m_reference; }

  private:
    // Disable assignment - not implemented.
    ReferenceHolder& operator=(const ReferenceHolder&);
    T& m_reference;
};


template<class T>
inline ReferenceHolder<T> ByReference(T& t)
{
    return ReferenceHolder<T>(t);
}


class ScopeGuardBase
{
  public:
    ScopeGuardBase& operator=(const ScopeGuardBase&);
    ScopeGuardBase() throw() : m_dismissed(false) {}
    void dismiss() const throw() { m_dismissed = true; }
    void keep() const throw() { m_dismissed = false; }

  protected:
    ScopeGuardBase(const ScopeGuardBase& other) throw() :
	m_dismissed(other.m_dismissed) { other.dismiss(); }
    ~ScopeGuardBase() {}

    template<typename J>
    static void safeExecute(J& j) throw()
    {
	if (!j.m_dismissed)
	    try { j.execute(); }
	    catch (...) {}
    }

    mutable bool m_dismissed;
};


typedef const ScopeGuardBase& ScopeGuard;


template<typename F>
class ScopeGuard0 : public ScopeGuardBase
{
  public:
    static ScopeGuard0<F> makeGuard(F f) {
	return ScopeGuard0<F>(f); }

    ~ScopeGuard0() throw() { safeExecute(*this); }
    void execute() { m_function(); }

  protected:
    ScopeGuard0(F f) : m_function(f) {}

    F m_function;
};


template<typename F>
inline ScopeGuard0<F>
makeGuard(F f)
{
    return ScopeGuard0<F>::makeGuard(f);
}


template<typename F, typename P1>
class ScopeGuard1 : public ScopeGuardBase
{
  public:
    static ScopeGuard1<F, P1>
    makeGuard(F f, P1 p1)
    {
	return ScopeGuard1<F, P1>(f, p1);
    }

    ~ScopeGuard1() throw() { safeExecute(*this); }
    void execute() { m_function(m_parameter1); }

  protected:
    ScopeGuard1(F f, P1 p1) : m_function(f), m_parameter1(p1) {}

    F m_function;
    const P1 m_parameter1;
};


template<typename F, typename P1>
inline ScopeGuard1<F, P1>
makeGuard(F f, P1 p1)
{
    return ScopeGuard1<F, P1>::makeGuard(f, p1);
}


template<typename F, typename P1, typename P2>
class ScopeGuard2: public ScopeGuardBase
{
  public:
    static ScopeGuard2<F, P1, P2>
    makeGuard(F f, P1 p1, P2 p2)
    {
	return ScopeGuard2<F, P1, P2>(f, p1, p2);
    }

    ~ScopeGuard2() throw() { safeExecute(*this); }
    void execute() { m_function(m_parameter1, m_parameter2); }

  protected:
    ScopeGuard2(F f, P1 p1, P2 p2) :
	m_function(f), m_parameter1(p1), m_parameter2(p2) {}

    F m_function;
    const P1 m_parameter1;
    const P2 m_parameter2;
};


template<typename F, typename P1, typename P2>
inline ScopeGuard2<F, P1, P2>
makeGuard(F f, P1 p1, P2 p2)
{
    return ScopeGuard2<F, P1, P2>::makeGuard(f, p1, p2);
}


template<typename F, typename P1, typename P2, typename P3>
class ScopeGuard3 : public ScopeGuardBase
{
  public:
    static ScopeGuard3<F, P1, P2, P3>
    makeGuard(F f, P1 p1, P2 p2, P3 p3)
    {
	return ScopeGuard3<F, P1, P2, P3>(f, p1, p2, p3);
    }

    ~ScopeGuard3() throw() { safeExecute(*this); }
    void execute() { m_function(m_parameter1, m_parameter2, m_parameter3); }
=====================================================================
Found a 183 line (706 tokens) duplication in the following files: 
Starting at line 32 of D:\home\eCora_PM\PM\pmOAService\CommandLine.cpp
Starting at line 31 of D:\home\eCora_PM\PM\pmServices\pmServiceTester\CommandLine.cpp

    parseCmdLine(&cmdLineArgs, GetCommandLine());

    int argc = cmdLineArgs.size();
    wchar_t** argv = new wchar_t*[argc];
    for (int i = 0 ; i < argc; ++i)
    {
        wstring arg = cmdLineArgs[i];
        if (!i)
        {
            arg = wstring2vector(wstring2vector(arg, L"\\").back(), L".").front();
        }

        argv[i] = new wchar_t[arg.size() + 1];
        wcscpy(argv[i], arg.c_str());
    }

    setupOptions(argc, argv);

    for (int j = 0 ; j < argc; ++j)
    {
        delete[] argv[j];
    }
    delete[] argv;
}

void
CommandLine::parseCmdLine(vector<wstring>* words, const wstring& line)
{
    wstring word(L"");
    bool startWord = false;
    bool startQuote = false;

    wstring::const_iterator chIt = line.begin();
    for (; chIt != line.end(); ++chIt)
    {
        wchar_t c = *chIt;
        if (c == L'\"')
        {
            if (startWord)
            {
                startWord = false;
                words->push_back(word);
                word.erase();
            }
            else
            {
                startWord = true;
            }

            startQuote = !startQuote;

            continue;
        }

        if (c != L' ' && c != L'\t')
        {
            if (!startWord)
            {
                startWord = true;
            }
            word.append(1, c);
        }
        else
        {
            if (startQuote)
            {
                word.append(1, c);
            }
            else
            {
                if (startWord)
                {
                    startWord = false;
                    words->push_back(word);
                    word.erase();
                }
            }
        }
    }

    if (startQuote)
    {
        wstring errorMsg(L"Parsing error: double quotes not closed ! [");
        errorMsg.append(line).append(L"]");
        throw GenericException(
            __FILE__, __LINE__, L"CommandLine::parseCmdLine", L"", errorMsg);
    }

    if (startWord)
    {
        words->push_back(word);
    }
}

void
CommandLine::setupOptions(int argc, wchar_t** argv)
{
    assert(argc);
    assert(argv);

    WGetopt options(argc, argv);
    wstring logSpec;

    wchar_t c;
    while ((c = options.next(L"z:h:u:b:d:s:")) != WEOF)
    {
        switch (c)
        {
            case L'h':
            {
                m_mode = MODE_HELP;
                m_topic = options.optarg();
                break;
            }

            case L'z':
            {
                m_mode = MODE_PUSHBATCH;
                m_topic = options.optarg();
                break;
            }

            case 'u': //updates
            {
                m_mode = MODE_UPDATE;
                if (!options.optarg())
                {
                    log(L"checkOptions", Log::Error, L"Invalid argument for patch database update");
                    throw GenericException(__FILE__, __LINE__, L"CommandLine::CommandLine", L"",
                        L"Invalid argument for patch database update");
                }

                m_topic = options.optarg();

                if (0 != m_topic.compare(L"check") &&
                    0 != m_topic.compare(L"download") &&
                    0 != m_topic.compare(L"install"))
                {
                    log(L"checkOptions", Log::Error, L"Invalid argument for patch database update");
                    throw GenericException(__FILE__, __LINE__, L"CommandLine::CommandLine", L"",
                        L"Invalid argument for patch database update");
                }
                break;
            }

            case 'b': // batch
            {
                m_mode = MODE_BATCH;
                m_topic = options.optarg();
                break;
            }

            case 'd': // download
            {
                m_mode = MODE_DOWNLOAD;      
                
		if (!options.optarg())
                {
                    log(L"checkOptions", Log::Error, L"Invalid argument for patch download");
                    throw GenericException(__FILE__, __LINE__, L"CommandLine::CommandLine", L"",
                        L"Invalid argument for patch download");
                }

                m_topic = options.optarg();

                break;
            }

            case 's': // scheduled repository maintenance
            {
                m_mode = MODE_REPOMAINTENANCE;
                m_topic = options.optarg();
                break;
            }

            default:
            {
                throw GenericException(__FILE__, __LINE__, L"errors - command line", L"",
                    L"Invalid arguments to program.");
            }
        }
    }
}
=====================================================================
Found a 114 line (687 tokens) duplication in the following files: 
Starting at line 163 of D:\home\eCora_PM\PM\agent\agent\Library\Common\ScopeGuard.h
Starting at line 163 of D:\home\eCora_PM\PM\utils\ScopeGuard.h

    void execute() { m_function(m_parameter1, m_parameter2, m_parameter3); }

  protected:
    ScopeGuard3(F f, P1 p1, P2 p2, P3 p3) :
	m_function(f), m_parameter1(p1), m_parameter2(p2), m_parameter3(p3) {}

    F m_function;
    const P1 m_parameter1;
    const P2 m_parameter2;
    const P3 m_parameter3;
};


template<typename F, typename P1, typename P2, typename P3>
inline ScopeGuard3<F, P1, P2, P3>
makeGuard(F f, P1 p1, P2 p2, P3 p3)
{
    return ScopeGuard3<F, P1, P2, P3>::makeGuard(f, p1, p2, p3);
}


template<class O, typename MF>
class ObjectScopeGuard0 : public ScopeGuardBase
{
  public:
    static ObjectScopeGuard0<O, MF>
    makeObjectGuard(O& o, MF mf)
    {
	return ObjectScopeGuard0<O, MF>(o, mf);
    }

    ~ObjectScopeGuard0() throw() { safeExecute(*this); }
    void execute() { (m_object.*m_memberFunction)(); }

  protected:
    ObjectScopeGuard0(O& o, MF mf) :
	m_object(o), m_memberFunction(mf) {}

    O& m_object;
    MF m_memberFunction;
};


template<class O, typename MF>
inline ObjectScopeGuard0<O, MF>
makeObjectGuard(O& o, MF mf)
{
    return ObjectScopeGuard0<O, MF>::makeObjectGuard(o, mf);
}


template<class O, typename MF, typename P1>
class ObjectScopeGuard1 : public ScopeGuardBase
{
  public:
    static ObjectScopeGuard1<O, MF, P1>
    makeObjectGuard(O& o, MF mf, P1 p1)
    {
	return ObjectScopeGuard1<O, MF, P1>(o, mf, p1);
    }

    ~ObjectScopeGuard1() throw() { safeExecute(*this); }
    void execute() { (m_object.*m_memberFunction)(m_parameter1); }

  protected:
    ObjectScopeGuard1(O& o, MF mf, P1 p1) :
	m_object(o), m_memberFunction(mf), m_parameter1(p1) {}

    O& m_object;
    MF m_memberFunction;
    const P1 m_parameter1;
};


template<class O, typename MF, typename P1>
inline ObjectScopeGuard1<O, MF, P1>
makeObjectGuard(O& o, MF mf, P1 p1)
{
    return ObjectScopeGuard1<O, MF, P1>::makeObjectGuard(o, mf, p1);
}


template<class O, typename MF, typename P1, typename P2>
class ObjectScopeGuard2 : public ScopeGuardBase
{
  public:
    static ObjectScopeGuard2<O, MF, P1, P2>
    makeObjectGuard(O& o, MF mf, P1 p1, P2 p2)
    {
	return ObjectScopeGuard2<O, MF, P1, P2>(o, mf, p1, p2);
    }

    ~ObjectScopeGuard2() throw() { safeExecute(*this); }
    void execute() {
	(m_object.*m_memberFunction)(m_parameter1, m_parameter2); }

  protected:
    ObjectScopeGuard2(O& o, MF mf, P1 p1, P2 p2) :
	m_object(o), m_memberFunction(mf),
	m_parameter1(p1), m_parameter2(p2) {}

    O& m_object;
    MF m_memberFunction;
    const P1 m_parameter1;
    const P2 m_parameter2;
};


template<class O, typename MF, typename P1, typename P2>
inline ObjectScopeGuard2<O, MF, P1, P2>
makeObjectGuard(O& o, MF mf, P1 p1, P2 p2)
{
    return ObjectScopeGuard2<O, MF, P1, P2>::makeObjectGuard(o, mf, p1, p2);
}
=====================================================================
Found a 117 line (656 tokens) duplication in the following files: 
Starting at line 2432 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 1023 of D:\home\eCora_PM\PM\patchRepository\WinSolRepoSettings.cpp

        windowsSettings->setUsername(qs2ws(m_winWidget->m_windowsLogin->text()));
        windowsSettings->setPassword(qs2ws(m_winWidget->m_windowsPassword->text()));

        windowsSettings->setCredentialsAvailable(true);

        if (windowsSettings)
            m_repositories.push_back(windowsSettings);

        m_pISettings->setSetting(L"upgrade20Repository",
            (m_winWidget->m_upgrade20Repo->isChecked() ? L"1" : L"0"));

    }

    if (m_originalWindowsSettings && windowsSettings)
    {
        if (!m_originalWindowsSettings->matches(windowsSettings))
        {
            log(L"patchRepository", Log::Debug,
            L"Windows repository settings need to be saved - don't match original.");
            needToSave = true;
        }
    }
    else if (m_originalWindowsSettings || windowsSettings)
    {
        log(L"patchRepository", Log::Debug,
            L"Windows repository settings need to be saved - added or deleted.");
        needToSave = true;
    }

    UnixRepositorySettings* unixSettings = 0;
    if (m_solWidget->m_enableUnix->isChecked())
    {
        log(L"patchRepository", Log::Debug, L"Unix repository enabled");
        wstring hostId = qs2ws(m_solWidget->m_unixHostname->text());
        if (hostId.empty())
            hostId = qs2ws(m_solWidget->m_unixIPAddress->text());
        wstring path = qs2ws(m_solWidget->m_unixRepository->text());

        //Sergey Sokolov - Fix bug 14378
        path = convertBackSlashes(path);

        unixSettings = new UnixRepositorySettings(m_services, hostId, hostId,
            path, L"solaris", L"solaris");

        unixSettings->setHostname(qs2ws(m_solWidget->m_unixHostname->text()));
        unixSettings->setDnsDomain(qs2ws(m_solWidget->m_unixDNSDomain->text()));
        unixSettings->setIpAddress(qs2ws(m_solWidget->m_unixIPAddress->text()));
        //unixSettings->setmd5Path(qs2ws(m_solWidget->m_unixMd5->text()));

        unixSettings->setTUsername(qs2ws(m_solWidget->m_unixTUsername->text()));
        unixSettings->setTPassword(qs2ws(m_solWidget->m_unixTPassword->text()));
        unixSettings->setTRootPassword(qs2ws(m_solWidget->m_unixTRootPass->text()));
        unixSettings->setTProtocol(qs2ws(m_solWidget->m_unixTProtocol->currentText()));

        unixSettings->setFtUsername(qs2ws(m_solWidget->m_unixFTUsername->text()));
        unixSettings->setFtPassword(qs2ws(m_solWidget->m_unixFTPassword->text()));
        unixSettings->setFtProtocol(qs2ws(m_solWidget->m_unixFTProtocol->currentText()));

        unixSettings->setCredentialsAvailable(true);

        if (m_advancedUnix)
        {
            unixSettings->setTConnectionDelay(m_advancedUnix->tConnectionDelay());
            unixSettings->setTLoginPrompt(m_advancedUnix->tLoginPrompt());
            unixSettings->setTRootConnectionDelay(m_advancedUnix->tRootConnectionDelay());
            unixSettings->setTRootLoginPrompt(m_advancedUnix->tRootLoginPrompt());
            unixSettings->setTPort(m_advancedUnix->tPort());

            unixSettings->setFtPort(m_advancedUnix->ftPort());
        }

        if (unixSettings)
            m_repositories.push_back(unixSettings);
    }
    if (m_originalUnixSettings && unixSettings)
    {
        if (!m_originalUnixSettings->matches(unixSettings))
        {
            log(L"patchRepository", Log::Debug,
            L"Unix repository settings need to be saved - don't match original.");
            needToSave = true;
        }
    }
    else if (m_originalUnixSettings || unixSettings)
    {
        log(L"patchRepository", Log::Debug,
        L"Unix repository settings need to be saved - added or deleted.");
        needToSave = true;
    }

    if (!needToSave)
    {
        log(L"patchRepository", Log::Debug, L"No repository setting changes - no save");
        if (m_dsnChanged)
        {
            wstring errMessage;
            m_pIRepositoryManager->reloadRepositories(false);
            m_pIRepositoryManager->updateEvent(errMessage);
        }

        m_pISettings->setSetting(L"repositoryDatabaseCleanup",
            (m_winWidget->m_removeUnusedStatus->isChecked() ? L"true" : L"false"));
        return checkValidityOfTempDownloadDir();
    }

    // test repo connections
    log(L"patchRepository", Log::Debug, L"Test repository connections");
    bool testSuccess = inDialog<bool>(
        m_parent,
        qs2ws(tr("Saving repository settings...")),
        intercept::memberFunction<bool>(*this, &WinSolRepoSettings::test));

    WinSolRepoTranslator translator;

    if (!testSuccess)
    {
        QMessageBox::warning(0,
=====================================================================
Found a 169 line (652 tokens) duplication in the following files: 
Starting at line 34 of D:\home\eCora_PM\PM\network\main.cc
Starting at line 34 of D:\home\eCora_PM\PM\network\network\main.cc

using namespace std;
using namespace network;

#define PRINT_RESULT(res)\
{\
    Result* XresX = dynamic_cast<Result*>(res);\
    wcout << *XresX;\
}


class MyListener : public com::NetworkListener
{
  public:
    virtual void downloadProgress(double amount, double total);
    virtual void uploadProgress(double amount, double total);
};

class MyLoginAgent : public HttpLogin
{
  public:

    virtual bool login(Http* client, const wstring& url);
};

int 
main(int argc, char* argv[])
{
    ThreadUtils::init();

    wstring furl = L"ftp://ftp.iol.unh.edu/pub/ip/routing/member.doc";
    wstring ffile = L"c:\\ecora\\member.doc";

#ifdef TEST_GENERAL

    network::GeneralClient* client = new GeneralClient(L"cookies.txt", L"");
#define hclient client
#define fclient client

#else // !TEST_GENERAL

    network::Http* hclient = new Http(L"cookies.txt");
    network::Ftp* fclient = new Ftp();

#endif 

    MyListener mylistener;
    MyLoginAgent agent;

    try
    {
	bool res;
	wstring s;
	com::NetworkResult* result;

#ifdef TEST_HTTP

	// Download and show the size of the downloaded string
        res = hclient->url2wstring(
	    L"http://data.ecora.com/~rlarocc/menu.html", 
	    &s, false, &result);
	wcout << L"size: " << s.size() << endl; 
	PRINT_RESULT(result);
	hclient->freeResult(result);

	// This should be a success, with progress messages
	hclient->addListener(&mylistener);
	res = hclient->url2file(
	    L"http://data.ecora.com/~keith/downloads/viewDoc.exe",
	    L"./viewDoc.exe", true, &result);
	PRINT_RESULT(result);
	hclient->freeResult(result);
	hclient->removeListener(&mylistener);

	// This should return a 404
	res = hclient->url2file(
	    L"http://data.ecora.com/~keith2/downloads/viewDoc.exe",
	    L"./viewDoc.exe", true, &result);
	PRINT_RESULT(result);
	hclient->freeResult(result);

	wstring setupUrl =
	    L"http://www.ecora.com/ecora/releases/windows/windows/"
	    L"core-2086_core-2-0-2220-14320_wns-2107_windows-2-1-2240-13364/"
	    L"EcoraWindowsSetup-2.1.2240.13364.exe";

	// This should return a 401
	res = hclient->url2file(setupUrl, L"./Setup.exe", true, &result);
	PRINT_RESULT(result);
	hclient->freeResult(result);

	// ... but this should work
	hclient->addLoginAgent(&agent);
	hclient->addListener(&mylistener);
	res = hclient->url2file(setupUrl, L"./Setup2.exe", true, &result);
	PRINT_RESULT(result);
	hclient->freeResult(result);

#endif // TEST_HTTP
#ifdef TEST_FTP

	wstring ftpurl = L"ftp://data.ecora.com/pub/petelist.txt";
	res = fclient->url2file(ftpurl, L"petelist.txt", false, &result);
	PRINT_RESULT(result);

	ftpurl = 
	    L"ftp://peg:timex;@data.ecora.com/public_html/faq/menu.html";
	res = fclient->url2file(ftpurl, L"menu.html", false, &result);
	PRINT_RESULT(result);

	// This should fail (invalid login)
	fclient->setCredentials(L"peg2", L"*****");
	ftpurl = L"ftp://data.ecora.com/public_html/faq/menu.html";
	res = fclient->url2file(ftpurl, L"menu.html", false, &result);
	PRINT_RESULT(result);

	// But this should work
	fclient->addListener(&mylistener);
	ftpurl = L"ftp://data.ecora.com/data/common.data";
	fclient->setCredentials(L"peg", L"timex;");
	res = fclient->url2file(ftpurl, L"common.data", false, &result);
	fclient->removeListener(&mylistener);
	PRINT_RESULT(result);

#endif // TEST_FTP
    }
    catch (GenericException& e)
    {
        wcerr << L"Failure: " << e.message() << endl;
    }
    return 0;
}

void
MyListener::downloadProgress(double amount, double total)
{
    int amt = (int)amount;
    int tot = (int)total;
    wcerr << L"[downloading: " << amt << L"/" << tot << L"]\n";
}

void
MyListener::uploadProgress(double amount, double total)
{
    // wcerr << L"[uploading: " << amount << L"/" << total << L"]\n";
}

bool
MyLoginAgent::login(Http* client, const wstring& url)
{
    if (url.find(L"ecora.com") == wstring::npos)
	return false;

    wstring loginUrl = 
	L"http://www.ecora.com/cgi-bin/ecora/2.0/go?go=login&"
	L"Login=kamg&Password=password";

    wstring content;
    bool res = client->url2wstring(loginUrl, &content, false, 0);
    if (res == true && content.find(L"nvalid") == wstring::npos)
    {
	wcout << L"Login successful.\n";
	return true;
    }
    else
    {
	wcout << L"Login failed.\n";
	return false;
    }
}
=====================================================================
Found a 126 line (627 tokens) duplication in the following files: 
Starting at line 41 of D:\home\eCora_PM\PM\agent\agent\apps\Setup\Win32\Msi\CustomActions\CustomActionsDLL\CustomActions.cpp
Starting at line 16 of D:\home\eCora_PM\PM\agent\agent\apps\Setup\Win32\Msi\CustomActions\UpgradeCheck\UpgradeCheck.cpp

BOOL APIENTRY DllMain(HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved)
{
    return TRUE;
}

CString 
readFromFile(FILE* fd)
{
    CString strConfig;
    fseek(fd, 0, SEEK_END);
    long fileSize = ftell(fd);
    fseek(fd, 0, SEEK_SET);

    char* data = new char[fileSize + 1];
    memset(data, 0, fileSize + 1);
    
    fread(data, 1, fileSize, fd);
    strConfig = data;
    delete data;
    return strConfig;
}

int 
compare2Versions(const CString& firstVersion, const CString& secondVersion)
{
    CString tempFirstVersion =  firstVersion;
    CString tempSecondVersion =  secondVersion;
    
    tempFirstVersion = tempFirstVersion.Trim();
    tempSecondVersion = tempSecondVersion.Trim();
    int curPosFirst = 0;
    int curPosSecond = 0;
    CString substrFirstVersion = tempFirstVersion.Tokenize(L".", curPosFirst);
    CString substrSecondVersion = tempSecondVersion.Tokenize(L".", curPosSecond);

    while (substrFirstVersion != L"" && substrSecondVersion != L"")
    {
        wchar_t* error;
        errno = 0;
        long firstNumber = wcstol(substrFirstVersion.GetString(), &error, 10);
        if (((errno == ERANGE) && ((firstNumber == LONG_MAX) || firstNumber == LONG_MIN)) || 
            (error == substrFirstVersion))
        {
            return -2;
        }

        errno = 0;
        long secondNumber = wcstol(substrSecondVersion.GetString(), &error, 10);
        if (((errno == ERANGE) && ((secondNumber == LONG_MAX) || secondNumber == LONG_MIN)) || 
            (error == substrSecondVersion))
        {
            return -3;
        }
        if (firstNumber > secondNumber)
        {
            return 1;
        }
        else
        {
            if (firstNumber < secondNumber)
            {
                return -1;
            }
        }
        substrFirstVersion = tempFirstVersion.Tokenize(L".", curPosFirst);
        substrSecondVersion = tempSecondVersion.Tokenize(L".", curPosSecond);


    }
    if (substrFirstVersion != L"")
    {
        return 1;
    }
    else
    {
        if (substrSecondVersion != L"")
        {
            return -1;
        }
    }
    return 0;
}

CString GetAttributeValue(const CString& strConfig, LPCTSTR szAttributeName)
{
    CString strValue;
    int nNum = strConfig.Find(szAttributeName);
    if (nNum > 0)
    {
        int nFirst = strConfig.Find(L'"', nNum) + 1;
        int nLast = strConfig.Find('"', nFirst + 1);
        if (nFirst > 0 && nLast > 0)
        {
            strValue = strConfig.Mid(nFirst, nLast - nFirst);
        }
    }
    return strValue;
}
void SetAttributeValue(CString& strConfig, LPCTSTR szAttributeName, const CString& value)
{
    CString strValue;
    int nNum = strConfig.Find(szAttributeName);
    if (nNum > 0)
    {
        int nFirst = strConfig.Find(L'"', nNum) + 1;
        int nLast = strConfig.Find('"', nFirst);
        if (nFirst > 0 && nLast > 0)
        {
            CString strTemp = strConfig.Left(nFirst);
            strTemp += value;
            strTemp += strConfig.Right(strConfig.GetLength() - nLast);
            strConfig = strTemp;
        }
    }
}

UINT ReportInstallError(MSIHANDLE hInstall, LPCTSTR  szErrorMessage, 
                        UINT nErrorCode = ERROR_INSTALL_USEREXIT)
{
    PMSIHANDLE hRecord = MsiCreateRecord(0);
    MsiRecordSetString(hRecord, 0, szErrorMessage);
    MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_ERROR + MB_OK), hRecord);
    return nErrorCode;
}
=====================================================================
Found a 144 line (624 tokens) duplication in the following files: 
Starting at line 35 of D:\home\eCora_PM\PM\network\ScpConnection.cpp
Starting at line 35 of D:\home\eCora_PM\PM\network\network\ScpConnection.cpp

namespace network {

ScpConnection::ScpConnection()
{
}

ScpConnection::~ScpConnection()
{
}        

void
ScpConnection::connect(const LoginParameters*const device)
{
    m_userAndHost = device->username() + L"@" + device->hostname();
    log(L"ScpConnection::connect", Log::Info, m_userAndHost);

    m_pw = device->password();
    m_client = device->clientDir() + L"pscp.exe";

    m_completionString = "pscp xfer done";
}

void
ScpConnection::put(const wstring& localFilename,
		   const wstring& remotePath)
{
    //  pscp -pw pw source user@host:target

    wstring logMessage = localFilename +
	L" " + m_userAndHost + L":" + remotePath;    
    log(L"ScpConnection::connect", Log::Info, logMessage);

    wstring unixLocal;

    for (size_t i = 0; i < localFilename.size(); ++i)
    {
        if (localFilename[i] == L'\\')
            unixLocal += L'/';
        else
            unixLocal += localFilename[i];
    }

    vector<wstring> arguments;
    arguments.push_back(L"-pw");
    arguments.push_back(m_pw);
    arguments.push_back(unixLocal);
    wstring remoteFilename = remotePath + L"/" + 
        returnFilename(unixLocal);
    wstring target = m_userAndHost + L":" + remoteFilename;
    arguments.push_back(target);
    
    try {
        m_host = new Smuggler(m_driver, m_client, arguments);
    }
    catch (...)
    {
        deleteHost();
        throw;
    }

    vector<bstring> errorPrompts;
    errorPrompts.push_back("Fatal:");
    errorPrompts.push_back("Command failed:");
    errorPrompts.push_back("Access denied");

    vector<bstring> successPrompts;
    successPrompts.push_back("Success:");

    bstring response = waitForTransfer(successPrompts, errorPrompts);
    deleteHost();

    if (response.find("Command failed:") != bstring::npos)
    {
        wstring errorMessage = L"File transfer timeout: " + logMessage +
            L" Host response: " + bstring2wstring(response);

        throw GenericException(__FILE__, __LINE__, L"ScpConnection::put", 
                                L"", errorMessage);
    }
    
}

void
ScpConnection::get(const wstring& remoteFilename,
		   const wstring& localPath)
{
    //  pscp -pw pw user@host:source target
    wstring logMessage = m_userAndHost + L":" + remoteFilename + L" " + 
                localPath;
    log(L"ScpConnection::connect", Log::Info, logMessage);
    
    vector<wstring> arguments;
    arguments.push_back(L"-pw");
    arguments.push_back(m_pw);
    wstring target = m_userAndHost + L":" + remoteFilename;
    arguments.push_back(target);

    wstring localFilename = localPath + L"/" + 
        returnFilename(remoteFilename);

    arguments.push_back(localFilename);    
    
    try {
        m_host = new Smuggler(m_driver, m_client, arguments);
    }
    catch (...)
    {
        deleteHost();
        throw;
    }

    vector<bstring> errorPrompts;
    errorPrompts.push_back("Fatal:");
    errorPrompts.push_back("Command failed:");
    errorPrompts.push_back("Access denied");

    vector<bstring> successPrompts;
    successPrompts.push_back("Success:");

    bstring response = waitForTransfer(successPrompts, errorPrompts);
    deleteHost();
    if (response.find("Command failed:") != bstring::npos)
    {
        wstring errorMessage = L"File transfer timeout: " + logMessage +
            L" Host response: " + bstring2wstring(response);

        throw GenericException(__FILE__, __LINE__, L"ScpConnection::get", 
                                L"", errorMessage);
    }
}


ScpConnection* 
establishScpConnection(const LoginParameters*const device)
{
    wstring logMessage = device->username() + L"@" + device->hostname();
    log(L"establishScpConnection", Log::Info, logMessage);
	
    ScpConnection* fC = new ScpConnection();
    fC->connect(device);
    return fC;
}

} // End namespace connections
=====================================================================
Found a 144 line (623 tokens) duplication in the following files: 
Starting at line 21 of D:\home\eCora_PM\PM\network\GeneralClient.cc
Starting at line 21 of D:\home\eCora_PM\PM\network\network\GeneralClient.cc

namespace network {

GeneralClient::GeneralClient(
    const wstring& cookies, const wstring& userAgentLocation, IUnknown* pUnkOuter)
    : m_comBase(pUnkOuter, false)
{
    m_http = new Http(cookies, userAgentLocation, this);
    m_ftp = new Ftp(this);
}

GeneralClient::~GeneralClient()
{
    delete m_http;
    delete m_ftp;
}

HRESULT
GeneralClient::QueryInterface(const GUID& iid, void** iface)
{
    IUnknown* outer = m_comBase.getUnkOuter();
    if (outer != 0)
	return outer->QueryInterface(iid, iface);
    else if (iid == IID_IUnknown)
    {
	*iface = (IUnknown*)this;
	AddRef();
	return NO_ERROR;
    }
    else if (iid == IID_INetwork)
    {
	*iface = (com::INetwork*)this;
	AddRef();
	return NO_ERROR;
    }
    else
    {
	*iface = 0;
	return E_NOINTERFACE;
    }
}

unsigned long
GeneralClient::AddRef()
{
    return m_comBase.addRef();
}

unsigned long
GeneralClient::Release()
{
    return m_comBase.release(this);
}

bool 
GeneralClient::url2wstring(
	const wstring& url, wstring* content, 
	bool runInThread, com::NetworkResult** result)
{
    if (url.find(L"http") == 0)
	return m_http->url2wstring(url, content, runInThread, result);
    else if (url.find(L"ftp") == 0)
	return m_ftp->url2wstring(url, content, runInThread, result);
    else
    {
	if (result != 0)
	    *result = new Result(Result::Error, L"Unsupported protocol");
	return false;
    }
}

bool 
GeneralClient::url2file(
	const wstring& url, const wstring& file, 
	bool runInThread, com::NetworkResult** result)
{
    if (url.find(L"http") == 0)
	return m_http->url2file(url, file, runInThread, result);
    else if (url.find(L"ftp") == 0)
	return m_ftp->url2file(url, file, runInThread, result);
    else
    {
	if (result != 0)
	    *result = new Result(Result::Error, L"Unsupported protocol");
	return false;
    }
}

void 
GeneralClient::useProxy(
	const wstring& addr, const wstring& login, const wstring& pass,
        const bool useNTLM)
{
    m_http->useProxy(addr, login, pass, useNTLM);
    m_ftp->useProxy(addr, login, pass, useNTLM);
}

void 
GeneralClient::setCredentials(const wstring& login, const wstring& pass)
{
    m_http->setCredentials(login, pass);
    m_ftp->setCredentials(login, pass);
}

void 
GeneralClient::addListener(com::NetworkListener* listener)
{
    m_http->addListener(listener);
    m_ftp->addListener(listener);
}

void 
GeneralClient::removeListener(com::NetworkListener* listener)
{
    m_http->removeListener(listener);
    m_ftp->removeListener(listener);
}

void 
GeneralClient::abort()
{
    m_http->abort();
    m_ftp->abort();
}

void 
GeneralClient::freeResult(com::NetworkResult* result) const
{
    delete result;
}

void 
GeneralClient::addLoginAgent(HttpLogin* login)
{
    m_http->addLoginAgent(login);
}

void 
GeneralClient::removeLoginAgent(HttpLogin* login)
{
    m_http->removeLoginAgent(login);
}


} // namespace network
=====================================================================
Found a 86 line (615 tokens) duplication in the following files: 
Starting at line 389 of D:\home\eCora_PM\PM\customPatch\ExportWizard.cpp
Starting at line 327 of D:\home\eCora_PM\PM\customPatch\ImportWizard.cpp

void ImportWizard::onValueChanged(int row, int col)
{
    if (row == -1 || col == -1)
        return;
    bool checked = ((QCheckTableItem*)m_table->item(row, 0))->isChecked();
    if (col != 0)
        return;
    if (m_table->horizontalHeader()->label(0) == tr("Application"))
    {
        QString appName = m_table->text(row, 0);
        CustomApplication* app = m_apps[appName];
        app->m_isSelected = checked;
        QString product = app->m_name;
        QCheckListItem* productNode = (QCheckListItem*)m_listTree->firstChild()->firstChild();
        while (productNode->text(0) != product)
        {
            productNode = (QCheckListItem*)productNode->nextSibling();
        }
        QCheckListItem* appNode = (QCheckListItem*)productNode->firstChild();
        while (appNode->text(0) != appName)
        {
            appNode = (QCheckListItem*)appNode->nextSibling();
        }
        unSelectChild(appNode, checked);
        unSelectApp(app, checked);
        //checkRoot();
        checkParents((QCheckListItem*)appNode->parent());
    }
    else if (m_table->horizontalHeader()->label(0) == tr("Product"))
    {
        QString product = m_table->text(row, 0);
        QCheckListItem* productNode = (QCheckListItem*)m_listTree->firstChild()->firstChild();
        while (productNode->text(0) != product)
        {
            productNode = (QCheckListItem*)productNode->nextSibling();
        }
        unSelectChild(productNode, checked);
        CustomApplication* app;
        map<QString, CustomApplication*>::iterator it = m_apps.begin();
        for (; it != m_apps.end(); ++it)
        {
            app = it->second;
            if (app->m_name == product)
            {
                unSelectApp(app, checked);
            }
        }
        checkParents((QCheckListItem*)productNode->parent());
    }
    else //if (m_table->horizontalHeader()->label(0) == tr("Patch"))
    {
        CustomApplication* app = m_apps.find(m_appName)->second;
        QString name = m_table->text(row, 0);
        app->m_patches.find(name)->second->m_isSelected = checked;
        QString product = app->m_name;
        QCheckListItem* productNode = (QCheckListItem*)m_listTree->firstChild()->firstChild();
        while (productNode->text(0) != product)
        {
            productNode = (QCheckListItem*)productNode->nextSibling();
        }
        QCheckListItem* appNode = (QCheckListItem*)productNode->firstChild();
        while (appNode->text(0) != m_appName)
        {
            appNode = (QCheckListItem*)appNode->nextSibling();
        }
        QCheckListItem* child = (QCheckListItem*)appNode->firstChild();
        while (child->text(0) != name)
        {
            child = (QCheckListItem*)child->nextSibling();
        }
        child->setOn(checked);
        //m_currentPatch = app->m_patches[name];
        //checkApp(appNode, app);
        map<QString, CustomPatch*>::iterator it = app->m_patches.begin();
        bool allChecked = true;
        while (allChecked && it != app->m_patches.end())
        {
            allChecked = it->second->m_isSelected;
            it++;
        }
        app->m_isSelected = allChecked;
        checkParents(appNode);
    }
}

void ImportWizard::unSelectApp(CustomApplication* app, bool checked)
=====================================================================
Found a 136 line (589 tokens) duplication in the following files: 
Starting at line 37 of D:\home\eCora_PM\PM\network\FtpConnection.cpp
Starting at line 37 of D:\home\eCora_PM\PM\network\network\FtpConnection.cpp

namespace network {

FtpConnection::FtpConnection()
{
}

FtpConnection::~FtpConnection()
{
}        

void
FtpConnection::connect(const LoginParameters*const device)
{
    wstring userAndHost = device->username() + L"@" + device->hostname();
    log(L"FtpConnection::connect", Log::Info, userAndHost);

    m_hostname = device->hostname();
    m_user = device->username();
    m_pw = device->password();
    m_clientDir = device->clientDir();

    m_completionString = "ncftp xfer done";
}

       
void
FtpConnection::put(const wstring& localFilename,
		   const wstring& remotePath)
{
    //  ncftpput -u user -p pw host remoteFilename localFilename
    wstring logMessage = localFilename + L" " + m_user + L"@" + m_hostname +
	L":" + remotePath;    
    log(L"FtpConnection::put", Log::Info, logMessage);

    vector<wstring> arguments;
    arguments.push_back(L"-u");
    arguments.push_back(m_user);
    arguments.push_back(L"-p");
    arguments.push_back(m_pw);
    arguments.push_back(m_hostname);
    arguments.push_back(remotePath);
    arguments.push_back(localFilename);

    wstring connectionMethod = m_clientDir + L"ncftpput.exe";
  
    try {
        m_host = new Smuggler(m_driver, connectionMethod, arguments);
    }
    catch (...)
    {
        deleteHost();
        throw;
    }

    vector<bstring> errorPrompts;
    errorPrompts.push_back("ncftp failure:");

    vector<bstring> successPrompts;
    successPrompts.push_back(m_completionString);

    bstring response = waitForTransfer(successPrompts, errorPrompts);
    deleteHost();

    if (response.find("Command failed:") != bstring::npos)
    {
        wstring errorMessage = L"File transfer failed: " + logMessage +
            L"\n Host response: " + bstring2wstring(response);

        throw GenericException(__FILE__, __LINE__, L"FtpConnection::put", 
                                L"", errorMessage);
    }

}


void
FtpConnection::get(const wstring& remoteFilename,
		   const wstring& localPath)
{
    //  ncftpput -u user -p pw host localFilename remoteFilename
    wstring logMessage = localPath + L" " + m_user + L"@" + m_hostname +
	L":" + remoteFilename; 
    log(L"FtpConnection::get", Log::Info, logMessage);

    vector<wstring> arguments;
    arguments.push_back(L"-u");
    arguments.push_back(m_user);
    arguments.push_back(L"-p");
    arguments.push_back(m_pw);
    arguments.push_back(m_hostname);
    arguments.push_back(localPath);
    arguments.push_back(remoteFilename);

    wstring connectionMethod = m_clientDir + L"/ncftpget.exe";
    
    try {
        m_host = new Smuggler(m_driver, connectionMethod, arguments);
    }
    catch (...)
    {
        deleteHost();
        throw;
    }
    
    vector<bstring> errorPrompts;
    errorPrompts.push_back("ncftp failure:");

    vector<bstring> successPrompts;
    successPrompts.push_back(m_completionString);

    bstring response = waitForTransfer(successPrompts, errorPrompts);
    deleteHost(); 

    if (response.find("Command failed:") != bstring::npos)
    {
        wstring errorMessage = L"File transfer failed: " + logMessage +
            L" Host response: " + bstring2wstring(response);

        throw GenericException(__FILE__, __LINE__, L"FtpConnection::get", 
                                L"", errorMessage);
    }
}


FtpConnection* 
establishFtpConnection(const LoginParameters*const device)
{
    wstring logMessage = device->username() + L"@" + device->hostname();
    log(L"establishFtpConnection", Log::Info, logMessage);
	
    FtpConnection* fC = new FtpConnection();
    fC->connect(device);
    return fC;
}

} // End namespace connections
=====================================================================
Found a 147 line (551 tokens) duplication in the following files: 
Starting at line 17 of D:\home\eCora_PM\PM\network\CurlHttpTestInterpreter.h
Starting at line 17 of D:\home\eCora_PM\PM\network\network\CurlHttpTestInterpreter.h

using namespace std;

namespace network {

class CurlTestDescriptor
{
  public:
    CurlTestDescriptor(int testNumber, const wstring& testDescription) :
        m_testNumber(testNumber),
        m_testDescription(testDescription),
        m_passFail(false),
        m_errorMessage(L"NoMessage")
    {}

        //  Build an error message based on test number, description
        //  pass/fail and errorMessage:
        //  ex:  Test # (testDescription) passed/failed.
        //       Error Message on failure.
    wstring failureMessage()  { return (L"Test " + int2wstring(m_testNumber) +
            L" (" + m_testDescription + L") " + passFail() + L" : " +
            m_errorMessage); }

    wstring passFail()
    {
        if (m_passFail)
            return (L"Passed");
        else
            return (L"Failed");
    }

    wstring getUrl() { return m_url; }
    void setUrl(wstring url) { m_url = url; }

    wstring getUsername() { return m_username; }
    void setUsername(wstring username) { m_username = username; }

    wstring getPassword() { return m_password; }
    void setPassword(wstring password) { m_password = password; }

    //  Use cookies or agent...
    wstring getCookies() { return m_cookies; }
    void setCookies(wstring cookies) { m_cookies = cookies; }

    wstring getUserAgentLocation() { return m_userAgentLocation; }
    void setUserAgentLocation(wstring userAgentLocation)
        { m_userAgentLocation = userAgentLocation; }

    //  Proxy address, username, password and whether to use NTLM
    //  authentication...
    wstring getProxyAddress() { return m_proxyAddress; }
    void setProxyAddress(wstring proxyAddress) { m_proxyAddress = proxyAddress; }

    wstring getProxyAuthentication() { return m_proxyAuthentication; }
    void setProxyAuthentication(wstring proxyAuthentication)
        { m_proxyAuthentication = proxyAuthentication; }

    wstring getProxyUsername() { return m_proxyUsername; }
    void setProxyUsername(wstring proxyUsername)
        { m_proxyUsername = proxyUsername; }

    wstring getProxyPassword() { return m_proxyPassword; }
    void setProxyPassword(wstring proxyPassword)
        { m_proxyPassword = proxyPassword; }

    //  Possible timeout values... Connection timeout and overall
    //  operation timeout
    wstring getConnectionTimeout() { return m_connectionTimeout; }
    void setConnectionTimeout(wstring connectionTimeout)
        { m_connectionTimeout = connectionTimeout; }

    wstring getOperationTimeout() { return m_operationTimeout; }
    void setOperationTimeout(wstring operationTimeout)
        { m_operationTimeout = operationTimeout; }

    //  Test parameters...
    wstring getCompareAgainst() { return m_compareAgainst; }
    void setCompareAgainst(wstring compareAgainst)
        { m_compareAgainst = compareAgainst; }

    int getTestNumber() { return m_testNumber; }
    void setTestNumber(int testNumber) { m_testNumber = testNumber; }

    wstring getTestDescription() { return m_testDescription; }
    void setTestDescription(wstring testDescription)
        { m_testDescription = testDescription; }

    bool getPassFail() { return m_passFail; }
    void setPassFail(bool passFail) { m_passFail = passFail; }

    wstring getErrorMessage() { return m_errorMessage; }
    void setErrorMessage(wstring errorMessage) { m_errorMessage = errorMessage; }

  private:
    int m_testNumber;
    wstring m_testDescription;
    bool m_passFail;
    wstring m_errorMessage;

    //  Url and a login (if necessary)
    wstring m_url;
    wstring m_username;
    wstring m_password;

    //  Cookies and/or agent location (where to find the agent text)...
    wstring m_cookies;
    wstring m_userAgentLocation;

    //  Proxy address, username, password and whether to use NTLM
    //  authentication...
    wstring m_proxyAddress;
    wstring m_proxyAuthentication;

    wstring m_proxyUsername;
    wstring m_proxyPassword;

    //  Possible timeout values... Connection timeout and overall
    //  operation timeout
    wstring m_connectionTimeout;
    wstring m_operationTimeout;

    //  Test parameters...
    wstring m_compareAgainst;


};

class CurlHttpTestInterpreter
{
  public:
      CurlHttpTestInterpreter() {}
      ~CurlHttpTestInterpreter();

    //  Read the CurlTestDriver.xml file and try to read each url described.
    //  For each of these urls' create an httpTestDescriptor and store the
    //  pointer to it in the vector m_httpTestDescriptors.
    void run();
    void runTest(xml::Node* test);
    void compareResultsToFile(const wstring& results, const wstring& file);
    vector<CurlTestDescriptor*> m_httpTestDescriptors;

  private:
    xml::Document* m_testDocument;
    xml::Node* m_testNode;

};

}  // End namespace network
=====================================================================
Found a 113 line (477 tokens) duplication in the following files: 
Starting at line 22 of D:\home\eCora_PM\PM\pmServices\pmServiceTester\CommandLine.cpp
Starting at line 22 of D:\home\eCora_PM\PM\pmWindowsService\CommandLine.cpp

CommandLine::CommandLine(int argc, char* argv[]) : m_argc(argc), m_argv(argv), m_mode(MODE_GUI)
{
    processCommandLine();
}

void
CommandLine::processCommandLine()
{
    vector<wstring> cmdLineArgs;
    parseCmdLine(&cmdLineArgs, GetCommandLine());

    int argc = cmdLineArgs.size();
    wchar_t** argv = new wchar_t*[argc];
    for (int i = 0 ; i < argc; ++i)
    {
        wstring arg = cmdLineArgs[i];
        if (!i)
        {
            arg = wstring2vector(wstring2vector(arg, L"\\").back(), L".").front();
        }

        argv[i] = new wchar_t[arg.size() + 1];
        wcscpy(argv[i], arg.c_str());
    }

    setupOptions(argc, argv);

    for (int j = 0 ; j < argc; ++j)
    {
        delete[] argv[j];
    }
    delete[] argv;
}

void
CommandLine::parseCmdLine(vector<wstring>* words, const wstring& line)
{
    wstring word(L"");
    bool startWord = false;
    bool startQuote = false;

    wstring::const_iterator chIt = line.begin();
    for (; chIt != line.end(); ++chIt)
    {
        wchar_t c = *chIt;
        if (c == L'\"')
        {
            if (startWord)
            {
                startWord = false;
                words->push_back(word);
                word.erase();
            }
            else
            {
                startWord = true;
            }

            startQuote = !startQuote;

            continue;
        }

        if (c != L' ' && c != L'\t')
        {
            if (!startWord)
            {
                startWord = true;
            }
            word.append(1, c);
        }
        else
        {
            if (startQuote)
            {
                word.append(1, c);
            }
            else
            {
                if (startWord)
                {
                    startWord = false;
                    words->push_back(word);
                    word.erase();
                }
            }
        }
    }

    if (startQuote)
    {
        wstring errorMsg(L"Parsing error: double quotes not closed ! [");
        errorMsg.append(line).append(L"]");
        throw GenericException(
            __FILE__, __LINE__, L"CommandLine::parseCmdLine", L"", errorMsg);
    }

    if (startWord)
    {
        words->push_back(word);
    }
}

void
CommandLine::setupOptions(int argc, wchar_t** argv)
{
    assert(argc);
    assert(argv);

    WGetopt options(argc, argv);
    wstring logSpec;

    wchar_t c;
=====================================================================
Found a 118 line (471 tokens) duplication in the following files: 
Starting at line 23 of D:\home\eCora_PM\PM\winAnalyzer\CommandLine.cpp
Starting at line 24 of D:\home\eCora_PM\PM\winTransferFiles\CommandLine.cpp

m_upgradePI(false), m_outputEnabled(false)
{

    processCommandLine();
}

void
CommandLine::processCommandLine()
{
    vector<wstring> cmdLineArgs;

    wstring line((wchar_t*)GetCommandLine()); // !!!!!!!!

    parseCmdLine(&cmdLineArgs, line);

    int argc = cmdLineArgs.size();
    wchar_t** argv = new wchar_t*[argc];
    for (int i = 0 ; i < argc; ++i)
    {
        wstring arg = cmdLineArgs[i];
        if (!i)
        {
            arg = wstring2vector(wstring2vector(arg, L"\\").back(), L".").front();
        }

        argv[i] = new wchar_t[arg.size() + 1];
        wcscpy(argv[i], arg.c_str());
    }

    setupOptions(argc, argv);

    for (int j = 0 ; j < argc; ++j)
    {
        delete[] argv[j];
    }
    delete[] argv;
}

void
CommandLine::parseCmdLine(vector<wstring>* words, const wstring& line)
{
    wstring word(L"");
    bool startWord = false;
    bool startQuote = false;

    wstring::const_iterator chIt = line.begin();
    for (; chIt != line.end(); ++chIt)
    {
        wchar_t c = *chIt;
        if (c == L'\"')
        {
            if (startWord)
            {
                startWord = false;
                words->push_back(word);
                word.erase();
            }
            else
            {
                startWord = true;
            }

            startQuote = !startQuote;

            continue;
        }

        if (c != L' ' && c != L'\t')
        {
            if (!startWord)
            {
                startWord = true;
            }
            word.append(1, c);
        }
        else
        {
            if (startQuote)
            {
                word.append(1, c);
            }
            else
            {
                if (startWord)
                {
                    startWord = false;
                    words->push_back(word);
                    word.erase();
                }
            }
        }
    }

    if (startQuote)
    {
        wstring errorMsg(L"Parsing error: double quotes not closed ! [");
        errorMsg.append(line).append(L"]");
        throw GenericException(
            __FILE__, __LINE__, L"CommandLine::parseCmdLine", L"", errorMsg);
    }

    if (startWord)
    {
        words->push_back(word);
    }
}

void
CommandLine::setupOptions(int argc, wchar_t** argv)
{
    assert(argc);
    assert(argv);

    WGetopt options(argc, argv);
    wstring logSpec;

    wchar_t c;
    while ((c = options.next(L"l:h:p:k:")) != WEOF)
=====================================================================
Found a 72 line (462 tokens) duplication in the following files: 
Starting at line 1307 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 2029 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp

    log(L"patchRepository", Log::Debug, L"Enter WinSolRepoSettings::determineUNCPath");
    wstring uncPath = path;

    try
    {
        auto_ptr<CRegConnectRegistry> pRemoteKey;
        pRemoteKey = auto_ptr<CRegConnectRegistry>(
            new CRegConnectRegistry(L"", HKEY_LOCAL_MACHINE));

        if (0 == pRemoteKey.get() || 0 == pRemoteKey->GetHKEY())
        {
            log(L"patchRepository", Log::Error,
            L"Error trying to convert local path to UNC: Unable to connect to registry");
            return path;
        }

        HKEY hkeyRemote = pRemoteKey->GetHKEY();

        wstring sKey;
        sKey = _T("SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Shares");

        KeyValues kv(hkeyRemote, sKey.c_str());
        kv.Read();

        map<tstring, KeyData>::iterator it;
        for (it = kv.begin(); it != kv.end(); it++)
        {
            wstring shareName = it->first;
            BYTE value[2048];
            DWORD len = 2048;

                HKEY openKeyMatch;
            if (RegOpenKeyEx(hkeyRemote, sKey.c_str(),
                       0, KEY_ALL_ACCESS, &openKeyMatch) != ERROR_SUCCESS)
            continue;

            if (RegQueryValueEx(openKeyMatch, shareName.c_str(), 0, 0, value, &len) == ERROR_SUCCESS)
            {
                log(L"patchRepository", Log::Debug, L"Found share " << shareName);
                // the value returned from registry has multiple strings separated by "\0"
                wstring shareValue = wstring((LPWSTR)value);
                while (shareValue.size() < len / 2 - 2)
                    shareValue += L" " + wstring((LPWSTR)&value[(shareValue.size() + 1) * 2]);
                log(L"patchRepository", Log::Debug, L"Share value " << shareValue);

                wstring sharePath = shareValue.substr(shareValue.find(L"Path=") + 5);
                sharePath = sharePath.substr(0, sharePath.find(L"Permissions=") - 1);
                log(L"patchRepository", Log::Debug, L"Share path " << sharePath);

                // now we've got the local path for the share, see if it's part of the path the user chose
                if (_wcsicmp(sharePath.c_str(), path.substr(0, sharePath.size()).c_str()) == 0)
                {
                    uncPath = L"\\\\" + getHostName() + L"\\" + shareName;
                    if (path.size() > sharePath.size())
                    uncPath += path.substr(sharePath.size());

                    log(L"patchRepository", Log::Debug,
                    L"Exit WinSolRepoSettings::determineUNCPath - path converted " << uncPath);
                    RegCloseKey(openKeyMatch);
                    return uncPath;
                }
            }
            RegCloseKey(openKeyMatch);
        }
    }
    catch (GenericException& e)
    {
        log(L"patchRepository", Log::Error,
        L"Error trying to convert local path to UNC: "  << e.userMessage());
    }

    log(L"patchRepository", Log::Debug,
=====================================================================
Found a 111 line (453 tokens) duplication in the following files: 
Starting at line 24 of D:\home\eCora_PM\PM\patchManager\CommandLine.cpp
Starting at line 25 of D:\home\eCora_PM\PM\pmServices\pmServiceTester\CommandLine.cpp

}

void
CommandLine::processCommandLine()
{
    vector<wstring> cmdLineArgs;
    parseCmdLine(&cmdLineArgs, GetCommandLine());

    int argc = cmdLineArgs.size();
    wchar_t** argv = new wchar_t*[argc];
    for (int i = 0 ; i < argc; ++i)
    {
        wstring arg = cmdLineArgs[i];
        if (!i)
        {
            arg = wstring2vector(wstring2vector(arg, L"\\").back(), L".").front();
        }

        argv[i] = new wchar_t[arg.size() + 1];
        wcscpy(argv[i], arg.c_str());
    }

    setupOptions(argc, argv);

    for (int j = 0 ; j < argc; ++j)
    {
        delete[] argv[j];
    }
    delete[] argv;
}

void
CommandLine::parseCmdLine(vector<wstring>* words, const wstring& line)
{
    wstring word(L"");
    bool startWord = false;
    bool startQuote = false;

    wstring::const_iterator chIt = line.begin();
    for (; chIt != line.end(); ++chIt)
    {
        wchar_t c = *chIt;
        if (c == L'\"')
        {
            if (startWord)
            {
                startWord = false;
                words->push_back(word);
                word.erase();
            }
            else
            {
                startWord = true;
            }

            startQuote = !startQuote;

            continue;
        }

        if (c != L' ' && c != L'\t')
        {
            if (!startWord)
            {
                startWord = true;
            }
            word.append(1, c);
        }
        else
        {
            if (startQuote)
            {
                word.append(1, c);
            }
            else
            {
                if (startWord)
                {
                    startWord = false;
                    words->push_back(word);
                    word.erase();
                }
            }
        }
    }

    if (startQuote)
    {
        wstring errorMsg(L"Parsing error: double quotes not closed ! [");
        errorMsg.append(line).append(L"]");
        throw GenericException(
            __FILE__, __LINE__, L"CommandLine::parseCmdLine", L"", errorMsg);
    }

    if (startWord)
    {
        words->push_back(word);
    }
}

void
CommandLine::setupOptions(int argc, wchar_t** argv)
{
    assert(argc);
    assert(argv);

    WGetopt options(argc, argv);
    wstring logSpec;

    wchar_t c;
    while ((c = options.next(L"z:h:u:b:d:s:")) != WEOF)
=====================================================================
Found a 110 line (444 tokens) duplication in the following files: 
Starting at line 24 of D:\home\eCora_PM\PM\patchManager\CommandLine.cpp
Starting at line 25 of D:\home\eCora_PM\PM\pmWindowsService\CommandLine.cpp

}

void
CommandLine::processCommandLine()
{
    vector<wstring> cmdLineArgs;
    parseCmdLine(&cmdLineArgs, GetCommandLine());

    int argc = cmdLineArgs.size();
    wchar_t** argv = new wchar_t*[argc];
    for (int i = 0 ; i < argc; ++i)
    {
        wstring arg = cmdLineArgs[i];
        if (!i)
        {
            arg = wstring2vector(wstring2vector(arg, L"\\").back(), L".").front();
        }

        argv[i] = new wchar_t[arg.size() + 1];
        wcscpy(argv[i], arg.c_str());
    }

    setupOptions(argc, argv);

    for (int j = 0 ; j < argc; ++j)
    {
        delete[] argv[j];
    }
    delete[] argv;
}

void
CommandLine::parseCmdLine(vector<wstring>* words, const wstring& line)
{
    wstring word(L"");
    bool startWord = false;
    bool startQuote = false;

    wstring::const_iterator chIt = line.begin();
    for (; chIt != line.end(); ++chIt)
    {
        wchar_t c = *chIt;
        if (c == L'\"')
        {
            if (startWord)
            {
                startWord = false;
                words->push_back(word);
                word.erase();
            }
            else
            {
                startWord = true;
            }

            startQuote = !startQuote;

            continue;
        }

        if (c != L' ' && c != L'\t')
        {
            if (!startWord)
            {
                startWord = true;
            }
            word.append(1, c);
        }
        else
        {
            if (startQuote)
            {
                word.append(1, c);
            }
            else
            {
                if (startWord)
                {
                    startWord = false;
                    words->push_back(word);
                    word.erase();
                }
            }
        }
    }

    if (startQuote)
    {
        wstring errorMsg(L"Parsing error: double quotes not closed ! [");
        errorMsg.append(line).append(L"]");
        throw GenericException(
            __FILE__, __LINE__, L"CommandLine::parseCmdLine", L"", errorMsg);
    }

    if (startWord)
    {
        words->push_back(word);
    }
}

void
CommandLine::setupOptions(int argc, wchar_t** argv)
{
    assert(argc);
    assert(argv);

    WGetopt options(argc, argv);
    wstring logSpec;

    wchar_t c;
=====================================================================
Found a 111 line (442 tokens) duplication in the following files: 
Starting at line 133 of D:\home\eCora_PM\PM\agentInstaller\main.cpp
Starting at line 229 of D:\home\eCora_PM\PM\pushInstaller_main\main.cpp

            log->open(logFilePath); // current directory

#else
        wstring file, ext, dir, input;
        input = logFilePrefix;  // Get around const-ness
        parseLogFilePrefix(input, dir, file, ext);
        LogObject* log = new LogObject(file, ext);
        log->open(dir); // current directory
#endif
        Log::initialize(log);
        log->setProgramName(L"EcoraPatchManager");
        return true;
    }
    catch (...)
    {
        return false;
    }
}
int
getopts(int argc, char* argv[], char* optstring)
{

    static char* next = 0;

    if (optind == 0)
        next = 0;

    optarg = 0;

    if (next == 0 || *next == '\0')
    {
        if (optind == 0)
            optind++;
        if (optind >= argc || argv[optind][0] != '-'
              || argv[optind][1] == '\0')
        {
            optarg = 0;
            if (optind < argc)
                optarg = argv[optind];
            return EOF;
        }

        if (strcmp(argv[optind], "--") == 0)
        {
            optind++;
            optarg = 0;
            if (optind < argc)
                optarg = argv[optind];
            return EOF;
        }

        next = argv[optind] + 1;
        optind++;
    }

    char c = *next++;
    char* cp = strchr(optstring, c);

    if (cp == 0 || c == ':')
        return '?';
    cp++;
    if (*cp == ':')
    {
        if (*next != '\0')
        {
            optarg = next;
            next = 0;
        }
        else if (optind < argc)
        {
            optarg = argv[optind];
            optind++;
        }
        else
        {
            return '?';
        }
    }
    return c;

}

/**
 * The incoming string may be UNIX path format.
 */
void
parseLogFilePrefix(wstring& logFilePrefix, wstring& dir, wstring& file, wstring& ext)
{
    dir = L"";
    file = L"";
    ext = L"";

    int n = logFilePrefix.rfind(L"/");

    if (n != wstring::npos) // We have a path
    {
        dir = logFilePrefix.substr(0, n); // No trailing slash
    }
    else
    {
        dir = L"./";
    }

    file = logFilePrefix.substr(n + 1);

    if ((n = file.find(L".")) != wstring::npos)
    {
        ext = file.substr(n);
        file = file.substr(0, n);
    }
}
=====================================================================
Found a 69 line (432 tokens) duplication in the following files: 
Starting at line 1009 of D:\home\eCora_PM\PM\pmAgentManagement\OptionalAgentDeployWizard.cpp
Starting at line 628 of D:\home\eCora_PM\PM\pmAgentManagement\OptionalAgentUninstallWizard.cpp

        if (m_sysKeys.size())
        {
            // Note we have the unique key in the query. We need it later.
            // We need the
            QString selectStr = "SELECT DeviceName, Agent, DomainName, IpAddress, UniqueKey, "
                "UserName, Password "
                "FROM WindowsSystem WHERE UniqueKey =  '%1' ";
            QString orClause = " OR UniqueKey = '%1' ";

            QString queryStr = selectStr.arg(ws2qs(m_sysKeys[0]));
            for (int i = 1; i < m_sysKeys.size(); ++i)
            {
                queryStr = queryStr + orClause.arg(ws2qs(m_sysKeys[i]));
            }

            QSqlQuery q = m_db->exec(qs2ws(queryStr));

            while (q.next())
            {
                // Build up a vector of ScanSettings for use in communication with the threads.
                wstring systemName = qs2ws(q.value(0).asString());
                wstring domainName = qs2ws(q.value(2).asString());
                wstring ipAddress = qs2ws(q.value(3).asString());
                wstring systemId = qs2ws(q.value(4).asString());
                wstring userName = qs2ws(q.value(5).asString());
                wstring passwd = qs2ws(q.value(6).asString());
                passwd = pmServices::Utils::decrypt(passwd);

                // BUG FIX #16891 by Yuri Kovalenko ->
                CComPtr<com::IDbContainer> pDbContainer;
                HRESULT hr = m_pDatabase->getDbContainer(&pDbContainer);
                _IfFailHrRet(hr);

                hr = pDbContainer->registerObjectType(&idb::WindowsDevice());
                _IfFailHrRet(hr);

                idb::WindowsDevice device(m_app);
                device.setFieldValue(idb::WindowsDevice::DeviceName, ws2qs(systemName));
                device.setFieldValue(idb::WindowsDevice::DomainName, ws2qs(domainName));
                device.setFieldValue(idb::WindowsDevice::UserName, ws2qs(userName));
                hr = pDbContainer->retrieveObject(&device);
                if (FAILED(hr))
                {
                    log(L"pmAgentManagement", Log::Error, L"OptionalAgentDeployWizard::selectSystemsQuery"
                        << L" - unable to retrieveObject");
                    return;
                }
                QString qsPassword;
                hr = device.getFieldValue(idb::WindowsDevice::Password, qsPassword);
                if (S_OK == hr)
                {
                    passwd = qs2ws(qsPassword);
                }
                // BUG FIX #16891 by Yuri Kovalenko <-

                QString installStatus = "";
                if (m_agentManager->hasAgent(systemId))
                {
                    if (userName.empty())
                    {
                        installStatus = QObject::tr("Invalid");
                    }
                    else
                    {
                        installStatus = QObject::tr("Installed");
                    }
                }
                else
                    installStatus = QObject::tr("Not Installed");
=====================================================================
Found a 106 line (431 tokens) duplication in the following files: 
Starting at line 30 of D:\home\eCora_PM\PM\patchManager\CommandLine.cpp
Starting at line 32 of D:\home\eCora_PM\PM\pmOAService\CommandLine.cpp
Starting at line 35 of D:\home\eCora_PM\PM\winAnalyzer\CommandLine.cpp

    parseCmdLine(&cmdLineArgs, line);

    int argc = cmdLineArgs.size();
    wchar_t** argv = new wchar_t*[argc];
    for (int i = 0 ; i < argc; ++i)
    {
        wstring arg = cmdLineArgs[i];
        if (!i)
        {
            arg = wstring2vector(wstring2vector(arg, L"\\").back(), L".").front();
        }

        argv[i] = new wchar_t[arg.size() + 1];
        wcscpy(argv[i], arg.c_str());
    }

    setupOptions(argc, argv);

    for (int j = 0 ; j < argc; ++j)
    {
        delete[] argv[j];
    }
    delete[] argv;
}

void
CommandLine::parseCmdLine(vector<wstring>* words, const wstring& line)
{
    wstring word(L"");
    bool startWord = false;
    bool startQuote = false;

    wstring::const_iterator chIt = line.begin();
    for (; chIt != line.end(); ++chIt)
    {
        wchar_t c = *chIt;
        if (c == L'\"')
        {
            if (startWord)
            {
                startWord = false;
                words->push_back(word);
                word.erase();
            }
            else
            {
                startWord = true;
            }

            startQuote = !startQuote;

            continue;
        }

        if (c != L' ' && c != L'\t')
        {
            if (!startWord)
            {
                startWord = true;
            }
            word.append(1, c);
        }
        else
        {
            if (startQuote)
            {
                word.append(1, c);
            }
            else
            {
                if (startWord)
                {
                    startWord = false;
                    words->push_back(word);
                    word.erase();
                }
            }
        }
    }

    if (startQuote)
    {
        wstring errorMsg(L"Parsing error: double quotes not closed ! [");
        errorMsg.append(line).append(L"]");
        throw GenericException(
            __FILE__, __LINE__, L"CommandLine::parseCmdLine", L"", errorMsg);
    }

    if (startWord)
    {
        words->push_back(word);
    }
}

void
CommandLine::setupOptions(int argc, wchar_t** argv)
{
    assert(argc);
    assert(argv);

    WGetopt options(argc, argv);
    wstring logSpec;

    wchar_t c;
    //Sersok fix 21060
    while ((c = options.next(L"t:h:s:d:m:i:p:c:")) != WEOF)
=====================================================================
Found a 59 line (430 tokens) duplication in the following files: 
Starting at line 109 of D:\home\eCora_PM\PM\print\HTML.h
Starting at line 97 of D:\home\eCora_PM\PM\print\LaTeX.h

    virtual ecwofstream& registered();
    virtual ecwofstream& trademark();
    virtual ecwofstream& servicemark();
    virtual ecwofstream& copyright();

    virtual ecwofstream& bold();
    virtual ecwofstream& end_bold();
    virtual ecwofstream& italic();
    virtual ecwofstream& end_italic();
    virtual ecwofstream& underline();
    virtual ecwofstream& end_underline();
    virtual ecwofstream& verbatim();
    virtual ecwofstream& end_verbatim();
    virtual ecwofstream& fixed();
    virtual ecwofstream& end_fixed();
    virtual ecwofstream& center();
    virtual ecwofstream& end_center();
    virtual ecwofstream& quote();
    virtual ecwofstream& end_quote();
    virtual ecwofstream& paragraph();
    virtual ecwofstream& end_paragraph();
    virtual ecwofstream& note(bool indent = false);
    virtual ecwofstream& end_note(bool indent = false);
    virtual ecwofstream& xref();
    virtual ecwofstream& end_xref();
    virtual ecwofstream& errorValue();
    virtual ecwofstream& defaultValue();
    virtual ecwofstream& unknownValue();
    virtual ecwofstream& end_errorValue();
    virtual ecwofstream& end_defaultValue();
    virtual ecwofstream& end_unknownValue();
    virtual ecwofstream& hint(bool indent = false);
    virtual ecwofstream& end_hint(bool indent = false);
    virtual ecwofstream& warning(bool indent = false);
    virtual ecwofstream& end_warning(bool indent = false);
    virtual ecwofstream& url(const URL& url);
    virtual ecwofstream& end_url();
    virtual ecwofstream& color(const Color& color);
    virtual ecwofstream& end_color();
    virtual ecwofstream& image(const Image& image);
    virtual ecwofstream& table(const Table& table);
    virtual ecwofstream& row();
    virtual ecwofstream& column();
    virtual ecwofstream& end_column();
    virtual ecwofstream& end_row();
    virtual ecwofstream& end_table();
    virtual ecwofstream& blist();
    virtual ecwofstream& item();
    virtual ecwofstream& end_item();
    virtual ecwofstream& end_blist();
    // End Bug #2383

    virtual void chapter(const Chapter& chapter);
    virtual void section(const Section& section);
    virtual void subsection(const SubSection& subsection);
    virtual void subsubsection(const SubSubSection& subsubsection);

    virtual void unnumbered_chapter(
	const UnnumberedChapter& uChapter);
=====================================================================
Found a 109 line (425 tokens) duplication in the following files: 
Starting at line 39 of D:\home\eCora_PM\PM\network\FileTransferConnection.cpp
Starting at line 39 of D:\home\eCora_PM\PM\network\network\FileTransferConnection.cpp

using namespace smuggle;

namespace network {    
    
FileTransferConnection* 
makeFileTransferConnection(const LoginParameters*const device)
{
    if (device->getProtocol() == scp)
    {
	return establishScpConnection(device);
    }
    else if (device->getProtocol() == ftp)
    {
	return establishFtpConnection(device);
    }
    else if (device->getProtocol() == sftp)
    {
	return establishSftpConnection(device);
    }
    else
    {
	wstring message = L"Terminal protocol is not supported" +
	    device->getProtocol();
	
        throw GenericException(__FILE__, __LINE__, L"UnixStorage", 
                                L"", message);
    }
}

FileTransferConnection::FileTransferConnection()
{
}

FileTransferConnection::~FileTransferConnection()
{
}

bstring
FileTransferConnection::waitForTransfer(
                                const vector<bstring>const successMessages,
				const vector<bstring>const errorMessages)
{
    m_host->setTimeout(240);
    
    vector<pair<bstring, int> > possible;
    for (size_t i = 0; i < successMessages.size(); ++i)
    {
	possible.push_back(pair<bstring, int>(successMessages[i], 
            TRANSFER_COMPLETE));
    }	   
    
    for (size_t j = 0; j < errorMessages.size(); ++j)
    {
	possible.push_back(pair<bstring, int>(errorMessages[j], FAILURE));
    }	       

    bstring returnMessage = "";

    try
    {	
        int hostReturn = m_host->match(possible);
        if (hostReturn == TRANSFER_COMPLETE)
        {
	    returnMessage = m_host->data();
	}
	else if (hostReturn == FAILURE)
	{
	    //  HERE WE NEED TO GET DATA AND RETURN ALL WE KNOW.
            returnMessage = "Command failed: Host returned: " + 
                m_host->data();

	    log(L"FileTransferConnection::waitForTransfer", Log::Debug, 
                bstring2wstring(returnMessage));
	}
    }
    catch (Timeout&)
    { 
        returnMessage =  
            "Command failed: File transfer Timeout. "
            "Failed to receive expected response.  "
            "Current host data: " + m_host->data();

        log(L"FileTransferConnection::waitForTransfer",
	    Log::Debug, bstring2wstring(returnMessage));

	return returnMessage;
    }

    return returnMessage;
}

wstring 
FileTransferConnection::returnFilename(const wstring& pathAndFile)
{
    if (pathAndFile.rfind(L'/') != bstring::npos)
    {
        return pathAndFile.substr(pathAndFile.rfind(L'/') + 1);
    }
    else if (pathAndFile.rfind(L'\\') != bstring::npos)
    {
        return pathAndFile.substr(pathAndFile.rfind(L'\\') + 1);
    }
    else
    {
        return pathAndFile;
    }
}

}  // End namespace network
=====================================================================
Found a 104 line (422 tokens) duplication in the following files: 
Starting at line 32 of D:\home\eCora_PM\PM\pmOAService\CommandLine.cpp
Starting at line 31 of D:\home\eCora_PM\PM\pmWindowsService\CommandLine.cpp

    parseCmdLine(&cmdLineArgs, GetCommandLine());

    int argc = cmdLineArgs.size();
    wchar_t** argv = new wchar_t*[argc];
    for (int i = 0 ; i < argc; ++i)
    {
        wstring arg = cmdLineArgs[i];
        if (!i)
        {
            arg = wstring2vector(wstring2vector(arg, L"\\").back(), L".").front();
        }

        argv[i] = new wchar_t[arg.size() + 1];
        wcscpy(argv[i], arg.c_str());
    }

    setupOptions(argc, argv);

    for (int j = 0 ; j < argc; ++j)
    {
        delete[] argv[j];
    }
    delete[] argv;
}

void
CommandLine::parseCmdLine(vector<wstring>* words, const wstring& line)
{
    wstring word(L"");
    bool startWord = false;
    bool startQuote = false;

    wstring::const_iterator chIt = line.begin();
    for (; chIt != line.end(); ++chIt)
    {
        wchar_t c = *chIt;
        if (c == L'\"')
        {
            if (startWord)
            {
                startWord = false;
                words->push_back(word);
                word.erase();
            }
            else
            {
                startWord = true;
            }

            startQuote = !startQuote;

            continue;
        }

        if (c != L' ' && c != L'\t')
        {
            if (!startWord)
            {
                startWord = true;
            }
            word.append(1, c);
        }
        else
        {
            if (startQuote)
            {
                word.append(1, c);
            }
            else
            {
                if (startWord)
                {
                    startWord = false;
                    words->push_back(word);
                    word.erase();
                }
            }
        }
    }

    if (startQuote)
    {
        wstring errorMsg(L"Parsing error: double quotes not closed ! [");
        errorMsg.append(line).append(L"]");
        throw GenericException(
            __FILE__, __LINE__, L"CommandLine::parseCmdLine", L"", errorMsg);
    }

    if (startWord)
    {
        words->push_back(word);
    }
}

void
CommandLine::setupOptions(int argc, wchar_t** argv)
{
    assert(argc);
    assert(argv);

    WGetopt options(argc, argv);
    wstring logSpec;

    wchar_t c;
=====================================================================
Found a 57 line (407 tokens) duplication in the following files: 
Starting at line 1307 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 515 of D:\home\eCora_PM\PM\patchRepository\RepositorySettingsQT.cpp

    log(L"patchRepository", Log::Debug, L"Enter RepositorySettingsQT::determineUNCPath");
    wstring uncPath = path;

    try
    {
	auto_ptr<CRegConnectRegistry> pRemoteKey;
	pRemoteKey = auto_ptr<CRegConnectRegistry>(
	    new CRegConnectRegistry(L"", HKEY_LOCAL_MACHINE));

	if (0 == pRemoteKey.get() || 0 == pRemoteKey->GetHKEY())
	{
	    log(L"patchRepository", Log::Error,
		L"Error trying to convert local path to UNC: Unable to connect to registry");
	    return path;
	}

	HKEY hkeyRemote = pRemoteKey->GetHKEY();

	wstring sKey;
	sKey = _T("SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Shares");

	KeyValues kv(hkeyRemote, sKey.c_str());
	kv.Read();

	map<tstring, KeyData>::iterator it;
	for (it = kv.begin(); it != kv.end(); it++)
	{
	    wstring shareName = it->first;
	    BYTE value[2048];
	    DWORD len = 2048;

    	    HKEY openKeyMatch;
	    if (RegOpenKeyEx(hkeyRemote, sKey.c_str(),
			       0, KEY_ALL_ACCESS, &openKeyMatch) != ERROR_SUCCESS)
		continue;

	    if (RegQueryValueEx(openKeyMatch, shareName.c_str(), 0, 0, value, &len) == ERROR_SUCCESS)
	    {
		log(L"patchRepository", Log::Debug, L"Found share " << shareName);
		// the value returned from registry has multiple strings separated by "\0"
		wstring shareValue = wstring((LPWSTR)value);
		while (shareValue.size() < len / 2 - 2)
		    shareValue += L" " + wstring((LPWSTR)&value[(shareValue.size() + 1) * 2]);
		log(L"patchRepository", Log::Debug, L"Share value " << shareValue);

		wstring sharePath = shareValue.substr(shareValue.find(L"Path=") + 5);
		sharePath = sharePath.substr(0, sharePath.find(L"Permissions=") - 1);
		log(L"patchRepository", Log::Debug, L"Share path " << sharePath);

		// now we've got the local path for the share, see if it's part of the path the user chose
		if (_wcsicmp(sharePath.c_str(), path.substr(0, sharePath.size()).c_str()) == 0)
		{
		    uncPath = L"\\\\" + getHostName() + L"\\" + shareName;
		    if (path.size() > sharePath.size())
			uncPath += path.substr(sharePath.size());

		    log(L"patchRepository", Log::Debug,
=====================================================================
Found a 107 line (401 tokens) duplication in the following files: 
Starting at line 38 of D:\home\eCora_PM\PM\network\SshConnection.cpp
Starting at line 38 of D:\home\eCora_PM\PM\network\network\SshConnection.cpp

namespace network {

SshConnection::SshConnection()
{
}

SshConnection::~SshConnection()
{
    //  There are at least two shells created when the connection
    //  is made.   Kill them all now.
    try {
        send("exit\n");
        send("exit\n");
        send("exit\n");
    }

    catch (...)
    {
        log(L"SshConnection::~SshConnection()", Log::Debug,
            L"Error condition detected while killing shells.");
    }
    deleteHost();
}

void
SshConnection::connect(const LoginParameters*const device)
{
    log(L"SshConnection::connectTo", Log::Info, device->hostname());
    
    bstring connectionMethod =  ws2ansi(device->clientDir()) + 
        "plink_2_0.exe";

    vector<bstring> baseArguments;
    baseArguments.push_back("-ssh");
    baseArguments.push_back(ws2ansi(device->hostname()));

    //  Save the string that gets sent for future reference.    
    m_connectionString = L"Connecting using: " + 
        bstring2wstring(connectionMethod) +
	L" -ssh " + device->hostname();

    bstring arguments = ws2ansi(device->arguments());
   
    while (true)
    {
	char* thisToken =
	    strtok(const_cast<char *>(arguments.c_str()), " \t,;");
	
	if (thisToken == NULL)
	    break;

        bstring token = thisToken;

	m_connectionString += L" ";
	m_connectionString += bstring2wstring(token);

	baseArguments.push_back(token); 
    }

    //  FIXME:  We need a default for when the user does not want
    //    to enter a port.
    if (device->port() != 0)
    {
        baseArguments.push_back("-P");
        baseArguments.push_back(int2bstring(device->port()));
    }
    
    log(L"SshConnection::connectTo", Log::Debug, m_connectionString);
    
    m_host = new Smuggler(m_driver, connectionMethod, baseArguments);
    m_host->setTimeout(TWENTY_SECOND_TIMEOUT);
    
    m_connected = true;

    // If a userName and password are provided then
    // Login as a normal user would
    if (!device->username().empty())
    {
        login(ws2ansi(device->username()), ws2ansi(device->password()));
    }	      

    // FIXME:  NEED TO GET THIS INFORMATION FROM HOST MANAGEMENT.
    // If a prompt has been identified by the user, look for it after
    // delaying the proper amount of time (as specified by the user.)
    delayAndWaitForPrompt(device->loginDelay(), ws2ansi(device->loginPrompt()),
        TWENTY_SECOND_TIMEOUT);

    // Initialize the connection so that we are at a basic
    // level (/bin/sh with no environment variables)
    initShell();   
}


TerminalConnection* 
establishSshConnection(const LoginParameters*const device)
{
    wstring logMessage = device->username() + L"@" + device->hostname();
    log(L"establishSshConnection", Log::Info, logMessage);
	
    TerminalConnection* tC = new SshConnection();
    tC->connect(device);
    return tC;

}


} // End namespace connections
=====================================================================
Found a 99 line (386 tokens) duplication in the following files: 
Starting at line 37 of D:\home\eCora_PM\PM\network\TelnetConnection.cpp
Starting at line 37 of D:\home\eCora_PM\PM\network\network\TelnetConnection.cpp

namespace network {

TelnetConnection::TelnetConnection()
{
}

TelnetConnection::~TelnetConnection()
{
    //  There are at least two shells created when the connection
    //  is made.   Kill them all now.
    try {
        send("exit\n");
        send("exit\n");
        send("exit\n");
    }

    catch (...)
    {
        log(L"TelnetConnection::~TelnetConnection", Log::Debug,
            L"Error condition detected while killing shells.");
    }
    deleteHost();
}

void
TelnetConnection::connect(const LoginParameters*const device)
{    
    log(L"TelnetConnection::connectTo", Log::Info, device->hostname());
    
    bstring connectionMethod =  ws2ansi(device->clientDir()) + 
        "plink_2_0.exe";

    vector<bstring> baseArguments;
    baseArguments.push_back("-telnet");
    baseArguments.push_back(ws2ansi(device->hostname()));

    //  Save the string that gets sent for future reference.    
    m_connectionString = L"Connecting using: " + 
    bstring2wstring(connectionMethod) + L" -telnet " + device->hostname();

    bstring arguments = ws2ansi(device->arguments());
   
    while (true)
    {
	char* thisToken =
	    strtok(const_cast<char *>(arguments.c_str()), " \t,;");
	
	if (thisToken == NULL)
	    break;

        bstring token = thisToken;

	m_connectionString += L" ";
	m_connectionString += bstring2wstring(token);

	baseArguments.push_back(token); 
    }

    //  FIXME:  We need a default for when the user does not want
    //    to enter a port.
    if (device->port() != 0)
    {
        baseArguments.push_back("-P");
        baseArguments.push_back(int2bstring(device->port()));
    }
	
    log(L"TelnetConnection::connectTo", Log::Debug, m_connectionString);
    
    m_host = new Smuggler(m_driver, connectionMethod, baseArguments);
    m_host->setTimeout(TWENTY_SECOND_TIMEOUT);

    m_connected = true;

    // Login.
    login(ws2ansi(device->username()), ws2ansi(device->password()));

    // FIXME:  NEED TO GET THIS INFORMATION FROM HOST MANAGEMENT.
    // If a prompt has been identified by the user, look for it after
    // delaying the proper amount of time (as specified by the user.)
    delayAndWaitForPrompt(device->loginDelay(), ws2ansi(device->loginPrompt()),
        TWENTY_SECOND_TIMEOUT);

    // Initialize the connection so that we are at a basic
    // level (/bin/sh with no environment variables)
    initShell();    
}

TerminalConnection* 
establishTelnetConnection(const LoginParameters*const device)
{
    wstring logMessage = device->username() + L"@" + device->hostname();
    log(L"establishTelnetConnection", Log::Info, logMessage);
	
    TerminalConnection* tC = new TelnetConnection();
    tC->connect(device);
    return tC;
}

} // End namespace connections
=====================================================================
Found a 75 line (377 tokens) duplication in the following files: 
Starting at line 306 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\UnixComputer.cpp
Starting at line 486 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\UnixComputer.cpp

    actSeq->push_back(RepoTestAction::representation(id++, primaryKey(), repoDir()));

   // COMMAND TO TRANSFER THE COMPUTER  MODEL
    com::ISettings* iSet = 0;
    if (0 == appIface())
    {
        throw GenericException(__FILE__, __LINE__, L"UnixComputer::prepareForPush", L"",
                L"NULL IUknown interface.");
    }

    appIface()->QueryInterface(IID_ISettings, (void**)&iSet);
    if (0 == iSet)
    {
        throw GenericException(__FILE__, __LINE__, L"UnixComputer::prepareForPush", L"",
                L"NULL Settings interface pointer.");
    }

    model = iSet->setting(L"root") + L"/data/";
    model += primaryKey();

    CreateDirectory(model.c_str(), 0);

    model += L"/model.xml";
    //wstring dest = L"model.xml";
    actSeq->push_back(TransferFileAction::representation(id++, primaryKey(), model, ecoraDirectory()));

   // COMMAND TO TRANSFER THE INSTALLER
    wstring instCs = installerCheckSum();
    wstring localInstallerDir = iSet->setting(L"root");
    iSet->Release();
    wstring dest = ecoraDirectory();
    actSeq->push_back(TransferInstallerAction::representation(id++,
                                    primaryKey(),
                                    localInstallerDir,
                                    instCs,
                                    dest));

    // The script executed by 'at' or pass through on transfer only
    localTask->prepareForPush(&id, ecoraDirectory(), false, actSeq, installMethod());

    // CLEANUP
    actSeq->push_back(PushCleanupAction::representation(id++, model, localTask->getAtScriptName()));

    // Save the computer model to disk
    wofstream wos;
    wos.open(ws2utf8s(model).c_str(), (ios::in | ios::out | ios::trunc));
    sd.write(wos);

    // DISCONNECT
    actSeq->push_back(DisconnectAction::representation(id++, primaryKey()));


    try
    {

#ifdef _DEBUG
        wstring dumpFileName =  L"pushactions.xml";

        wofstream dumpFile;
        dumpFile.open(ws2utf8s(dumpFileName).c_str(), (ios::in | ios::out | ios::trunc));

        if (dumpFile.is_open())
            actionSeqDoc.write(dumpFile);
#endif
        actionsInterpreter()->loadActionSequence(actionSeqDoc);
    }
    catch (GenericException& e)
    {
        wstring message = L"Failed to create push actions: " + e.message();
        setStatus(pmPushBaseModel::IComputer::PushFailure, message);
        return 0;
    }

    return id; // the number of push actions
}
=====================================================================
Found a 228 line (368 tokens) duplication in the following files: 
Starting at line 41 of D:\home\eCora_PM\PM\network\TerminalConnection.h
Starting at line 41 of D:\home\eCora_PM\PM\network\network\TerminalConnection.h

using namespace smuggle;

namespace network {
  
class smuggle::Smuggler;
class smuggle::UnixDriver;

struct ShellResponse
{
    wstring command;
    wstring response;
    typedef enum
    {
        SUCCESS,
        FAIL,
        WARNING
    } status_t;

    status_t status;

};


/*
 * Base class used as a terminal connection to a remote machine.
 */
class TerminalConnection : public PtyConnection
{    
  public:
    TerminalConnection();
    virtual ~TerminalConnection();

    /*
     * Each terminal connection type (Telnet or Ssh) needs to implement a
     *  unique connection method.   All the parameters necessary to make
     *  a connection are encapsulated in the UnixDevice class.
     */
    virtual void connect(const LoginParameters*const) = 0;
    
    /*
     * Initialize Smuggle to a proper connection base on
     * Operating System type.
     */
    void initShell(void);

    /*
     * Allow the user to su to root.
     * @param  root password.
     * @param  int delay before testing to see if we are connected.
     * @param  prompt string that we will try to match.
     * @return true is uid=0 false otherwise.
     */
    bool beRoot(const wstring& password, const int delay,
		const wstring& prompt);

    /*
     * Check return the response to uid=0;
     * @return if (uid=0) return true else return false.
     */
    bool hostIdIsRoot();

    /*
     * Send a message to the remote device and wait for a response.
     * @param command to be sent.
     * @param retry count.  Number of attempts before giving up.
     * @return reponse from the remote device.
     */
    ShellResponse sh(const bstring& message, const int retryCount)
    { return (sendAndReceive(message, retryCount)); }
    
    /*
     * Send a message to the remote device and wait for a response.
     * @param command to be sent.
     * @return reponse from the remote device.
     */
    ShellResponse sh(const bstring& message)
    { return (sendAndReceive(message, 1)); }

    /*
     * Send a message to the remote device and wait for a response.
     * @param command to be sent.
     * @param filter these strings from the response.
     * @return filtered reponse from the remote device.
     */
    ShellResponse sh(const bstring& message, const wchar_t filter);

    /*
     * Send a message to the remote device and wait for a response.
     * Filter any carriage return, line feeds from the response, and 
     * return the result.  Throw an exection on error.
     * @param command to be sent.
     * @return filtered reponse from the remote device.
     */
    wstring shFilterCrLf(const bstring& message);

    /*
     * Execute the command passed but we don't care about the
     * response.  On error throw an exception.
     * @param command to be executed.
     */
    void shNoResponse(const bstring& command);

    /* 
     * Create the path on the remote device if it doesn't exist.
     * @param pathname.
     *
     */
    void makeAbsPath(const wstring& path);

    /*
     * Convert the name passed from "MS to Unix" and add quotes
     * if the addQuotes parameter is true.
     * @param name to be converted.
     * @param add quotes or not.
     * @return the converted string.
     */
    bstring convertName(const wstring& name, bool addQuotes);
    wstring wConvertName(const wstring& name, bool addQuotes);

    /*
     * Set the mask to whatever is passed.
     * @param mask
     *
     */
    void setUmask(const wstring& mask);


    /*
     *  Test for the exsitence of a file.
     *  @param filename (complete path or "local" filename)
     *  @return true if the file exists or false otherwise.
     *
     */
    bool fileExists(const wstring& filename);

    /*
     *  Remove the filename that is passed.  In order to remove
     *  entire directories and sub-directories, this method will
     *  execute the shell command "rm -r filepath"  which could
     *  be dangerous.   Use caution when makeing this call!  Any
     *  errors will throw an exception.
     *  @parm filename (complete path or "local" filename.)
     * 
     */
    void fileRemove(const wstring& filename);

    /*
     * Searches the directory passed and returns all of the
     * directories found in that directory.
     * @param Path to the directory to be searched.
     * @return a vector of directory names.
     */
    vector<wstring> getDirNamesOnly(const wstring& dirPath);

    /*
     * Searches the directory passed and returns all of the
     * filenames found in that directory.
     * @param Path to the directory to be searched.
     * @return a vector of directory names.
     */
    vector<wstring> getFileNamesOnly(const wstring& dirPath);

    /*
     * Searches the directory passed and returns everything.
     * @param Path to the directory to be searched.
     * @return a vector of names.
     */
    vector<wstring> getDirectoryContent(const wstring& dirPath);

    /*
     * Set permissions will change the files permissions using "/usr/bin/chmod"
     * @param filename ... complete path.
     * @param permissions to set on the file.
     */
    void setPermissions(const wstring& filePath, const wstring& permissions);

    /*
     * Set owner will change the files owner using "/usr/bin/chown"
     * @param filname ... complete path.
     * @param ownership name:group to set on the file.
     */
    void setOwner(const wstring& filePath, const wstring& owner);

    /*
     * checksum will return the files checksum using "/usr/bin/sum"
     * @param filename ... complete path to the file to be checksummed.
     * @return checksum value.
     */
    wstring checkSum(const wstring& filePath);

    /*
     * Determine how much space is available on the filesystem that
     * the directory passed has.
     * @param path ...  
     * @return number of kilo-bytes free.
     */
    unsigned long fsSpaceAvailable(const wstring& path);

    /*
     * Return the file size in bytes of the filename passed
     * @param file
     * @return size
     */
    unsigned long fileSize(const wstring& filePath);


    
  private:    
    /*
     * Send a message to the remote device and wait for a response.
     * @param command to be sent.
     * @param retry count.  Number of attempts before giving up.
     * @return reponse from the remote device.
     */
    ShellResponse sendAndReceive(const bstring& message,
			         const int retryCount);

    //  Assumes that the environment variable $ECMD has 
    //  already been loaded properly.  Will execute the
    //  command echo "$ECMD | /bin/sh",  strip CR/LFs from
    //  the response and store the result in the vector.
    vector<wstring> executeDirectoryListing(wstring logMessage);
    
};

TerminalConnection* makeTerminalConnection(const LoginParameters*const device);

} //  End namespace connections
=====================================================================
Found a 67 line (355 tokens) duplication in the following files: 
Starting at line 450 of D:\home\eCora_PM\PM\patchRepository\RepositoryUnitTest.h
Starting at line 275 of D:\home\eCora_PM\PM\patchRepository\RepositoryValidationManagerUnitTest.h

        setupEnvironment(patchIds, true);
    }


  private:
    static int m_trigger;
    map<wstring, wstring> m_resources;
    bool m_bLoaded;

    void load()
    {
        if (m_bLoaded)
            return;
        m_bLoaded = true;
        try {
            fs::FileSystem* fs = g_App->appServices()->disk()->systemHome();
            utf8string data;
            fs->file2utf8string(L"testsettings.xml", data);
            xml::Document* resourceFile = new xml::Document(data.c_str());

            xml::BaseNode* baseRes = resourceFile->query(L"testsettings", 0);
            xml::Node* res = dynamic_cast<xml::Node*>(baseRes);

            xml::Node::iterator it;
            for (it = res->begin(); it != res->end(); ++it)
            {
                xml::Node* resource = dynamic_cast<xml::Node*>(*it);
                if (resource != 0)
                {
                    wstring tag = resource->name();
                    xml::Data* data = dynamic_cast<xml::Data*>(*resource->begin());
                    if (data)
                    {
                        wstring value = data->value(true);
                        m_resources[tag] = value;
                    }
                }
            }
            delete resourceFile;

            //m_resources[Resources::UpdateProductName] = L"patchpro3";

        }
        catch (xml::Error& e)
        {
            QString message = "Error in resource file: line %1: %2";
            message = message.arg(e.stopLine());
            message = message.arg(ws2qs(e.userMessage()));

            wstring errorMessage = qs2ws(message);
            throw GenericException(__FILE__, __LINE__, L"Resources::load",
                L"", errorMessage);
        }
        catch (GenericException& e)
        {
            QString message = "Error in resource file: %1";
            message = message.arg(ws2qs(e.userMessage()));

            wstring errorMessage = qs2ws(message);
            throw GenericException(__FILE__, __LINE__, L"Resources::load",
                L"", errorMessage);
        }

    };
};

static RepositoryValidationManagerUnitTest RepositoryValidationManagerUnitTestTrigger;
=====================================================================
Found a 92 line (355 tokens) duplication in the following files: 
Starting at line 32 of D:\home\eCora_PM\PM\idbXml\DbObject.cpp
Starting at line 26 of D:\home\eCora_PM\PM\idb\DbObject.cpp

HRESULT DbObject::QueryInterface(const GUID& iid, void** ppObj)
{
    if (IID_IUnknown == iid || IID_IDbObject == iid)
    {
        *ppObj = (com::IDbObject*)this;
        AddRef();
        return NO_ERROR;
    }
    else
    {
        *ppObj = 0;
        return E_NOINTERFACE;
    }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
unsigned long DbObject::AddRef()
{
    return m_baseObject.addRef();
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
unsigned long DbObject::Release()
{
    return m_baseObject.release(this);
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
HRESULT DbObject::getFields(QValueVector<QPair<QString, int> >& pFields)
{
    pFields = m_fields.getFields();
    return S_OK;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
HRESULT DbObject::getFieldValue(const QString& qsName, QString& qsValue) const
{
    qsValue = m_fields.getFieldValue(qsName);
    return S_OK;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
HRESULT DbObject::getEncodedFieldValue(const QString& qsName, QString& qsValue) const
{
    qsValue = m_fields.getEncodedFieldValue(qsName);
    return S_OK;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
HRESULT DbObject::setFieldValue(const QString& qsName, QString& qsValue)
{
    m_fields.setFieldValue(qsName, qsValue);
    return S_OK;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
HRESULT DbObject::setEncodedFieldValue(const QString& qsName, QString& qsValue)
{
    m_fields.setEncodedFieldValue(qsName, qsValue);
    return S_OK;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
bool DbObject::matchObject(com::IDbObject* pMatch)
{
    QValueVector<QPair<QString, int> >& fields = m_fields.getFields();
    QValueVector<QPair<QString, int> >::iterator iter;
    for (iter = fields.begin(); iter != fields.end(); ++iter)
    {
        QString qsValue;
        pMatch->getFieldValue(iter->first, qsValue);
        if (qsValue.length())
        {
            if (qsValue != m_fields.getFieldValue(iter->first))
                return false;
        }
    }
    return true;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void DbObject::setServices(IUnknown* pServices)
{
=====================================================================
Found a 56 line (353 tokens) duplication in the following files: 
Starting at line 108 of D:\home\eCora_PM\PM\solarisActions\InstallPatchAction.cpp
Starting at line 105 of D:\home\eCora_PM\PM\solarisActions\RemovePatchAction.cpp

            log(LOGID, Log::User, L"Verifying patch removal.");
            vector<char*> showrevArgs;
            showrevArgs.insert(showrevArgs.end(), const_cast<char *>("showrev"));
            showrevArgs.insert(showrevArgs.end(), const_cast<char *>("-p"));
            CommandDef showrev("/usr/bin/showrev", showrevArgs, "");  

            log(LOGID, Log::Debug, L"Executing showrev.");
            try
            {
                showrev.exec();
            }
            catch (GenericException e)
            {
                logMsg << "Error executing showrev: " << e.message();
                log(LOGID, Log::Error, logMsg.str());
                return  getErrorActionResult(env);
            }
            log(LOGID, Log::Debug, L"Done executing showrev.");

            log(LOGID, Log::Debug, L"Reading output from showrev.");
            try
            {
                showrev.readPipes();
            }
            catch (GenericException e)
            {
                logMsg << "Error reading showrev output: " << e.message();
                log(LOGID, Log::Error, logMsg.str());
                return  getErrorActionResult(env);
            }
            bstring output = showrev.getStdoutOutput();
            bstring errOutput = showrev.getStderrOutput();
            log(LOGID, Log::Debug, L"Done reading output from showrev.");

            if (!output.empty())
            {
                logMsg << "Showrev output:" << endl << endl << output << endl;
                log(LOGID, Log::Debug, logMsg.str());
                logMsg.str(L"");
            }

            if (!errOutput.empty())
            {
                logMsg << "Showrev stderr output:" << endl << endl << errOutput << endl;
                log(LOGID, Log::Error, logMsg.str());
                logMsg.str(L"");
            } 

            if (!showrev.exited() || (showrev.status() != 0))
            {
                log(LOGID, Log::Error, 
                    L"Error executing /usr/bin/showrev to verify patch installation.");
                return getErrorActionResult(env);
            }

            if (output.find("Patch: " + patchId) != bstring::npos)
=====================================================================
Found a 209 line (348 tokens) duplication in the following files: 
Starting at line 47 of D:\home\eCora_PM\PM\agent\agent\Library\unzlib\unzip.h
Starting at line 47 of D:\home\eCora_PM\PM\zlib\unzip.h

extern "C" {
#endif

#ifndef _ZLIB_H
#include "zlib.h"
#endif

#ifndef _ZLIBIOAPI_H
#include "ioapi.h"
#endif

#if defined(STRICTUNZIP) || defined(STRICTZIPUNZIP)
/* like the STRICT of WIN32, we define a pointer that cannot be converted
    from (void*) without cast */
typedef struct TagunzFile__ { int unused; } unzFile__; 
typedef unzFile__ *unzFile;
#else
typedef voidp unzFile;
#endif


#define UNZ_OK                          (0)
#define UNZ_END_OF_LIST_OF_FILE         (-100)
#define UNZ_ERRNO                       (Z_ERRNO)
#define UNZ_EOF                         (0)
#define UNZ_PARAMERROR                  (-102)
#define UNZ_BADZIPFILE                  (-103)
#define UNZ_INTERNALERROR               (-104)
#define UNZ_CRCERROR                    (-105)

/* tm_unz contain date/time info */
typedef struct tm_unz_s 
{
	uInt tm_sec;            /* seconds after the minute - [0,59] */
	uInt tm_min;            /* minutes after the hour - [0,59] */
	uInt tm_hour;           /* hours since midnight - [0,23] */
	uInt tm_mday;           /* day of the month - [1,31] */
	uInt tm_mon;            /* months since January - [0,11] */
	uInt tm_year;           /* years - [1980..2044] */
} tm_unz;

/* unz_global_info structure contain global data about the ZIPfile
   These data comes from the end of central dir */
typedef struct unz_global_info_s
{
	uLong number_entry;         /* total number of entries in
				       the central dir on this disk */
	uLong size_comment;         /* size of the global comment of the zipfile */
} unz_global_info;


/* unz_file_info contain information about a file in the zipfile */
typedef struct unz_file_info_s
{
    uLong version;              /* version made by                 2 bytes */
    uLong version_needed;       /* version needed to extract       2 bytes */
    uLong flag;                 /* general purpose bit flag        2 bytes */
    uLong compression_method;   /* compression method              2 bytes */
    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
    uLong crc;                  /* crc-32                          4 bytes */
    uLong compressed_size;      /* compressed size                 4 bytes */ 
    uLong uncompressed_size;    /* uncompressed size               4 bytes */ 
    uLong size_filename;        /* filename length                 2 bytes */
    uLong size_file_extra;      /* extra field length              2 bytes */
    uLong size_file_comment;    /* file comment length             2 bytes */

    uLong disk_num_start;       /* disk number start               2 bytes */
    uLong internal_fa;          /* internal file attributes        2 bytes */
    uLong external_fa;          /* external file attributes        4 bytes */

    tm_unz tmu_date;
} unz_file_info;

extern int ZEXPORT unzStringFileNameCompare OF ((const char* fileName1,
												 const char* fileName2,
												 int iCaseSensitivity));
/*
   Compare two filename (fileName1,fileName2).
   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
								or strcasecmp)
   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
	(like 1 on Unix, 2 on Windows)
*/


extern unzFile ZEXPORT unzOpen OF((const char *path));
/*
  Open a Zip file. path contain the full pathname (by example,
     on a Windows XP computer "c:\\zlib\\zlib113.zip" or on an Unix computer
	 "zlib/zlib113.zip".
	 If the zipfile cannot be opened (file don't exist or in not valid), the
	   return value is NULL.
     Else, the return value is a unzFile Handle, usable with other function
	   of this unzip package.
*/

extern unzFile ZEXPORT unzOpen2 OF((const char *path,
                                    zlib_filefunc_def* pzlib_filefunc_def));
/*   Open a Zip file, like unzOpen, but provide a set of file low level API 
      for read/write the zip file (see ioapi.h)
*/

extern int ZEXPORT unzClose OF((unzFile file));
/*
  Close a ZipFile opened with unzipOpen.
  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
  return UNZ_OK if there is no problem. */

extern int ZEXPORT unzGetGlobalInfo OF((unzFile file,
					unz_global_info *pglobal_info));
/*
  Write info about the ZipFile in the *pglobal_info structure.
  No preparation of the structure is needed
  return UNZ_OK if there is no problem. */


extern int ZEXPORT unzGetGlobalComment OF((unzFile file,
										   char *szComment,
					   uLong uSizeBuf));
/*
  Get the global comment string of the ZipFile, in the szComment buffer.
  uSizeBuf is the size of the szComment buffer.
  return the number of byte copied or an error code <0
*/


/***************************************************************************/
/* Unzip package allow you browse the directory of the zipfile */

extern int ZEXPORT unzGoToFirstFile OF((unzFile file));
/*
  Set the current file of the zipfile to the first file.
  return UNZ_OK if there is no problem
*/

extern int ZEXPORT unzGoToNextFile OF((unzFile file));
/*
  Set the current file of the zipfile to the next file.
  return UNZ_OK if there is no problem
  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
*/

extern int ZEXPORT unzLocateFile OF((unzFile file, 
				     const char *szFileName,
				     int iCaseSensitivity));
/*
  Try locate the file szFileName in the zipfile.
  For the iCaseSensitivity signification, see unzStringFileNameCompare

  return value :
  UNZ_OK if the file is found. It becomes the current file.
  UNZ_END_OF_LIST_OF_FILE if the file is not found
*/


/* ****************************************** */
/* Ryan supplied functions */
/* unz_file_info contain information about a file in the zipfile */
typedef struct unz_file_pos_s
{
    uLong pos_in_zip_directory;   /* offset in zip file directory */
    uLong num_of_file;            /* # of file */
} unz_file_pos;

extern int ZEXPORT unzGetFilePos(
    unzFile file,
    unz_file_pos* file_pos);

extern int ZEXPORT unzGoToFilePos(
    unzFile file,
    unz_file_pos* file_pos);

/* ****************************************** */

extern int ZEXPORT unzGetCurrentFileInfo OF((unzFile file,
					     unz_file_info *pfile_info,
					     char *szFileName,
					     uLong fileNameBufferSize,
					     void *extraField,
					     uLong extraFieldBufferSize,
					     char *szComment,
					     uLong commentBufferSize));
/*
  Get Info about the current file
  if pfile_info!=NULL, the *pfile_info structure will contain somes info about
	    the current file
  if szFileName!=NULL, the filemane string will be copied in szFileName
			(fileNameBufferSize is the size of the buffer)
  if extraField!=NULL, the extra field information will be copied in extraField
			(extraFieldBufferSize is the size of the buffer).
			This is the Central-header version of the extra field
  if szComment!=NULL, the comment string of the file will be copied in szComment
			(commentBufferSize is the size of the buffer)
*/

/***************************************************************************/
/* for reading the content of the current zipfile, you can open it, read data
   from it, and close it (you can close it before reading all the file)
   */

extern int ZEXPORT unzOpenCurrentFile OF((unzFile file));
/*
  Open for reading data the current file in the zipfile.
  If there is no error, the return value is UNZ_OK.
*/

extern int ZEXPORT unzOpenCurrentFile2 OF((unzFile file,
=====================================================================
Found a 51 line (345 tokens) duplication in the following files: 
Starting at line 225 of D:\home\eCora_PM\PM\utils\Registry.cc
Starting at line 210 of D:\home\eCora_PM\PM\utils\RemoteRegistry.cpp

    status = RegOpenKeyEx(m_remoteKey, key.c_str(), 0, KEY_READ, &openKey.get());
    if (status != ERROR_SUCCESS)
	return ret;
    
    DWORD maxKeyLen;
    DWORD maxValueNameLen;

    // Find the max data length for the subkeys and value names
    status = RegQueryInfoKey(
	openKey.get(), NULL, NULL, NULL, NULL, &maxKeyLen, 
	NULL, NULL, &maxValueNameLen, NULL, NULL, NULL);
    if (status != ERROR_SUCCESS)
	throw WinErrorException(
	    __FILE__, __LINE__, L"RegQueryInfoKey", status, fullkey);

    // enumerate the values names
    maxlen = maxValueNameLen * sizeof(wchar_t) + 2;
    auto_ptr<BYTE> array(new BYTE[maxlen]);
    index = 0;
    do {
	DWORD len = maxlen;
	memset(array.get(), 0, maxlen);
	status = RegEnumValue(
	    openKey.get(), index++, reinterpret_cast<wchar_t*>(array.get()),
	    &len, NULL, NULL, NULL, NULL);
	if (status == ERROR_SUCCESS)
	{
	    wstring s(reinterpret_cast<wchar_t*>(array.get()));
	    ret.push_back(s);
	}
    } while (status == ERROR_SUCCESS);

    // enumerate the subkeys
    maxlen = maxKeyLen * sizeof(wchar_t) + 2;
    auto_ptr<BYTE> dataArray(new BYTE[maxlen]);
    index = 0;
    do {
	DWORD len = maxlen;
	memset(dataArray.get(), 0, maxlen);
	status = RegEnumKeyEx(
	    openKey.get(), index++, reinterpret_cast<wchar_t*>(dataArray.get()), 
	    &len, NULL, NULL, NULL, NULL);
	if (status == ERROR_SUCCESS)
	{
	    wstring s(reinterpret_cast<wchar_t*>(dataArray.get()));
	    ret.push_back(s);
	}
    } while (status == ERROR_SUCCESS);
    
    return ret;
}
=====================================================================
Found a 58 line (342 tokens) duplication in the following files: 
Starting at line 1547 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 204 of D:\home\eCora_PM\PM\patchRepository\WinSolRepoSettings.cpp

    m_dsnChanged(false)
{
    if (0 == winWidget)
        m_winWidget = new WinRepoSettings(parent, services);
    else
        m_winWidget = (WinRepoSettings*)winWidget;
    if (0 == solWidget)
        m_solWidget = new SolRepoSettings(parent, services);
    else
        m_solWidget = (SolRepoSettings*)solWidget;

    qtInit();
}

void WinSolRepoSettings::qtInit()
{
/*
    if (m_parent != 0)
        if (m_parent->icon() != 0)
            setIcon(*(m_parent->icon()));
*/
    m_winWidget->setHelper(this);
    m_solWidget->setHelper(this);

    ui::help::InlineHelp tips;
    if (check_patchRepository_InlineHelpVar())
    {
        tips.loadDataF(g_patchRepository_inlineHelp);
    }

    tips.setHelp(m_winWidget->m_enableWindows, L"Enable Windows");
    tips.setHelp(m_winWidget->m_windowsPassword, L"Windows Password");
    //tips.setHelp(m_winWidget->m_windowsConfirmPass, L"Windows Confirm Password");
    tips.setHelp(m_winWidget->m_browseWindowsRepo, L"Browse Windows Repository");
    tips.setHelp(m_winWidget->m_browseForDownloadDir, L"Browse For Download Dir");
    tips.setHelp(m_winWidget->m_downloadDir, L"Download Dir");
    tips.setHelp(m_winWidget->m_windowsLogin, L"Windows Login");
    tips.setHelp(m_winWidget->m_windowsRepository, L"Windows Repository");
    tips.setHelp(m_winWidget->m_upgrade20Repo, L"Upgrade 2 0 Repository");
    tips.setHelp(m_winWidget->m_removeUnusedStatus, L"CleanupRepositoryStatus");

    tips.setHelp(m_solWidget->m_enableUnix, L"Enable Unix");
    tips.setHelp(m_solWidget->m_unixTPassword, L"Unix Terminal Connection Password");
    tips.setHelp(m_solWidget->m_unixTRootPass, L"Unix Root Password");
    tips.setHelp(m_solWidget->m_unixFTPassword, L"Unix FTP Password");
    //tips.setHelp(m_solWidget->m_unixTConfirmPass, L"Unix Verify Terminal Connection Password");
    //tips.setHelp(m_solWidget->m_unixTConfirmRootPass, L"Unix Verify Root Password");
    //tips.setHelp(m_solWidget->m_unixFTConfirmPass, L"Unix Verify FTP Password");
    tips.setHelp(m_solWidget->m_unixAdvancedButton, L"Button: Unix Advanced");

    tips.setHelp(m_solWidget->m_unixRepository, L"Unix Repository");
    tips.setHelp(m_solWidget->m_unixHostname, L"Unix Hostname");
    tips.setHelp(m_solWidget->m_unixDNSDomain, L"Unix DNS Domain");
    tips.setHelp(m_solWidget->m_unixIPAddress, L"Unix IP Address");
    tips.setHelp(m_solWidget->m_unixTUsername, L"Unix Terminal Connection Username");
    tips.setHelp(m_solWidget->m_unixTProtocol, L"Unix Terminal Connection Protocol");
    tips.setHelp(m_solWidget->m_unixFTUsername, L"Unix FTP Connection Username");
    tips.setHelp(m_solWidget->m_unixFTProtocol, L"Unix FTP Connection Protocol");
=====================================================================
Found a 63 line (341 tokens) duplication in the following files: 
Starting at line 286 of D:\home\eCora_PM\PM\pmDaoDbImpl\DaoDbImplUnitTest.h
Starting at line 445 of D:\home\eCora_PM\PM\pmDaoXmlImpl\DaoXmlImplUnitTest.h

        TS_ASSERT(iSystem);

        createSystemObjectGraph(iSystem);

        TS_ASSERT(iSystem->first());

        pmDaoInterfaces::IActivity* iActivity = iSystem->getActivities();

        TS_ASSERT(iActivity);
        TS_ASSERT(iActivity->count() == 3);

        iActivity->clear();

        TS_ASSERT(iActivity->count() == 0);
        TS_ASSERT(!iActivity->first());

        iActivity = iSystem->getActivities();
        TS_ASSERT(iActivity);
        TS_ASSERT(iActivity->count() == 0);
        TS_ASSERT(!iActivity->first());

        pmDaoInterfaces::IProduct* iProduct = iSystem->getProducts();
        TS_ASSERT(iProduct);
        TS_ASSERT(iProduct->count() == 2);

        bool moreProducts = iProduct->first();
        if (moreProducts)
        {
            pmDaoInterfaces::IPatch* iPatch = iProduct->getPatches();
            TS_ASSERT(iPatch);
            TS_ASSERT(iPatch->count() == 2);

            iPatch->clear();

            count = iPatch->count();
            TS_ASSERT(count == 0);
            TS_ASSERT(!iPatch->first());
        }

        TS_ASSERT(iProduct->next());

        pmDaoInterfaces::IPatch* iPatch = iProduct->getPatches();
        TS_ASSERT(iPatch);
        TS_ASSERT(iPatch->count() == 2);

        iSystem->clear();
        TS_ASSERT(iSystem->count() == 0);

        iActivity = iSystem->getActivities();
        TS_ASSERT(iActivity);
        TS_ASSERT(iActivity->count() == 0);

        iProduct = iSystem->getProducts();
        TS_ASSERT(iProduct);
        TS_ASSERT(iProduct->count() == 0);

        iPatch = iProduct->getPatches();
        TS_ASSERT(iPatch);
        count = iPatch->count();
        TS_ASSERT(count == 0);
    }

    void testCompare()
=====================================================================
Found a 63 line (336 tokens) duplication in the following files: 
Starting at line 457 of D:\home\eCora_PM\PM\patchRepository\RepositoryUnitTest.h
Starting at line 1128 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h

      map<wstring, wstring> m_resources;
      // this function loads all settings we need (uder name, passwd, pathes etc)
      // from the testsettings.xml file
    void load()
    {
        if (m_bLoaded)
            return;
        m_bLoaded = true;
        try {
            fs::FileSystem* fs = g_App->appServices()->disk()->systemHome();
            utf8string data;
            fs->file2utf8string(L"testsettings.xml", data);
            xml::Document* resourceFile = new xml::Document(data.c_str());

            xml::BaseNode* baseRes = resourceFile->query(L"testsettings", 0);
            xml::Node* res = dynamic_cast<xml::Node*>(baseRes);

            xml::Node::iterator it;
            for (it = res->begin(); it != res->end(); ++it)
            {
                xml::Node* resource = dynamic_cast<xml::Node*>(*it);
                if (resource != 0)
                {
                    wstring tag = resource->name();
                    xml::Data* data = dynamic_cast<xml::Data*>(*resource->begin());
                    if (data)
                    {
                        wstring value = data->value(true);
                        m_resources[tag] = value;
                    }
                }
            }
            delete resourceFile;

            //m_resources[Resources::UpdateProductName] = L"patchpro3";

        }
        catch (xml::Error& e)
        {
            QString message = "Error in resource file: line %1: %2";
            message = message.arg(e.stopLine());
            message = message.arg(ws2qs(e.userMessage()));

            wstring errorMessage = qs2ws(message);
            throw GenericException(__FILE__, __LINE__, L"Resources::load",
                L"", errorMessage);
        }
        catch (GenericException& e)
        {
            QString message = "Error in resource file: %1";
            message = message.arg(ws2qs(e.userMessage()));

            wstring errorMessage = qs2ws(message);
            throw GenericException(__FILE__, __LINE__, L"Resources::load",
                L"", errorMessage);
        }

    };


};

static RepositoryWindowsStorageUnitTest RepositoryWindowsStorageUnitTestTrigger;
=====================================================================
Found a 62 line (332 tokens) duplication in the following files: 
Starting at line 85 of D:\home\eCora_PM\PM\patchManager\GroupInfo.cpp
Starting at line 35 of D:\home\eCora_PM\PM\patchManager\ProductInfo.cpp

    switch (criteria) {
    case Criteria::WINDOWS_OS_PRODUCT:
	return g_GlobalConst.osPixmap();
    case Criteria::WINDOWS_IIS_PRODUCT:
	return g_GlobalConst.iisPixmap();
    case Criteria::WINDOWS_IE_PRODUCT:
	return g_GlobalConst.iePixmap();
    case Criteria::WINDOWS_WMP_PRODUCT:
	return g_GlobalConst.wmpPixmap();
    case Criteria::WINDOWS_EXCHANGE_PRODUCT:
	return g_GlobalConst.exchangePixmap();
    case Criteria::WINDOWS_DOTNET_PRODUCT:
	return g_GlobalConst.dotNetPixmap();
    case Criteria::WINDOWS_DIRECTX_PRODUCT:
	return g_GlobalConst.directXPixmap();
    case Criteria::WINDOWS_OUTLOOKEXPRESS_PRODUCT:
	return g_GlobalConst.outlookExpPixmap();
    case Criteria::WINDOWS_SQL_PRODUCT:
	return g_GlobalConst.sqlPixmap();
    case Criteria::WINDOWS_MSDE_PRODUCT:
	return g_GlobalConst.sqlPixmap();
    case Criteria::WINDOWS_MDAC_PRODUCT:
	return g_GlobalConst.mdacPixmap();
    case Criteria::WINDOWS_OFFICE_PRODUCT:
	return g_GlobalConst.officePixmap();
    case Criteria::SOLARIS_UNBUNDLED_PRODUCT:
	return g_GlobalConst.unbundledPixmap();
    case Criteria::SOLARIS_OS_PRODUCT:
	return g_GlobalConst.solarisOSPixmap();
    case Criteria::SOLARIS_SOLARIS_PRODUCT:
	return g_GlobalConst.solarisPixmap();
    case Criteria::SOLARIS_MISC_PRODUCT:
	return g_GlobalConst.miscPixmap();
    case Criteria::NEW_PRODUCT_NO_KB_CRITERIA:
	return g_GlobalConst.newProductNoKbPixmap();
    //elefil
    case Criteria::WINDOWS_ADOBE_PRODUCT:
    return g_GlobalConst.adobePixmap();
    case Criteria::WINDOWS_JRE_PRODUCT:
    return g_GlobalConst.jrePixmap();
    //end elefi
    //air 2010
    case WINDOWS_MSXML_PRODUCT:
        return g_GlobalConst.msxmlPixmap();
    case WINDOWS_DEFENDER_PRODUCT:
        return g_GlobalConst.defenderPixmap();
    case WINDOWS_FIREFOX_PRODUCT:
        return g_GlobalConst.firefoxPixmap();
    case WINDOWS_THUNDERBIRD_PRODUCT:
        return g_GlobalConst.thunderbirdPixmap();
    case Criteria::WINDOWS_FLASHPLAYER_PRODUCT:
        return g_GlobalConst.flashplayerPixmap();
    case Criteria::WINDOWS_WLIVE_PRODUCT:
        return g_GlobalConst.wlivePixmap();

    case Criteria::CUSTOM_PRODUCT:
        return g_GlobalConst.metaDomainPixmap(); //Valeri 29-Sep-2005 CHANGE IT!!!
    case Criteria::CUSTOM_PRODUCT_VERSION:
        {
            CPixmapItem *item;
            item = NULL;
            g_App->getCaches()->m_dcPictures->getItem(this->m_productName, (CCacheItem**)&item);
=====================================================================
Found a 49 line (331 tokens) duplication in the following files: 
Starting at line 115 of D:\home\eCora_PM\PM\collector\TextInterface.h
Starting at line 210 of D:\home\eCora_PM\PM\collector\TextInterface.h

    virtual void setPassword(const wstring &val);

    // inherited from InterfaceCommon
    virtual int licenseLimit(const wstring& type) const
    { return m_common->licenseLimit(type); }
    virtual wstring networkCacheFile() const
    { return m_common->networkCacheFile(); }
    virtual wstring installationDirectory() const 
    { return m_common->installationDirectory(); }
    virtual QWidget* parentWindow() const 
    { return m_common->parentWindow(); }
    virtual bool trialMode() const 
    { return m_common->trialMode(); }
    virtual wstring encrypt(const wstring& in) const
    { return m_common->encrypt(in); }
    virtual wstring decrypt(const wstring& in) const
    { return m_common->decrypt(in); }
    virtual int information(
	const wstring& caption, 
	const wstring& text,
	const wstring& b0 = L"",
	const wstring& b1 = L"",
	const wstring& b2 = L"", 
	int defaultButtonNumber = 0, 
	int escapeButtonNumber = -1) const
    { return m_common->information(
	caption, text, b0, b1, b2, defaultButtonNumber, escapeButtonNumber); }
    virtual int warning(
	const wstring& caption, 
	const wstring& text,
	const wstring& b0 = L"",
	const wstring& b1 = L"",
	const wstring& b2 = L"", 
	int defaultButtonNumber = 0, 
	int escapeButtonNumber = -1) const
    { return m_common->warning(
	caption, text, b0, b1, b2, defaultButtonNumber, escapeButtonNumber); }
    virtual int critical(
	const wstring& caption, 
	const wstring& text,
	const wstring& b0 = L"",
	const wstring& b1 = L"",
	const wstring& b2 = L"", 
	int defaultButtonNumber = 0, 
	int escapeButtonNumber = -1) const
    { return m_common->critical(
	caption, text, b0, b1, b2, defaultButtonNumber, escapeButtonNumber); }

  private:
=====================================================================
Found a 91 line (322 tokens) duplication in the following files: 
Starting at line 79 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 67 of D:\home\eCora_PM\PM\patchRepository\WinSolRepoSettings.cpp

namespace patchRepository {

// BEGIN FIX BUG #18532

class WinSolRepoTranslator : public PatchTranslatorBase
{
  public:
    WinSolRepoTranslator()
    {
        m_table.push_back(TranslatePair(
                "Remote login failed. Sending user/password. "
                "Host Response:",
                WinSolRepoTranslator::tr(
                "Remote login failed. Sending user/password. "
                "Host Response:"
                )
            ));
        m_table.push_back(TranslatePair(
                "Remote connection failed.  "
                "Host response:",
                WinSolRepoTranslator::tr(
                "Remote connection failed.  "
                "Host response:"
                )
            ));
        m_table.push_back(TranslatePair(
                "Remote connection failed.  Failed to identify prompt:",
                WinSolRepoTranslator::tr("Remote connection failed.  Failed to identify prompt:")
            ));
        m_table.push_back(TranslatePair(
                "Host response was:",
                WinSolRepoTranslator::tr("Host response was:")
            ));
        m_table.push_back(TranslatePair(
                "Host response:",
                WinSolRepoTranslator::tr("Host response:")
            ));
        m_table.push_back(TranslatePair(
                "Remote connection failed.",
                WinSolRepoTranslator::tr("Remote connection failed.")
            ));
        m_table.push_back(TranslatePair(
                "Login incorrect",
                WinSolRepoTranslator::tr("Login incorrect")
            ));
        m_table.push_back(TranslatePair(
                "Access denied",
                WinSolRepoTranslator::tr("Access denied")
            ));
        m_table.push_back(TranslatePair(
                "Authentication refused",
                WinSolRepoTranslator::tr("Authentication refused")
            ));
        m_table.push_back(TranslatePair(
                "Connection refused",
                WinSolRepoTranslator::tr("Connection refused")
            ));
        m_table.push_back(TranslatePair(
                "Unknown host",
                WinSolRepoTranslator::tr("Unknown host")
            ));
        m_table.push_back(TranslatePair(
                "Looking up host",
                WinSolRepoTranslator::tr("Looking up host")
            ));
        m_table.push_back(TranslatePair(
                "Connecting to",
                WinSolRepoTranslator::tr("Connecting to")
            ));
        m_table.push_back(TranslatePair(
                "FATAL ERROR",
                WinSolRepoTranslator::tr("FATAL ERROR")
            ));
        m_table.push_back(TranslatePair(
                "Network error",
                WinSolRepoTranslator::tr("Network error")
            ));
        m_table.push_back(TranslatePair(
                "Connection timed out",
                WinSolRepoTranslator::tr("Connection timed out")
            ));
        m_table.push_back(TranslatePair(
                "port",
                WinSolRepoTranslator::tr("port")
            ));
    }
};

// END FIX BUG #18532

WinRepoSettings::WinRepoSettings(QWidget* parent, IUnknown* services):
=====================================================================
Found a 92 line (322 tokens) duplication in the following files: 
Starting at line 382 of D:\home\eCora_PM\PM\daoXmlImpl\XmlDaoBase.cpp
Starting at line 203 of D:\home\eCora_PM\PM\pmDaoXmlImpl\XmlDaoBase.cpp

    QDomElement returnEntity = m_doc->createElement(ws2qs(getDaoId()));

    setEntityAttr(&returnEntity, metaElem.getName(), metaElem.getValue());

    resEntities->push_back(returnEntity);
}

void
XmlDaoBase::entitiesByName(const wstring& entityName, const QDomElement& entity, EntityList* entities)
{
    assert(entities);

    if (entity.tagName() == ws2qs(entityName))
    {
        entities->push_back(entity);
        return;
    }

    QDomNodeList nodeList = entity.elementsByTagName(ws2qs(entityName));
    for (size_t nodeIdx = 0; nodeIdx < nodeList.length(); ++nodeIdx)
    {
        QDomElement elem = nodeList.item(nodeIdx).toElement();
        assert(!elem.isNull());

        entities->push_back(elem);
    }
}

unsigned int
XmlDaoBase::count() const
{
    return m_entities.size();
}

bool
XmlDaoBase::next()
{
    if (m_crtEntity == m_entities.end())
    {
        return false;
    }

    if (++m_crtEntity == m_entities.end())
    {
        return false;
    }

    return true;
}

bool
XmlDaoBase::prev()
{
    if (m_crtEntity == m_entities.begin())
    {
        return false;
    }

    if (--m_crtEntity == m_entities.end())
    {
        return false;
    }

    return true;
}

bool
XmlDaoBase::first()
{
    m_crtEntity = m_entities.begin();

    if (m_crtEntity == m_entities.end())
    {
        return false;
    }

    return true;
}

bool
XmlDaoBase::last()
{
    if (!m_entities.size())
    {
        return false;
    }

    m_crtEntity = m_entities.end();
    --m_crtEntity;

    return true;
}
=====================================================================
Found a 84 line (304 tokens) duplication in the following files: 
Starting at line 194 of D:\home\eCora_PM\PM\pmAnalysisWinProvider\Constants.cpp
Starting at line 567 of D:\home\eCora_PM\PM\pmCollectorWinProvider\OsUtils.cpp

    return L"Windows";
}

wstring
GetMsProductNames::getMsProductVersionName()
{
    if (m_mask & PROD_INVALID)
        return L"";
    
    if (m_mask & PROD_NT4)
    {
        wstring wsVersion = L"";
        
        if (m_mask & PROD_SP3)
            wsVersion = L"Windows NT4 Service Pack 3";
        else if (m_mask & PROD_SP4)
            wsVersion = L"Windows NT4 Service Pack 4";
        else if (m_mask & PROD_SP5)
            wsVersion = L"Windows NT4 Service Pack 5";
        else if (m_mask & PROD_SP6)
            wsVersion = L"Windows NT4 Service Pack 6a";
        
        return wsVersion;
    }
    
    if (m_mask & PROD_WIN2K)
    {
        wstring wsVersion = L"";
        
        if (m_mask & PROD_SP0)
            wsVersion = L"Windows 2000 Gold";
        else if (m_mask & PROD_SP1)
            wsVersion = L"Windows 2000 Service Pack 1";
        else if (m_mask & PROD_SP2)
            wsVersion = L"Windows 2000 Service Pack 2";
        else if (m_mask & PROD_SP3)
            wsVersion = L"Windows 2000 Service Pack 3";
        else if (m_mask & PROD_SP4)
            wsVersion = L"Windows 2000 Service Pack 4";
        else if (m_mask & PROD_SP5)
            wsVersion = L"Windows 2000 Service Pack 5";
        
        return wsVersion;
    }
    
    if (m_mask & PROD_WIN2K3)
    {
        //sersok x64
        wstring wsVersion = L"Windows Server 2003 ";
        if (m_mask & PROD_WIN2K3_x64)
            wsVersion += L"x64 ";
        
        if (m_mask & PROD_SP0)
            wsVersion += L"Gold";
        else if (m_mask & PROD_SP1)
            wsVersion += L"Service Pack 1"; //valeri
        else if (m_mask & PROD_SP2)
            wsVersion += L"Service Pack 2"; //Sersok
        else if (m_mask & PROD_SP3)
            wsVersion += L"Service Pack 3"; //air
        //sersok x64 end
        
        return wsVersion;
    }
    
    if (m_mask & PROD_NT4TS)
    {
        wstring wsVersion = L"";
        
        if (m_mask & PROD_SP0)
            wsVersion = L"Windows NT 4 Terminal Server Gold";
        else if (m_mask & PROD_SP4)
            wsVersion = L"Windows NT4 Terminal Server Service Pack 4";
        else if (m_mask & PROD_SP5)
            wsVersion = L"Windows NT4 Terminal Server Service Pack 5";
        else if (m_mask & PROD_SP6)
            wsVersion = L"Windows NT4 Terminal Server Service Pack 6";
        
        return wsVersion;
    }
    
    if ((m_mask & PROD_WINXPPRO) || (m_mask & PROD_WINXP_PR_x64))
    {
        wstring wsVersion = L"Windows XP ";//air add XP x64
=====================================================================
Found a 106 line (303 tokens) duplication in the following files: 
Starting at line 96 of D:\home\eCora_PM\PM\pmAnalysisWinProvider\Constants.cpp
Starting at line 437 of D:\home\eCora_PM\PM\pmCollectorWinProvider\OsUtils.cpp

        return PROD_STR_WINDOWS7_x64;
    // windows 7

    if (m_mask & PROD_IIS4)
        return L"Internet Information Server 4.0";
    
    if (m_mask & PROD_IIS5)
        return L"Internet Information Services 5.0";

    if (m_mask & PROD_IIS6)
        return L"Internet Information Services 6.0";
    
    if (m_mask & PROD_IE501)
        return L"Internet Explorer 5.01";
    
    if (m_mask & PROD_IE55)
        return L"Internet Explorer 5.5";
    
    if (m_mask & PROD_IE6)
        return L"Internet Explorer 6";

    if (m_mask & PROD_IE7)
        return L"Internet Explorer 7";
    
    if (m_mask & PROD_SQL7)
        return L"SQL Server 7.0";
    
    if (m_mask & PROD_SQL2K)
        return L"SQL Server 2000";

    if (m_mask & PROD_SQL2K5)
        return L"SQL Server 2005";
    
    if (m_mask & PROD_MSDE1)
        return L"SQL Server Desktop Engine (MSDE) 1.0";
    
    if (m_mask & PROD_MSDE2K)
        return L"SQL Server Desktop Engine (MSDE) 2000";
    
    if (m_mask & PROD_EXCHANGE55)
        return L"Exchange Server 5.5";
    
    if (m_mask & PROD_EXCHANGE2K)
        return L"Exchange 2000 Server";
    
    if (m_mask & PROD_EXCHANGE2K_ENT)
        return L"Exchange 2000 Enterprise Server";

    if (m_mask & PROD_EXCHANGE2K3)
	    return L"Exchange 2003 Server";

    if (m_mask & PROD_EXCHANGE2K3_ENT)
	    return L"Exchange 2003 Enterprise Server";

    if (m_mask & PROD_EXCHANGE2K7)
	    return L"Exchange 2007 Server";

    if (m_mask & PROD_EXCHANGE2K7_ENT)
	    return L"Exchange 2007 Enterprise Server";
    
    if (m_mask & PROD_OFFICE2K)
        return L"Office 2000";
    
    if (m_mask & PROD_OFFICEXP)
        return L"Office XP";
    
    //air
    if (m_mask & PROD_OFFICE2K3)
	return L"Office 2003";

    if (m_mask & PROD_OFFICE2K7)
	return L"Office 2007";
    //end air

    if (m_mask & PROD_WMP11)
	    return L"Windows Media Player 11.0";
   
    if (m_mask & PROD_WMP10)
        return L"Windows Media Player 10.0";
    
    if (m_mask & PROD_WMP9)
        return L"Windows Media Player 9.0";
    
    if (m_mask & PROD_WMP7_1)
        return L"Windows Media Player 7.1";
    
    if (m_mask & PROD_WMP7)
        return L"Windows Media Player 7.0";
    
    if ((m_mask & PROD_WMP6_4) && (m_mask & PROD_WIN2K))
        return L"Windows Media Player 6.4 for Windows 2000";
    
    if ((m_mask & PROD_WMP6_4) && (m_mask & PROD_NT4))
        return L"Windows Media Player 6.4 for Windows NT 4.0";
    
    if (m_mask & PROD_WMP6_4)
        return L"Windows Media Player 6.4";
    
    return L"";
}

//
//  Provide a short name (used only for OS)
//
wstring
GetMsProductNames::getMsShortName()
=====================================================================
Found a 31 line (299 tokens) duplication in the following files: 
Starting at line 167 of D:\home\eCora_PM\PM\pmDataProcessor\CustomProduct.cpp
Starting at line 200 of D:\home\eCora_PM\PM\pmDataProcessor\WindowsPatch.cpp

            registryChangeQuery.replace("@language", ws2qs(m_lang));

            // insert the <registryChange> nodes
            QSqlQuery qrQuery = getIDbManager()->exec(qs2ws(registryChangeQuery), false, getDbConnection());
            item = new CRegistryCacheItem();
        
            while (qrQuery.next())
            {
                DpContainer* registryChange = new DpContainer(L"RegistryChange", getIDbManager(), getDbConnection(), false);
                if (registryChange)
                {
                    registryChange->addAttribute(L"Path", qs2ws(qrQuery.value(0).toString()));
                    registryChange->addAttribute(L"KeyName", qs2ws(qrQuery.value(1).toString()));
                    registryChange->addAttribute(L"Type", qs2ws(qrQuery.value(2).toString()));
                    registryChange->addAttribute(L"Mode", qs2ws(qrQuery.value(3).toString()));
                    registryChange->addAttribute(L"ExpectedValue", qs2ws(qrQuery.value(4).toString()));
                    registryChanges.addContainer(registryChange);

                    cRegCacheElement* pRegCache = new cRegCacheElement();

                    pRegCache->path = qs2ws(qrQuery.value(0).toString());
                    pRegCache->keyName = qs2ws(qrQuery.value(1).toString());
                    pRegCache->type = qs2ws(qrQuery.value(2).toString());
                    pRegCache->mode = qs2ws(qrQuery.value(3).toString());
                    pRegCache->expectedValue = qs2ws(qrQuery.value(4).toString());
        
                    item->m_vRegCache.push_back(pRegCache);
                    item->empty = false;
                }
            }
            m_queriesProvider->getCaches()->m_dcRegistry->putItem(key, item);
=====================================================================
Found a 31 line (299 tokens) duplication in the following files: 
Starting at line 91 of D:\home\eCora_PM\PM\pmDataProcessor\CustomProduct.cpp
Starting at line 124 of D:\home\eCora_PM\PM\pmDataProcessor\WindowsPatch.cpp

            fileChangeQuery.replace("@language", ws2qs(m_lang));

            // insert the <fileChange> nodes
            QSqlQuery qfQuery = getIDbManager()->exec(qs2ws(fileChangeQuery), false, getDbConnection());
            item = new CFileCacheItem();

            while (qfQuery.next())
            {
                DpContainer* fileChange = new DpContainer(L"FileChange", getIDbManager(), getDbConnection(), false);
                if (fileChange)
                {
                    fileChange->addAttribute(L"Path", qs2ws(qfQuery.value(0).toString()));
                    fileChange->addAttribute(L"Version", qs2ws(qfQuery.value(1).toString()));
                    fileChange->addAttribute(L"Revision", qs2ws(qfQuery.value(2).toString()));
                    fileChange->addAttribute(L"CommandId", qs2ws(qfQuery.value(3).toString()));
                    fileChange->addAttribute(L"Checksum", qs2ws(qfQuery.value(4).toString()));
                    fileChanges.addContainer(fileChange);

                    cFileCacheElement* pFileCache = new cFileCacheElement();
                    pFileCache->path = qs2ws(qfQuery.value(0).toString());
                    pFileCache->version = qs2ws(qfQuery.value(1).toString());
                    pFileCache->revision = qs2ws(qfQuery.value(2).toString());
                    pFileCache->commandID = qs2ws(qfQuery.value(3).toString());
                    pFileCache->checksum = qs2ws(qfQuery.value(4).toString());
            
                    item->m_vFileCache.push_back(pFileCache);
                    item->empty = false;
                    
                }
            }
            m_queriesProvider->getCaches()->m_dcFile->putItem(key, item);
=====================================================================
Found a 67 line (299 tokens) duplication in the following files: 
Starting at line 24 of D:\home\eCora_PM\PM\dtdSvc\DtdSvc.cpp
Starting at line 226 of D:\home\eCora_PM\PM\dtd\Dtd.cpp

class CmdLineParser
{
    int m_argc;
    TCHAR** m_argv;
  public:
    CmdLineParser(int& argc, TCHAR**& argv, TCHAR* cmdline)
    {
        argc = 0;
        argv = 0;
        vector<int> argsizes;
        int len = 0;
        for (int i = 0; i < _tcslen(cmdline); i++)
        {
            if (cmdline[i] == L' ')
            {
                argsizes.push_back(len);
                len = 0;
            }
            else
            {
                len++;
            }
        }
        if (len)
        {
            argsizes.push_back(len);
        }
        if (!argsizes.empty())
        {
            argv = new TCHAR*[argsizes.size()];
            argv[argc] = new TCHAR[argsizes[argc] + 1];
            TCHAR* ptr = argv[argc];
            for (i = 0, argc = 0; i < _tcslen(cmdline); i++)
            {
                if (cmdline[i] != L' ')
                {
                    *ptr++ = cmdline[i];
                }
                else
                {
                    *ptr = 0;
                    argc++;
                    argv[argc] = new TCHAR[argsizes[argc] + 1];
                    ptr = argv[argc];
                }
            }
            *ptr = 0;
            argc = argsizes.size();
        }

        m_argc = argc;
        m_argv = argv;
    }

    ~CmdLineParser()
    {
        for (int i = 0; i < m_argc; i++)
        {
            delete[] m_argv[i];
        }

        if (m_argv)
        {
            delete[] m_argv;
        }
    }
};
=====================================================================
Found a 59 line (294 tokens) duplication in the following files: 
Starting at line 2364 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 963 of D:\home\eCora_PM\PM\patchRepository\WinSolRepoSettings.cpp

bool WinSolRepoSettings::save()
{
    log(L"patchRepository", Log::Debug, L"Enter WinSolRepoSettings::save");
    bool needToSave = false;

    if (!checkValidity())
    return false;
    log(L"patchRepository", Log::Debug, L"Validity check passed");

    m_repositories.clear();
    
    // BUG FIX #14035 by Yuri Kovalenko ->
    vector<RepositorySettings*> repositories;
    try
    {
        RepositoryQuery rq(m_services);
        repositories = rq.select();
    }
    catch (GenericException& e)
    {
        log (L"patchRepository", Log::Error, L"Warning: No data source specified: "
            << e.userMessage());
    }

    for (int i = 0; i < repositories.size(); ++i)
    {
        if (repositories[i]->systemType() == L"windows")
        {
            if (m_originalWindowsSettings == 0)
                m_originalWindowsSettings = static_cast<WindowsRepositorySettings*> (repositories[i]);
            break;
        }
    }
    for (i = 0; i < repositories.size(); ++i)
    {
        if (repositories[i]->systemType() == L"solaris")
        {
            if (m_originalUnixSettings == 0)
                m_originalUnixSettings = static_cast<UnixRepositorySettings*> (repositories[i]);
            break;
        }
    }
    // BUG FIX #14035 by Yuri Kovalenko <-

    // save settings
    WindowsRepositorySettings* windowsSettings = 0;
    if (m_winWidget->m_enableWindows->isChecked())
    {
        log(L"patchRepository", Log::Debug, L"Windows repository enabled");
        wstring id = qs2ws(m_winWidget->m_windowsRepository->text());
        wstring path = qs2ws(m_winWidget->m_windowsRepository->text());

        //Sergey Sokolov - fix bug 14378 ->
        path = convertSlashes(path);
        id = convertSlashes(id);
        //Sergey Sokolov - fix bug 14378 <-

        windowsSettings = new WindowsRepositorySettings(m_services, id,
        path, L"windows", L"windows");
=====================================================================
Found a 57 line (293 tokens) duplication in the following files: 
Starting at line 143 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\Patch.cpp
Starting at line 125 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\SqlPatch.cpp

SqlPatch::prepareForPushConventional(int* id, const wstring& netDir, bool useRepo, bool transferOnly, xml::Node* actionSeq)
{
    using namespace winPushActions;
    wstring patchDir;
    if (transferOnly)
    {
        patchDir = L"transfer";
    }
    else
    {
        patchDir = wsIndex();
    }
    wstring patchFullPath = netDir + patchDir + L"\\";

    if (status() != pmPushBaseModel::IPatch::Ok)
    {
        return 0;
    }

    if (pushActions())
    {
        //FIXME
    }
    actionSeq->push_back(CreateDirectoryAction::representation((*id)++, netDir, patchDir, true));
    
    HRESULT hr;
    patchRepository::IRepositoryManager* repo = 0;
    hr = appIface()->QueryInterface(IID_IRepositoryManager, reinterpret_cast<void**>(&repo));
    if (FAILED(hr))    
    {
        throw GenericException(__FILE__, __LINE__, L"Patch::prepareForPush", 
                                L"", L"Failed to obtain an interface to the repository.");        
    }

    wstring repoPath = repo->uncPath(langKey(), getPmSelectData()->getHostId(),
        pmPushBaseModel::IComputer::Conventional); // AltRepo FIX by StUV
    
    if (!repoPath.empty())
    {
        wstring dir = repoPath + L"\\";
        setFullRepoPath(dir + displayName());
        setDir(dir);
    }

    unsigned long size = 0;
    if (!useRepo || transferOnly)
    {
        actionSeq->push_back(RepoMoveAction::representation((*id)++, 
            langKey(), getPmSelectData()->getHostId(), patchFullPath, displayName()));
        size = repo->patchSize(langKey());
    }
    repo->Release();

    return size;
}

unsigned long 
=====================================================================
Found a 209 line (286 tokens) duplication in the following files: 
Starting at line 41 of D:\home\eCora_PM\PM\network\PtyConnection.h
Starting at line 41 of D:\home\eCora_PM\PM\network\network\PtyConnection.h

using namespace smuggle;

namespace network {
  
class smuggle::Smuggler;
class smuggle::UnixDriver;

/*
 * Base class used as a terminal connection to a remote machine.
 */
class PtyConnection
{    
  public:
    PtyConnection(IUnknown* = 0);
    virtual ~PtyConnection();

    //  Connection responses to things such as login.
    enum
    { 
        QUESTION,
	USER,
	PASSWORD,
	PROMPT,
	FAILURE,
	ACCESS_DENIED,
	UID,
	ALMOST,
	TRANSFER_COMPLETE
    };

    //  Each terminal connection type (Telnet or Ssh) needs to implement a
    //  unique connection method.   All the parameters necessary to make
    //  a connection are encapsulated in the UnixDevice class.
    virtual void connect(const LoginParameters*const) = 0;
    
    /*
     * Attempts to login to the remote device and
     * provide a "clean" shell /bin/sh.
     * @param userName is the accounts login name.
     * @param password is the accounts password value.
     */
    void login(const bstring& userName, const bstring& password);

    /*
     *  No login necessary.  Just look for a prompt.
     */
    void loginWithoutUsernamePassword();

    /*
     *  Delay and search for prompt will delay n seconds and then
     *  search for the prompt provided.  The software will look for
     *  a prompt to be returned from the pty client and will timeout
     *  if none is found in the time alloted.
     *  If the prompt string is empty the software will assume a 
     *  connecion has been made.
     *  @param time in seconds to wait before searching for the prompt.
     *  @param prompt string to serach for before returning.  
     *  @param timeout is the number of milliseconds to wait for the prompt.
     */
     void delayAndWaitForPrompt(const int delay, const bstring& prompt,
         const int timeout);
    
    /*
     * Send a message to the remote device.
     * @param Message to be sent.
     */
    void send(const bstring message);

    /*
     * Return whatever data is in the current receive buffer.
     * @return bstring data that is currently available.
     */
    bstring getBuffer();
    
    /*
     * Send the string used to make the connection.  For display purposes.
     * @return The string the was sent.
     */
    wstring getConnectionString() { return m_connectionString; }

    /*
     * Return true if a valid connection has been made,
     * false otherwise.
     */
    bool connected() { return m_connected; }

    /*
     * Return the host name of the device that we are connected to.
     * @return hostName.
     */
    wstring hostName() { return m_hostName; }

    /*
     * Return the name of the user who has made the connection.
     * @return userName.
     */
    wstring userName() { return m_userName; }
    
    /*
     * Set the software installation directory.  The default is set to
     * "." This call will overide the default.
     * @param The installation directory.
     */
    void setInstallationDirectory(wstring installationDirectory);

    /*
     * Set the maximum amount of time to wait for a response from
     * the remote device.
     * @param Time in seconds.
     */
    void setTimeout(const int seconds);

    /*
     * Get the direcory where we are looking for the binaries.
     * @return directory name.
     */
    wstring getBinDirectory() 
    { return m_binDirectory; }

    /*
     * Set the directory where we are looking for the binaries.
     * @param Current directory.
     */
    void setBinDirectory(wstring binDirectory) 
    { m_binDirectory = binDirectory; }
    
    /*
     * Runtime timeout values.
     */
    enum {
        ONE_SECOND_TIMEOUT = 1,
        TEN_SECOND_TIMEOUT = 10,
        TWENTY_SECOND_TIMEOUT = 20,
        THIRTY_SECOND_TIMEOUT = 30,
        TWO_MINUTE_TIMEOUT = 120,
        FIVE_MINUTE_TIMEOUT = 300
    };

    /*
     * RETRIES: The number of  attempts to get an error free response
     * Two is typical and should cover anything that might be
     * causing problems.  Three is probably pushing it, and anything
     * more is a waste of time (authors opinion.)
     */
    enum {
        ONE_RETRY = 1,
        TWO_RETRIES = 2,
        THREE_RETRIES = 3
    };


  protected:    
    UnixDriver m_driver;
    Smuggler* m_host;    
    IUnknown * m_appIface;

    /*
     * The string that was used to make the connection.  This
     * member is stored as the actual string used less any
     * sensitive information such as passwords which show
     * as stars...
     */
    wstring m_connectionString;
    
    /*
     *  Kill the connection.
     */
    void deleteHost(void);

    /*
     * Indicates that this device is currently connected (or not).
     */
    bool m_connected;

    /*
     * If we are connected this contains the hostname of the device
     * we are currently connecto to.
     */
    wstring m_hostName;

    /*
     * The type of host that we are connected to.
     * Sun, Linux, Hpux, Aix, etc.
     */
    wstring m_hostType;

    /*
     *  If we are connected this is the name of the user who is connected.
     */
    wstring m_userName;
    
    /*
     * The directory that the software is currently being stored at.
     */
    wstring m_installationDirectory;
    
    /*
     * The directory where the binaries are located.  This directory is,
     * by default, the installation directory + /bin.  The software can
     * change this settting.
     */
    wstring m_binDirectory;

  private:
      void throwLoginException(const bstring& failureString);
    
};

} //  End namespace connections
=====================================================================
Found a 81 line (285 tokens) duplication in the following files: 
Starting at line 135 of D:\home\eCora_PM\PM\pmOAService\CommandLine.cpp
Starting at line 137 of D:\home\eCora_PM\PM\pmWindowsService\CommandLine.cpp

    return;   

    while ((c = options.next(L"z:h:u:b:d:s:")) != WEOF)
    {
        switch (c)
        {
            case L'h':
            {
                m_mode = MODE_HELP;
                m_topic = options.optarg();
                break;
            }

            case L'z':
            {
                m_mode = MODE_PUSHBATCH;
                m_topic = options.optarg();
                break;
            }

            case 'u': //updates
            {
                m_mode = MODE_UPDATE;
                if (!options.optarg())
                {
                    log(L"checkOptions", Log::Error, L"Invalid argument for patch database update");
                    throw GenericException(__FILE__, __LINE__, L"CommandLine::CommandLine", L"",
                        L"Invalid argument for patch database update");
                }

                m_topic = options.optarg();

                if (0 != m_topic.compare(L"check") &&
                    0 != m_topic.compare(L"download") &&
                    0 != m_topic.compare(L"install"))
                {
                    log(L"checkOptions", Log::Error, L"Invalid argument for patch database update");
                    throw GenericException(__FILE__, __LINE__, L"CommandLine::CommandLine", L"",
                        L"Invalid argument for patch database update");
                }
                break;
            }

            case 'b': // batch
            {
                m_mode = MODE_BATCH;
                m_topic = options.optarg();
                break;
            }

            case 'd': // download
            {
                m_mode = MODE_DOWNLOAD;      
                
		if (!options.optarg())
                {
                    log(L"checkOptions", Log::Error, L"Invalid argument for patch download");
                    throw GenericException(__FILE__, __LINE__, L"CommandLine::CommandLine", L"",
                        L"Invalid argument for patch download");
                }

                m_topic = options.optarg();

                break;
            }

            case 's': // scheduled repository maintenance
            {
                m_mode = MODE_REPOMAINTENANCE;
                m_topic = options.optarg();
                break;
            }

            default:
            {
                throw GenericException(__FILE__, __LINE__, L"errors - command line", L"",
                    L"Invalid arguments to program.");
            }
        }
    }
}
=====================================================================
Found a 57 line (283 tokens) duplication in the following files: 
Starting at line 83 of D:\home\eCora_PM\PM\pmServices\DbManager.cpp
Starting at line 72 of D:\home\eCora_PM\PM\utils\IPCMutex.cpp

IPCMutex::ObtainAccessableMutex(BOOL bInitialOwner, LPCTSTR szName)
{
    SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    PSID psidEveryone = NULL;
    HANDLE hMutex = NULL;
    PACL paclNewDacl = NULL;

    __try{
	// Create the everyone sid
	if (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0,
					  0, 0, 0, 0, 0, 0, &psidEveryone))
	{
	    psidEveryone = NULL ;
	    __leave;
	}

	int nSidSize = GetLengthSid(psidEveryone);
	int nAclSize = nSidSize * 2 + sizeof(ACCESS_ALLOWED_ACE) + sizeof(ACCESS_DENIED_ACE) + sizeof(ACL);
	paclNewDacl = (PACL) LocalAlloc(LPTR, nAclSize);
	if (!paclNewDacl)
	   __leave;
	if (!InitializeAcl(paclNewDacl, nAclSize, ACL_REVISION))
	   __leave;
	if (!AddAccessDeniedAce(paclNewDacl, ACL_REVISION, WRITE_DAC | WRITE_OWNER, psidEveryone))
	   __leave;
	// I am using GENERIC_ALL here so that this very code can be applied to
	// other objects. Specific access should be applied when possible.
	if (!AddAccessAllowedAce(paclNewDacl, ACL_REVISION, GENERIC_ALL, psidEveryone))
	   __leave;

	SECURITY_DESCRIPTOR sd;
	if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
	   __leave;
	if (!SetSecurityDescriptorDacl(&sd, TRUE, paclNewDacl, FALSE))
	   __leave;

	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(sa);
	sa.bInheritHandle = FALSE;
	sa.lpSecurityDescriptor = &sd;

	hMutex = CreateMutex(&sa, bInitialOwner, szName);
	if (!hMutex)
	   hMutex = OpenMutex(SYNCHRONIZE, FALSE, szName);
    }
    __finally
    {
	if (!paclNewDacl)
	   LocalFree(paclNewDacl);
	if (!psidEveryone)
	   FreeSid(psidEveryone);
    }

   return hMutex ;
}

bool
=====================================================================
Found a 51 line (281 tokens) duplication in the following files: 
Starting at line 922 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 810 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::loadSystems");
    
    // internal database
    CComQIPtr<com::IAppDatabase> pAppDatabase(g_App->services());
    _IfNullPtrRet(pAppDatabase);

    // systems container
    CComPtr<com::IDbContainer> pDbContainer;
    HRESULT hr = pAppDatabase->getDbContainer(&pDbContainer);
    _IfFailHrRet(hr);

    // load systems
    if (!devicesNode.isNull())
    {
        QDomElement element = devicesNode.firstChild().toElement();
        while (!element.isNull())
        {
            QString qsKey = element.attributeNode(SystemID).value();
            QString qsClass = element.attributeNode(SystemClass).value();
            if (qsKey.length() && qsClass.length())
            {
                hr = pDbContainer->registerObjectType(qsClass);
                if (FAILED(hr))
                {
                    _ASSERTE(0);
                    continue;
                }

                idb::WindowsDevice device(g_App->services());
                if (device.getObjectType() == qsClass)
                {
                    hr = pDbContainer->retrieveObject(qsKey, &device);
                    if (SUCCEEDED(hr))
                    {
                        selected[qs2ws(qsKey)] = device.clone(true);
                    }
                }
                else
                {
                    idb::UnixDevice device(g_App->services());
                    hr = pDbContainer->retrieveObject(qsKey, &device);
                    if (SUCCEEDED(hr))
                    {
                        selected[qs2ws(qsKey)] = device.clone(true);
                    }
                }
            }
            element = element.nextSibling().toElement();
        }
    }
    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::loadSystems, exiting");
=====================================================================
Found a 74 line (280 tokens) duplication in the following files: 
Starting at line 28 of D:\home\eCora_PM\PM\solaris-collector\UnixCollectExceptions.h
Starting at line 42 of D:\home\eCora_PM\PM\unix-collector\UnixCollectExceptions.h

	GenericException(L"unix-collector::Invalid Test File",
			 file, line, function, parameters, message)
    {}
};


class RemoteLoginError : public GenericException
{
  public:
    RemoteLoginError(const char* file,
		   const int line,
		   const wstring& function,
		   const wstring& parameters,
		   const wstring& message) :
	GenericException(L"unix-collector::Remote login error",
			 file, line, function, parameters, message)
    {}
};


class InvalidRootPasswordError : public GenericException
{
  public:
    InvalidRootPasswordError(const char* file,
		   const int line,
		   const wstring& function,
		   const wstring& parameters,
		   const wstring& message) :
	GenericException(L"unix-collector::Invalid root password error",
			 file, line, function, parameters, message)
    {}
};

class DuplicateHostIDError : public GenericException
{
  public:
    DuplicateHostIDError(const char* file,
		   const int line,
		   const wstring& function,
		   const wstring& parameters,
		   const wstring& message) :
	GenericException(L"unix-collector::Duplicate host id",
			 file, line, function, parameters, message)
    {}
};


class ShellCommandError : public GenericException
{
  public:
    ShellCommandError(const char* file,
		   const int line,
		   const wstring& function,
		   const wstring& parameters,
		   const wstring& message) :
	GenericException(L"unix-collector::Shell command error",
			 file, line, function, parameters, message)
    {}
};



class ScratchFileError : public GenericException
{
  public:
    ScratchFileError(const char* file,
		   const int line,
		   const wstring& function,
		   const wstring& parameters,
		   const wstring& message) :
	GenericException(L"unix-collector::Unable to create a tmp file.",
			 file, line, function, parameters, message)
    {}
};
=====================================================================
Found a 83 line (279 tokens) duplication in the following files: 
Starting at line 465 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketClient.cpp
Starting at line 460 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketServer.cpp

CSocketServer::WorkerThread::Run()
{
    try
    {
        while (true)   
        {
            // continually loop to service io completion packets
            bool closeSocket = false;
            DWORD dwIoSize = 0;
            Socket* pSocket = 0;
            CIOBuffer* pBuffer = 0;
            
            try
            {
                m_iocp.GetStatus((PDWORD_PTR)&pSocket, &dwIoSize, (OVERLAPPED**)&pBuffer);
            }
            catch (const CWin32Exception &e)
            {
                if (e.GetError() != ERROR_NETNAME_DELETED && e.GetError() != WSA_OPERATION_ABORTED)
                {
                    throw;
                }
                //Output(_T("IOCP error - client connection dropped"));
                closeSocket = true;
            }

            if (!pSocket)
            {
                // A completion key of 0 is posted to the iocp to request us to shut down...
                break;
            }

            OnBeginProcessing();
                
            if (pBuffer)
            {
                const IO_Operation operation = static_cast<IO_Operation>(pBuffer->GetUserData());
                switch (operation)
                {
                    case IO_Read_Request :
                        Read(pSocket, pBuffer);
                        break;
                                
                    case IO_Read_Completed :
                        if (0 != dwIoSize)
                        {
                            pBuffer->Use(dwIoSize);
                            ReadCompleted(pSocket, pBuffer);
                        }
                        else
                        {
                            // client connection dropped...
                            //Output(_T("ReadCompleted - 0 bytes - client connection dropped"));
                            closeSocket = true;
                        }
                        pSocket->Release();
                        pBuffer->Release();
                        break;
                                    
                    case IO_Write_Request :
                        Write(pSocket, pBuffer);
                        if (dwIoSize != 0)
                        {
                            // final write, now shutdown send side of connection
                            pSocket->Shutdown(SD_SEND);
                        }
                        break;
                                
                    case IO_Write_Completed :
                        pBuffer->Use(dwIoSize);
                        WriteCompleted(pSocket, pBuffer);
                        pSocket->Release();
                        pBuffer->Release();
                        break;
                            
                    case IO_Close :
                        AbortiveClose(pSocket);
                        pSocket->Release();
                        pBuffer->Release();
                        break;

                    default :
                        OnError(_T("CSocketServer::WorkerThread::Run() - Unexpected operation"));
=====================================================================
Found a 53 line (276 tokens) duplication in the following files: 
Starting at line 102 of D:\home\eCora_PM\PM\utils\Registry.cc
Starting at line 113 of D:\home\eCora_PM\PM\utils\RemoteRegistry.cpp

    status = RegOpenKeyEx(m_remoteKey, key.c_str(), 0, KEY_READ, &openKey.get());
    
    if (status != ERROR_SUCCESS)
	throw WinErrorException(
	    __FILE__, __LINE__, L"RegOpenKeyEx", status, fullkey);
    
    
    // Find the max data length for that key
    DWORD maxValueLen;
    status = RegQueryInfoKey(
	openKey.get(), NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	&maxValueLen, NULL, NULL);
    
    if (status != ERROR_SUCCESS)
	throw WinErrorException(
	    __FILE__, __LINE__, L"RegQueryInfoKey", status, fullkey);
    
    // Set up the buffer to retrieve the value into
    auto_ptr<BYTE> dataArray(new BYTE[maxValueLen + 2]);
    memset(dataArray.get(), 0, maxValueLen + 2);
    
    // Retrieve the value of the subkey
    DWORD type, length;
    length = maxValueLen + 2;
    status = RegQueryValueEx(
	openKey.get(), valueName, 0, &type, dataArray.get(), &length);
    
    if (status != ERROR_SUCCESS)
    {
	throw WinErrorException(
	    __FILE__, __LINE__, L"RegQueryValueEx", status, fullkey);
    }
    
    // Cast the value according to the type
    if (type == REG_SZ)
    {
	wstring s(reinterpret_cast<wchar_t*>(dataArray.get()));
	return Variant(s);
    }
    else if (type == REG_DWORD)
    {
	int i;
	memcpy(&i, dataArray.get(), sizeof(int));
	return Variant(i);
    }
    else
    {
	throw GenericException(
	    __FILE__, __LINE__, L"Registry::value", fullkey, 
	    L"Value type not supported.");
	return Variant(0);
    }
}
=====================================================================
Found a 23 line (274 tokens) duplication in the following files: 
Starting at line 35 of D:\home\eCora_PM\PM\pmDaoBase\CustomProductDao.h
Starting at line 35 of D:\home\eCora_PM\PM\pmDaoBase\ProductDao.h

    wstring getDaoId() const { return L"IProduct"; }

    wstring getVersionId() const { return getAttrValue(L"VersionId"); }
    wstring getSystemScanId() const { return getAttrValue(L"SystemScanId"); }
    wstring getName() const { return getAttrValue(L"ProductName"); }
    wstring getShortName() const { return getAttrValue(L"ProductShortName"); }
    wstring getVersion() const { return getAttrValue(L"Version"); }
    wstring getInstance() const { return getAttrValue(L"Instance"); }
    wstring getLocation() const { return getAttrValue(L"Location"); }
    wstring getLanguage() const { return getAttrValue(L"ProductLanguage"); }
    wstring getStatus() const { return getAttrValue(L"Status"); }

    void setVersionId(const wstring& value) { setAttr(L"VersionId", value); }
    void setSystemScanId(const wstring& value) { setAttr(L"SystemScanId", value); }
    void setName(const wstring& value) { setAttr(L"ProductName", value); }
    void setShortName(const wstring& value) { setAttr(L"ProductShortName", value); }
    void setVersion(const wstring& value) { setAttr(L"Version", value); }
    void setInstance(const wstring& value) { setAttr(L"Instance", value); }
    void setLocation(const wstring& value) { setAttr(L"Location", value); }
    void setLanguage(const wstring& value) { setAttr(L"ProductLanguage", value); }
    void setStatus(const wstring& value) { setAttr(L"Status", value); }

    pmDaoInterfaces::IPatch* addPatch()
=====================================================================
Found a 72 line (271 tokens) duplication in the following files: 
Starting at line 16 of D:\home\eCora_PM\PM\network\GeneralClient.h
Starting at line 16 of D:\home\eCora_PM\PM\network\network\GeneralClient.h

namespace network {

class HttpLogin;
class Http;
class Ftp;

/**
 * The GeneralClient class encapsulates all of the known clients 
 * so that one object can be used for all network communication.
 */
class GeneralClient : public com::INetwork
{
  public:

    /**
     * @param cookies the location to store the HTTP cookies
     * @param userAgentLocation the location in the registry to 
     * find (or set) the user agent string to use for HTTP connections.
     * If it is empty, no user agent will be used.
     */
    GeneralClient(const wstring& cookies, 
                  const wstring& userAgentLocation, 
                  IUnknown* pUnkOuter = 0);
    virtual ~GeneralClient();

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(
	const GUID& iid, void** ptr);
    virtual unsigned long STDMETHODCALLTYPE AddRef();
    virtual unsigned long STDMETHODCALLTYPE Release();


    /**
     * See com/INetwork.h for a description of the following functions.
     */

    virtual bool url2wstring(
        const wstring& url, wstring* content = 0, 
        bool runInThread = true, com::NetworkResult** result = 0);
    virtual bool url2file(
        const wstring& url, const wstring& file, 
        bool runInThread = true, com::NetworkResult** result = 0);
    virtual void useProxy(const wstring& addr, const wstring& login, 
        const wstring& pass, const bool useNTLM);
    virtual void setCredentials(const wstring& login, const wstring& pass);
    virtual void addListener(com::NetworkListener* listener);
    virtual void removeListener(com::NetworkListener* listener);
    virtual void abort();
    virtual void freeResult(com::NetworkResult* result) const;
    
    // Used only during HTTP communications
    void addLoginAgent(HttpLogin* login);
    void removeLoginAgent(HttpLogin* login);
    
    /**
     * @return the HTTP subclient
     */
    Http* http() { return m_http; }
    
    /**
     * @return the FTP subclient
     */
    Ftp* ftp() { return m_ftp; }

  private:

    Http* m_http;
    Ftp* m_ftp;
    com::BaseObject m_comBase;
};


} // namespace network
=====================================================================
Found a 48 line (270 tokens) duplication in the following files: 
Starting at line 76 of D:\home\eCora_PM\PM\pmAnalysisWinProvider\WindowsPatchManagerTest.cpp
Starting at line 146 of D:\home\eCora_PM\PM\pmAnalysisWinProvider\WindowsPatchManagerTest.cpp

	PRODUCT_IIS); 

    // get the info about the host and its installed products
    pmAnalysisWinProvider::ComputerInfo *pcInfo = winScanHost->computerInfo();
    
    // display info
    for (int i = 0; i < pcInfo->getNoProducts(); ++i)
    {
	pmAnalysisWinProvider::DisplayWindowsDB db = pcInfo->getDB(i);
	pmAnalysisWinProvider::ProductInfoContainer pic = 
	    pcInfo->getProductInfo();
	wcerr << L"Product Name: " << pic[i].nameProduct;
	wcerr << endl;
	wcerr << L"Service Pack: " << pic[i].servicePack << endl;
	wcerr << L"DB Info: " << endl;
	for (int j = 0; j < db.size(); ++j)
	{
	    wcerr << L"\t";
	    wcerr << L"Bulletin: " << db[j].getBulletinID() << L"   ";
	    wcerr << L"Service Pack Name: " << db[j].getPatchName();
	    wcerr << L"   ";
	    wcerr << L"Hotfix: " << db[j].getSqNumber();
	    wcerr << L"   ";
	    wcerr << L"Installed: " << db[j].getInstalled();
	    wcerr << L"   ";
	    wcerr << L"Status: " << db[j].status();
	    wcerr << L"   ";
	    wcerr << L"Required: " << db[j].isRequired();
	    wcerr << L"   ";
	    wcerr << L"URL: " << db[j].url();
	    wcerr << endl;
	}
	wcerr << L"---------------------" << endl;
    }

    // deallocated WinScanHost struct (pcInfo is implicitly deallocated)
    delete winScanHost;
    winScanHost = 0;

    }
    catch (...)
    {
	log(L"windows-patch-manager-test", Log::Error, L"Top Level");
	return 1;
    }

    return 0;
}
=====================================================================
Found a 44 line (268 tokens) duplication in the following files: 
Starting at line 1010 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 898 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::loadGroupSystems");
    // internal database
    CComQIPtr<com::IAppDatabase> pAppDatabase(g_App->services());
    _IfNullPtrRet(pAppDatabase);

    // systems container
    CComPtr<com::IDbContainer> pDbContainer;
    HRESULT hr = pAppDatabase->getDbContainer(&pDbContainer);
    _IfFailHrRet(hr);

    // load systems
    if (!groupsNode.isNull())
    {
        // register container for groups
        hr = pDbContainer->registerObjectType((IUnknown*)&idb::GroupObject());
        _IfFailHrRet(hr);

        QDomElement element = groupsNode.firstChild().toElement();
        while (!element.isNull())
        {
            QString qsKey = element.attributeNode(GroupID).value();
            if (qsKey.length())
            {

                CComPtr<com::IDbRelation> pRelation;
                hr = pAppDatabase->getDbRelation(&pRelation);
                _IfFailHrRet(hr);

                QPtrVector<IUnknown> systems;
                hr = pRelation->getRelatedObjects((IUnknown*)&idb::GroupObject(qsKey), systems);
                if (SUCCEEDED(hr))
                {
                    for (int idx = 0; idx < systems.count(); ++idx)
                    {
                        com::IDbObject* pSystem = (com::IDbObject*)systems[idx];
                        _ASSERTE(pSystem);
                        selected[qs2ws(pSystem->getKeyAsString())] = pSystem->clone(true);
                    }
                }
            }
            element = element.nextSibling().toElement();
        }
    }
    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::loadGroupSystems, exiting");
=====================================================================
Found a 61 line (267 tokens) duplication in the following files: 
Starting at line 598 of D:\home\eCora_PM\PM\patchManager\SettingsDlg.cpp
Starting at line 674 of D:\home\eCora_PM\PM\patchManager\main.cpp

        restoreConfigDialog(g_App);
        //Sersok fix 27623
        {
            wstring defaultDsn;
            wstring defaultDb;
            com::ISettings* settings;
            g_App->services()->QueryInterface(IID_ISettings, (void**)&settings);
            if (settings != 0)
            {
                defaultDsn = settings->getDefaultDsn();
                defaultDb = settings->getDefaultDbName();
            }
            
            sql::Dsn pmDsn(g_App->services(), 0,
                defaultDsn, g_defInstance, defaultDb);
            
            pmDsn.readDsn();
            
            QSqlDatabase* pmDB = QSqlDatabase::addDatabase("QODBC3", "fix");
            pmDB->setDatabaseName(ws2qs(pmDsn.dsnSettings()->source));
            pmDB->setUserName(ws2qs(pmDsn.dsnSettings()->userName));
            pmDB->setPassword(ws2qs(pmDsn.dsnSettings()->password));
            if (pmDB->open()) 
            {
                QString sqlStmt;
                QSqlQuery query;
                
                sqlStmt = "SELECT COLUMNPROPERTY(OBJECT_ID('WindowsSystem'), 'ResolveIP','PRECISION')";
                query = pmDB->exec(sqlStmt);
                if (query.next() && query.isNull(0))
                {
                    sqlStmt = "DROP VIEW dbo.WindowsSystemView";
                    pmDB->exec(sqlStmt);
                    sqlStmt = "ALTER TABLE WindowsSystem ADD ResolveIP NVARCHAR(255) NOT NULL DEFAULT '1'";
                    pmDB->exec(sqlStmt);
                    sqlStmt = "CREATE VIEW WindowsSystemView AS SELECT WindowsSystem.*, IdbAssociator.LeftObject "
                        "AS Object, IdbAssociator.LeftClass AS Class FROM IdbAssociator INNER JOIN WindowsSystem "
                        "ON IdbAssociator.RightObject = WindowsSystem.UniqueKey ";
                    pmDB->exec(sqlStmt);
                    
                }
                //air sept
                sqlStmt = "IF COLUMNPROPERTY( OBJECT_ID('windowsSystemExtension'),'programFilesDirX86','PRECISION') IS NULL \n" 
                    "ALTER TABLE windowsSystemExtension ADD programFilesDirX86 NVARCHAR(512) \n"
                    "IF COLUMNPROPERTY( OBJECT_ID('windowsSystemExtension'),'commonFilesDirX86','PRECISION') IS NULL \n" 
                    "ALTER TABLE windowsSystemExtension ADD commonFilesDirX86 NVARCHAR(512) \n";
                pmDB->exec(sqlStmt);

                //air 2010 july
                sqlStmt = "IF COLUMNPROPERTY( OBJECT_ID('properties'),'ID','PRECISION') IS NULL "
                    "BEGIN CREATE TABLE properties (ID integer NOT NULL PRIMARY KEY, DisplayName nvarchar(512) NOT NULL, PlaceHolder nvarchar(128) NOT NULL, IsPsw bit DEFAULT 0) "
                     "CREATE TABLE patchProperty (patchFK nvarchar(256) NOT NULL, propertyFK integer NOT NULL) END";
                pmDB->exec(sqlStmt);

                //sersok 12.04.10
                sqlStmt = "IF COLUMNPROPERTY( OBJECT_ID('actionParameter'),'languageFK','PRECISION') IS NULL "
                    "BEGIN "
                    "ALTER TABLE actionParameter ADD languageFK NVARCHAR(256) NULL FOREIGN KEY REFERENCES language(id) ON DELETE CASCADE "
                    "ALTER TABLE actionParameter ALTER COLUMN value NVARCHAR(4000) NOT NULL "
                    "END";
                pmDB->exec(sqlStmt);
=====================================================================
Found a 39 line (265 tokens) duplication in the following files: 
Starting at line 958 of D:\home\eCora_PM\PM\winPushActions\DelayTaskAction.cpp
Starting at line 131 of D:\home\eCora_PM\PM\winPushActions\ScheduleTaskAction.cpp

    parameterNode->addAttribute(Value, encrypt(password));
    parametersNode->push_back(parameterNode);

    parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, Directory);
    parameterNode->addAttribute(Value, pwd);
    parametersNode->push_back(parameterNode);

    parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, Application);
    parameterNode->addAttribute(Value, application);
    parametersNode->push_back(parameterNode);

    parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, ArgString);
    parameterNode->addAttribute(Value, argstring);
    parametersNode->push_back(parameterNode);

    parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, TaskName);
    parameterNode->addAttribute(Value, taskName);
    parametersNode->push_back(parameterNode);

    parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, Text);
    parameterNode->addAttribute(Value, comment);
    parametersNode->push_back(parameterNode);
    parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, Time);
    parameterNode->addAttribute(Value, installTime);
    parametersNode->push_back(parameterNode);

    parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, InstallImmediate);
    parameterNode->addAttribute(Value, true == installImmediate ? L"true" : L"false");
    parametersNode->push_back(parameterNode);

    return actionNode;
}
=====================================================================
Found a 36 line (265 tokens) duplication in the following files: 
Starting at line 47 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\ComponentInstaller.cpp
Starting at line 87 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\ComponentInstaller.cpp

void ComponentInstaller::unregisterComponents(const InstallDB& db)
{
    typedef InsTable::ColumnCont ColumnCont;
    typedef InsTable::RowCont RowCont;
    typedef ColumnCont::size_type size_type;

    const InsTable& ct = db.getTable(EI::COMPONENTS_TABLE);
    const InsTable& ft = db.getTable(EI::FILES_TABLE);
    const tstring module_name = db.getModule().m_name;

    const RowCont& cr = ct.getRows();
    const RowCont& fr = ft.getRows();

    size_type c_kf_index = ct.index(EI::FILE_ATTR);
    size_type f_kf_index = ft.index(EI::FILE_ATTR);

    size_type c_t_index = ct.index(EI::COMPONENT_TYPE_ATTR);
    // FIXME : relative path or not?
    size_type f_fp_index = ft.index(EI::REL_PATH_ATTR);
    
    const InstallerConfig& config = InstallerConfig::instance();
    const tstring module_prefix = config.getProgramFilesFolder() + ECORA_TEXT("/") + module_name;

    std::vector<tstring> abs_pathes = InstallerUtils::absPathesFromFTable(ft,
                    module_prefix, config.getSharedFilesFolder());
    
    RowCont::const_iterator cr_cit = cr.begin();
    RowCont::const_iterator cr_end = cr.end();

    size_type size = fr.size();
    for (; cr_cit != cr_end; ++cr_cit)
    {
        for (size_type ii = 0; ii < size; ++ii)
        {
            if ((*cr_cit)[c_kf_index] == (fr[ii])[f_kf_index])
                InsComponentMgr::unregisterComponent(abs_pathes[ii], (*cr_cit)[c_t_index]);
=====================================================================
Found a 41 line (257 tokens) duplication in the following files: 
Starting at line 285 of D:\home\eCora_PM\PM\pmDbProvider\ScanWinPatchDbProvider.cpp
Starting at line 157 of D:\home\eCora_PM\PM\pmDbProvider\ScanWinSpDbProvider.cpp

    query.addSelectColumn(L"Tbl", L"ServicePackEncryption");
    //query.addSelectColumn(L"Tbl", L"PushException"); // #8889 MM
        //-------- Product info ---------
    query.addSelectColumn(L"Tbl", L"ProductVersionId");
    query.addSelectColumn(L"Tbl", L"VersionName");
    query.addSelectColumn(L"Tbl", L"ProductName");
    query.addSelectColumn(L"Tbl", L"ProductShortName");
    query.addSelectColumn(L"Tbl", L"InstanceName");
    query.printStatement();

    ScanWinSystemDbProvider  systemDbProvider(getDbMgr());
    ScanWinProductDbProvider productDbProvider(getDbMgr());

    wstring l_SystemScanID = L"";
    wstring l_ProductVersionId = L"";

    pmUI::WinSystemInfo* l_pWinSysInfo = NULL;
    pmUI::WinProductInfo* l_pWinProductInfo = NULL;

    wstring wsCurrentProductInstanceName;  // #8889 MM

    while (query.next())
    {
        //------- Load system info ------------
        if (!l_pWinSysInfo || l_SystemScanID != query.stringvalue(L"SystemScanID"))
        {
            l_SystemScanID = query.stringvalue(L"SystemScanID");
            l_pWinSysInfo = dynamic_cast<pmUI::WinSystemInfo*>(systemDbProvider.CreateSystemInfo(_wtoi(l_SystemScanID.c_str())));

            assert(l_pWinSysInfo);

            l_pWinSysInfo->setDomainName(query.stringvalue(L"DomainName"));

            //------------ loadSystemCommonInfo ----------
            l_pWinSysInfo->setSystemId(query.stringvalue(L"SystemID"));
            l_pWinSysInfo->setSystemName(query.stringvalue(L"HostName"));
            l_pWinSysInfo->setIpAddress(query.stringvalue(L"IpAddress"));
            l_pWinSysInfo->setOS(query.stringvalue(L"ComputerOs"));
            l_pWinSysInfo->setOsVersionId(query.stringvalue(L"OsVersionID"));
            l_pWinSysInfo->setOSLanguage(query.stringvalue(L"OsLanguage"));
            l_pWinSysInfo->setStatus(query.stringvalue(L"SystemScanStatus"));
=====================================================================
Found a 49 line (257 tokens) duplication in the following files: 
Starting at line 25 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\resume_updownload.h
Starting at line 22 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\suspend_resume.h

    ~suspend_resume();

// AgentConnectionBase interface
    virtual bool requestJob(const JobData& job_data, tostream& stream);

    virtual bool putJobStatus(const JobData& job_data,
        const tstring& job_id, const tstring& job_status);

    virtual bool downloadJobData(const JobData& job_data, const tstring& job_id,
        const tstring& temp_name, const tstring& dest_path, const tstring& session_id);

    virtual bool uploadJobRequestData(const JobData& job_data, const tstring& job_id,
        const tstring& result_name, const tstring& job_path, const tstring& session_id);

    virtual bool registerAgent(const tstring& serial_num, int job_req_interval, tostream& agent_id);

    virtual bool unregisterAgent(const tstring& serial_num, const tstring& agent_id);

// InstallerBase interface
    virtual bool install(const tstring& package, const tstring& version);

    virtual bool uninstallAll();

    virtual bool uninstall(const tstring& package);

    virtual tstring getSharedFilesFolder() const;

    virtual tstring getPackageProgramFolder(const tstring& package_name) const;

    virtual void update(const ACE_Future<afw::CResult>& f);

    class suspend_core_MR : public ACE_Method_Request
    {
      public:
        suspend_core_MR(ACE_Future_Observer<afw::CResult>* observer)
        {
            m_res.attach(observer);
        }
        virtual ~suspend_core_MR() {}
        virtual int call(void);

      private:
        ACE_Future<afw::CResult> m_res;
    };

    class resume_core_MR : public ACE_Method_Request
    {
      public:
        resume_core_MR(ACE_Future_Observer<afw::CResult>* observer)
=====================================================================
Found a 53 line (254 tokens) duplication in the following files: 
Starting at line 2572 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 1162 of D:\home\eCora_PM\PM\patchRepository\WinSolRepoSettings.cpp

        QMessageBox::warning(0,
            tr("Unable to save repository settings..."),
        translator.translate(ws2qs(m_errorMessage)), QObject::tr("&OK"));

        // END FIX BUF #18532
    }

    return success;
}

wstring
WinSolRepoSettings::getHostName(const wstring repType)
{
    for (int i = 0; i < m_repositories.size(); ++i)
    {
        if (repType == L"solaris" &&
            m_repositories[i]->systemType() == L"solaris")
        {
            UnixRepositorySettings* unixSettings = 0;
            unixSettings = static_cast<UnixRepositorySettings*> (m_repositories[i]);
            return unixSettings->hostname();
        }
        if (repType == L"windows" &&
            m_repositories[i]->systemType() == L"windows")
        {
            WindowsRepositorySettings* winSettings = 0;
            winSettings = static_cast<WindowsRepositorySettings*> (m_repositories[i]);
            return winSettings->path();
        }
    }
    return L"";

}

// test that repositories can be connected/accessed
bool WinSolRepoSettings::test()
{
    bool res = true;
    log(L"patchRepository", Log::Debug, L"Enter WinSolRepoSettings::test");
    try
    {
        for (int i = 0; i < m_repositories.size(); ++i)
        {
            PatchRepository pr(m_services, m_repositories[i], false);
            if (!pr.canConnect(m_errorMessage))
            {
                log(L"patchRepository", Log::Debug, L"Exit WinSolRepoSettings::test can't connect");
                return false;
            }
            else
            {
                if (m_repositories[i]->systemType() == L"solaris")
                {
=====================================================================
Found a 64 line (254 tokens) duplication in the following files: 
Starting at line 52 of D:\home\eCora_PM\PM\alerts\alertslib\GlobalAlert.h
Starting at line 40 of D:\home\eCora_PM\PM\alerts\upgrade\GlobalAlert.h

    ~GlobalAlert10();

    /**
     * Read alert data from file
     */
    virtual void init(bool createFile = true);
    /**
     * Save alert data to file
     */
    virtual void save();

    /**
     * Is monitoring enabled?  If not, the monitoring service does not
     * evaluate triggers.
     */
    void setEnableMonitoring(bool enable) { m_enableMonitoring = enable; }
    bool getEnableMonitoring() { return m_enableMonitoring; }

    /**
     * monitoring interval in hours
     */
    void setMonitorInterval(int interval) { m_monitorInterval = interval; }
    int getMonitorInterval() { return m_monitorInterval; }

    /**
     * Last time monitoring service cleaned out the event file of old and
     * incomplete events.
     */
    void setLastPurge(time_t purge) { m_lastPurge = purge; }
    time_t getLastPurge() { return m_lastPurge; }

    /**
     * Is SNMP enabled?  If not, the monitoring service will not execute
     * any selected SNMP alerts.
     */
    void setEnableSNMP(bool enable) { m_enableSNMP = enable; }
    bool getEnableSNMP() { return m_enableSNMP; }

    /**
     * SNMP manager to send traps to
     */
    void setSNMPManager(const wstring& manager) { m_snmpManager = manager; }
    wstring getSNMPManager() { return m_snmpManager; }

    /**
     * SNMP port to use to connect to SNMP manager
     */
    void setSNMPPort(int port) { m_snmpPort = port; }
    int getSNMPPort() { return m_snmpPort; }

    /**
     * Is SMTP enabled?  If not, the monitoring service will not execute
     * any selected SMTP alerts.
     */
    void setEnableSMTP(bool enable) { m_enableSMTP = enable; }
    bool getEnableSMTP() { return m_enableSMTP; }
    void setSMTPServer(const wstring& server) { m_smtpServer = server; }
    wstring getSMTPServer() { return m_smtpServer; }
    void setSMTPPort(int port) { m_smtpPort = port; }
    int getSMTPPort() { return m_smtpPort; }
    void setSMTPMaxAttachSize(int size) { m_smtpMaxAttachSize = size; }
    int getSMTPMaxAttachSize() { return m_smtpMaxAttachSize; }
    void setCompress(bool enable) { m_compress = enable; }
    bool getCompress() { return m_compress; }
=====================================================================
Found a 25 line (253 tokens) duplication in the following files: 
Starting at line 353 of D:\home\eCora_PM\PM\patchRepository\RepositoryQuery.cpp
Starting at line 394 of D:\home\eCora_PM\PM\patchRepository\RepositoryQuery.cpp

		buffer->setValue("repositoryFK", ws2qs(id));
		buffer->setValue("hostname", ws2qs(unixSettings->hostname()));
		buffer->setValue("dnsDomain", ws2qs(unixSettings->dnsDomain()));
		buffer->setValue("ipAddress", ws2qs(unixSettings->ipAddress()));
		//buffer->setValue("md5Path", ws2qs(unixSettings->md5Path()));

		buffer->setValue("tUsername", ws2qs(unixSettings->tUsername()));
		buffer->setValue("tProtocol", ws2qs(unixSettings->tProtocol()));
		buffer->setValue("tPort", unixSettings->tPort());
		buffer->setValue("tConnectionDelay", unixSettings->tConnectionDelay());
		buffer->setValue("tLoginPrompt", ws2qs(unixSettings->tLoginPrompt()));
		buffer->setValue("tRootConnectionDelay", unixSettings->tRootConnectionDelay());
		buffer->setValue("tRootLoginPrompt", ws2qs(unixSettings->tRootLoginPrompt()));

		buffer->setValue("ftUsername", ws2qs(unixSettings->ftUsername()));
		buffer->setValue("ftProtocol", ws2qs(unixSettings->ftProtocol()));
		buffer->setValue("ftPort", unixSettings->ftPort());

		if (storeCredentials)
		{
		    buffer->setValue("tPassword", ws2qs(unixSettings->encryptedTPassword()));
		    buffer->setValue("tRootPassword", ws2qs(unixSettings->encryptedTRootPassword()));
		    buffer->setValue("ftPassword", ws2qs(unixSettings->encryptedFtPassword()));
		}
		else
=====================================================================
Found a 98 line (252 tokens) duplication in the following files: 
Starting at line 15 of D:\home\eCora_PM\PM\network\Http.h
Starting at line 15 of D:\home\eCora_PM\PM\network\network\Http.h

namespace network {

class HttpPrivate;
class HttpLogin;


/**
 * An implementation of the HTTP client, for accessing URLs on the WWW.
 */
class Http : public com::INetwork
{
  public:

    /**
     * Create an HTTP client
     *
     * @param cookies a file to store cookie information into.
     * @param userAgentLocation the location in the registry to 
     * find (or set) the user agent string to use for HTTP connections.
     * If it is empty, no user agent will be used.
     */
    Http(const wstring& cookies, const wstring& userAgentLocation, 
         IUnknown* pUnkOuter = 0);
    virtual ~Http();

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(
        const GUID& iid, void** ptr);
    virtual unsigned long STDMETHODCALLTYPE AddRef();
    virtual unsigned long STDMETHODCALLTYPE Release();

    /**
     * Implementation of the Client interface
     */
    virtual bool url2wstring(
        const wstring& url, wstring* content = 0, 
        bool runInThread = true, com::NetworkResult** result = 0);
    virtual bool url2file(
        const wstring& url, const wstring& file, 
        bool runInThread = true, com::NetworkResult** result = 0);
    
    virtual void useProxy(const wstring& addr, const wstring& login, 
        const wstring& pass, const bool useNTLM);
    
    virtual void setCredentials(
        const wstring& login, const wstring& password);
    
    void addListener(com::NetworkListener* listener);
    void removeListener(com::NetworkListener* listener);

    //  Maximum time allowed for a connection to the site.
    virtual void setConnectionTimeout(int timeInSeconds);

    //  Maximum time allowed for the overall operation.  Shoulud
    //  be greater than the time allowed for a connection.  If it
    //  is not then the connection time will override.
    virtual void setOperationTimeout(int timeInSeconds);
    
    virtual void abort();
    
    /**
     * This function adds a callback to use when a '401 - Access Denied'
     * message is encountered when trying to retrieve a URL.  When this
     * happens, the list of callbacks is called, and once one of them
     * returns true, the URL will be tried again.  If the callback list
     * is empty, not set, or if all callbacks return false, then the 401
     * will be returned as is.
     *
     * Each HttpLogin object in the list will have the 'HttpLogin::login()'
     * function called to retrieve the username and password for accessing
     * the URL.  If the HttpLogin object is able to provide a login and 
     * password for accessing that URL, it should return 'true', otherwise
     * it should return false.
     *
     * @param login the Login object to add to the list
     */
    void addLoginAgent(HttpLogin* login);

    /**
     * Removes the HttpLogin callback that was registered with 
     * 'addLoginCallback()'.
     *
     * @param login the object to remove
     */
    void removeLoginAgent(HttpLogin* login);

    /**
     * Release the resources from a Result object
     *
     * @param the Result object to delete
     */
    void freeResult(com::NetworkResult* result) const;

  private:

    HttpPrivate* p;
};

} // namespace network
=====================================================================
Found a 42 line (249 tokens) duplication in the following files: 
Starting at line 1012 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 1040 of D:\home\eCora_PM\PM\scanScheduling\TaskManager.cpp

    CComQIPtr<com::IAppDatabase> pAppDatabase(appServices());
    _IfNullPtrRet(pAppDatabase);

    // systems container
    CComPtr<com::IDbContainer> pDbContainer;
    HRESULT hr = pAppDatabase->getDbContainer(&pDbContainer);
    _IfFailHrRet(hr);

    // load systems
    if (!groupsNode.isNull())
    {
        // register container for groups
        hr = pDbContainer->registerObjectType((IUnknown*)&idb::GroupObject());
        _IfFailHrRet(hr);

        QDomElement element = groupsNode.firstChild().toElement();
        while (!element.isNull())
        {
            QString qsKey = element.attributeNode(GroupID).value();
            if (qsKey.length())
            {

                CComPtr<com::IDbRelation> pRelation;
                hr = pAppDatabase->getDbRelation(&pRelation);
                _IfFailHrRet(hr);

                QPtrVector<IUnknown> systems;
                hr = pRelation->getRelatedObjects((IUnknown*)&idb::GroupObject(qsKey), systems);
                if (SUCCEEDED(hr))
                {
                    for (int idx = 0; idx < systems.count(); ++idx)
                    {
                        com::IDbObject* pSystem = (com::IDbObject*)systems[idx];
                        _ASSERTE(pSystem);
                        selected[qs2ws(pSystem->getKeyAsString())] = pSystem->clone(true);
                    }
                }
            }
            element = element.nextSibling().toElement();
        }
    }
    log(L"TaskManager", Log::Debug, L"<< loadGroupSystems");
=====================================================================
Found a 21 line (240 tokens) duplication in the following files: 
Starting at line 160 of D:\home\eCora_PM\PM\pmXmlProvider\DataProvider.h
Starting at line 33 of D:\home\eCora_PM\PM\pmXmlProvider\WinQueryDB.h

    void getProductID(const wstring&, wstring&);
    void getProductAndSpID(const wstring&, wstring&, wstring&);
    void getFiles(const wstring&, const wstring&, vector<wstring>&);
    void getRegs(const wstring&, const wstring&, vector<wstring>&);
    void getRegLocation(const wstring&, vector<wstring>&);
    void getFileInfo(const wstring&, vector<wstring>&);
    void getLocation(const wstring&, wstring&);
    void getProductName(const wstring&, wstring&);
    void getLatestServicePack(const wstring&, wstring&);
    void searchLatestServicePack(vector<wstring>&, wstring[], wstring[], const int, 
				 const wstring&, const wstring&, wstring&);
    void sendQueryDBEx(wstring[], wstring[], wstring[], 
		       vector<wstring>&, vector<wstring>&, int, bool, 
		       vector<vector<wstring> >&, vector<vector<wstring> >&);
    void sendQueryDB(wstring whereAttributes[], 
			     wstring whereValues[], 
			     wstring selectList[], 
			     vector<wstring>& tableList, 
			     vector<wstring>& results, 
			     int nTables, 
			     bool oneMatchOnly)
=====================================================================
Found a 23 line (240 tokens) duplication in the following files: 
Starting at line 459 of D:\home\eCora_PM\PM\bzip2\blocksort.c
Starting at line 483 of D:\home\eCora_PM\PM\bzip2\blocksort.c

      c1 = block[i1]; c2 = block[i2];
      if (c1 != c2) return (c1 > c2);
      s1 = quadrant[i1]; s2 = quadrant[i2];
      if (s1 != s2) return (s1 > s2);
      i1++; i2++;
      /* 6 */
      c1 = block[i1]; c2 = block[i2];
      if (c1 != c2) return (c1 > c2);
      s1 = quadrant[i1]; s2 = quadrant[i2];
      if (s1 != s2) return (s1 > s2);
      i1++; i2++;
      /* 7 */
      c1 = block[i1]; c2 = block[i2];
      if (c1 != c2) return (c1 > c2);
      s1 = quadrant[i1]; s2 = quadrant[i2];
      if (s1 != s2) return (s1 > s2);
      i1++; i2++;
      /* 8 */
      c1 = block[i1]; c2 = block[i2];
      if (c1 != c2) return (c1 > c2);
      s1 = quadrant[i1]; s2 = quadrant[i2];
      if (s1 != s2) return (s1 > s2);
      i1++; i2++;
=====================================================================
Found a 54 line (238 tokens) duplication in the following files: 
Starting at line 118 of D:\home\eCora_PM\PM\pmArchivePurge\Archiver.cpp
Starting at line 161 of D:\home\eCora_PM\PM\sql\dataMigrator.cpp

{
    wchar_t wszQueryFilePath[1024];

    char szQueryFilePath[1024];

    wcscpy(wszQueryFilePath, wsQueryFilePath.c_str());
    int len = wcslen(wszQueryFilePath) + 1;

    WideCharToMultiByte(CP_ACP, 0, wszQueryFilePath, -1, szQueryFilePath, len, NULL, NULL);

    /*non wide char ops*/
    ifstream* queryFile = new ifstream(szQueryFilePath, ios::in);

    string totalString;
    string inString;

    while (*queryFile >> inString)
    {
        if (inString == "go" || inString == "GO")
        {
            /*execute sql stsement*/
            QSqlQuery queryTables;
            queryTables = QSqlQuery(QString(totalString.c_str()), m_pDBTo);

            totalString = "";
            continue;
        }

       int len = inString.length();
       if (len >= 2 && inString[0] == '/' && inString[1] == '*')
        {
            do
            {
                if (len >= 2 &&
                    inString[len - 2] == '*' &&
                    inString[len - 1] == '/')
                {
                    break;
                }
            }
            while (*queryFile >> inString, len = inString.length());
            continue;
        }

        totalString += (inString + " ");
    }
    if (totalString != "")
    {
        /*execute sql stsement*/
        QSqlQuery queryTables;
        queryTables = QSqlQuery(QString(totalString.c_str()), m_pDBTo);
    }

    delete queryFile;
=====================================================================
Found a 33 line (238 tokens) duplication in the following files: 
Starting at line 949 of D:\home\eCora_PM\PM\customPatch\ExportWizard.cpp
Starting at line 748 of D:\home\eCora_PM\PM\customPatch\ImportWizard.cpp

void ImportWizard::saveConfigTable()
{
    saveConfigSplit();
    if (m_table->numCols() == 0)
    {
        return;
    }

    QWidget *saver = new QWidget(this, QString(name()) + QString("Table"));
    QTable *clon = new QTable(saver, "clon");

    saver->resize(m_table->width() + 100, m_table->height() + 100);
    clon->move(10, 10);
    clon->resize(m_table->size());
    clon->setNumCols(m_table->numCols());
    for (int i = 0; i < m_table->numCols(); i++)
    {
        clon->horizontalHeader()->resizeSection(i,
            m_table->horizontalHeader()->sectionSize(i));
    }
    int srt = m_table->horizontalHeader()->sortIndicatorSection();
    if (srt != -1)
    {
        Qt::SortOrder sorder = m_table->horizontalHeader()->sortIndicatorOrder();
        clon->horizontalHeader()->setSortIndicator(srt, sorder);
        clon->sortColumn(srt, sorder == Qt::Ascending);
    }

    saveConfigDialog(saver, qs2ws(QString::number(m_table->numCols())));
    delete saver;
}

void ImportWizard::restoreConfigTable()
=====================================================================
Found a 517 line (237 tokens) duplication in the following files: 
Starting at line 37 of D:\home\eCora_PM\PM\agent\agent\Library\unzlib\zlib.h
Starting at line 37 of D:\home\eCora_PM\PM\zlib\zlib.h

extern "C" {
#endif

#define ZLIB_VERSION "1.1.4"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce some
  output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows. deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far. (In particular
  avail_in is zero after the call if enough output space has been provided
  before the call.)  Flushing may degrade compression for some compression
  algorithms and so it should be used only when necessary.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
  the compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
   value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller.  msg is set to null if there is no error
   message. inflateInit does not perform any decompression apart from reading
   the zlib header if present: this will be done by inflate().  (So next_in and
   avail_in may be modified, but next_out and avail_out are unchanged.)
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may some
  introduce some output latency (reading input without producing any output)
  except when forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_SYNC_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

     If a preset dictionary is needed at this point (see inflateSetDictionary
  below), inflate sets strm-adler to the adler32 checksum of the
  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
  it sets strm->adler to the adler32 checksum of all output produced
  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
  an error code as described below. At the end of the stream, inflate()
  checks that its computed adler32 checksum is equal to that saved by the
  compressor and returns Z_STREAM_END only if the checksum is correct.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect
  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
  case, the application may then call inflateSync to look for a good
  compression block.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library. Larger values of this parameter result in better
   compression at the expense of memory usage. The default value is 15 if
   deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
   method). msg is set to null if there is no error message.  deflateInit2 does
   not perform any compression: this will be done by deflate().
*/
                            
ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output. This function must be called
   immediately after deflateInit, deflateInit2 or deflateReset, before any
   call of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size in
   deflate or deflate2. Thus the strings most likely to be useful should be
   put at the end of the dictionary, not at the front.

     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if the compression method is bsort). deflateSetDictionary does not
   perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
				      int level,
				      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different
   strategy. If the compression level is changed, the input available so far
   is compressed with the old level (and may be flushed); the new level will
   take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter. The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library. The default value is 15 if inflateInit is used
   instead. If a compressed stream with a larger window size is given as
   input, inflate() will return with the error code Z_DATA_ERROR instead of
   trying to allocate a larger window.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
   memLevel). msg is set to null if there is no error message.  inflateInit2
   does not perform any decompression apart from reading the zlib header if
   present: this will be done by inflate(). (So next_in and avail_in may be
   modified, but next_out and avail_out are unchanged.)
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
=====================================================================
Found a 52 line (236 tokens) duplication in the following files: 
Starting at line 36 of D:\home\eCora_PM\PM\db-updates\CabExtract.cc
Starting at line 27 of D:\home\eCora_PM\PM\windows-utils\CabExtract.cpp

    lstrcpy((LPTSTR)szTarget, (LPTSTR)cabPath.c_str());
    
    switch (notification)
    {
	case SPFILENOTIFY_FILEEXTRACTED:
	    lRetVal = NO_ERROR;  // Do nothing
	    break;
	case SPFILENOTIFY_FILEINCABINET:
	    pInfo = (FILE_IN_CABINET_INFO *)param1;
	    lstrcat((LPTSTR)szTarget, pInfo->NameInCabinet);
	    lstrcpy(pInfo->FullTargetName, (LPTSTR)szTarget);
	    lRetVal = FILEOP_DOIT;  // Extract the file.
	    break;
	case SPFILENOTIFY_NEEDNEWCABINET: // Unexpected.
	    lRetVal = NO_ERROR;
	    break;
    }
    return lRetVal;
}

/**
*   cabExtract (see the header file for parameter info)
*/
int
cabExtract(wstring cabPath, const wstring& cabName, wstring& errmsg)
{
    // no message error
    errmsg = L""; 
    // checking for path
    if (cabPath.empty()) 
	cabPath = L".";
    wstring path = cabPath;
    if (path[path.length() - 1] != L'/' && path[path.length() - 1] != L'\\')
	path += L"/";
    path += cabName;
    // try to get info about the cabName
    {	
	struct _stat buf;
	if (_wstat((wchar_t*)path.c_str(), &buf) != 0)
	{
	    errmsg = L"No cab file info";
	    return ERR_NOCABINFO;
	}
    }
    // parse the cab file
    LONG res = 0;
    if ((res = SetupIterateCabinet((LPTSTR)path.c_str(), 0, (PSP_FILE_CALLBACK)&cabCallback, &cabPath)) == 0)
    {
        DWORD dw = GetLastError();
	errmsg = L"Failed to call SetupIterateCabinet function: " + int2wstring(dw);
	return ERR_CABEXTRACT;
    }
=====================================================================
Found a 28 line (236 tokens) duplication in the following files: 
Starting at line 75 of D:\home\eCora_PM\PM\customPatch\ExportWizard.cpp
Starting at line 625 of D:\home\eCora_PM\PM\customPatch\ImportWizard.cpp

        QCheckListItem* productItem;
        for (it = m_apps.begin(); it != m_apps.end(); ++it)
        {
            if (name != it->second->m_name)
            {
                name = it->second->m_name;
                productItem = new QCheckListItem(node, name, QCheckListItem::CheckBox);
                if (it->second->m_pix)
                    productItem->setPixmap(0, *it->second->m_pix);
                else
                    productItem->setPixmap(0, *m_info->m_pixApp);
                productItem->setOpen(true);
            }
            QCheckListItem* appItem = new QCheckListItem(productItem, it->second->m_id,
                QCheckListItem::CheckBox);
            if (it->second->m_pix)
                appItem->setPixmap(0, *it->second->m_pix);
            else
                appItem->setPixmap(0, *m_info->m_pixApp);
            appItem->setOpen(true);
            map<QString, CustomPatch*>::iterator its;
            for (its = it->second->m_patches.begin(); its != it->second->m_patches.end(); ++its)
            {
                QCheckListItem* item = new QCheckListItem(appItem, its->second->m_name,
                    QCheckListItem::CheckBox);
                item->setPixmap(0, *m_info->m_pixPatch);
            }
        }
=====================================================================
Found a 35 line (236 tokens) duplication in the following files: 
Starting at line 47 of D:\home\eCora_PM\PM\collector\ComAppCollect.h
Starting at line 46 of D:\home\eCora_PM\PM\collector\ComAppSelect.h

    ~ComAppSelect();

    // Throws an exception if any required interface is missing
    void verify(); 

    virtual com::ILicense* license();
    virtual wstring moduleName() const;
    virtual int numberOfThreads() const;
    virtual int licenseLimit(const wstring& type) const;
    virtual wstring networkCacheFile() const;
    virtual wstring installationDirectory() const;
    virtual QWidget* parentWindow() const;
    virtual bool trialMode() const;
    virtual bool collectCommonData() const;
    virtual wstring commonDataPath() const;
    virtual bool serialMode() const;
    virtual wstring encrypt(const wstring& plain) const;
    virtual wstring decrypt(const wstring& crypt) const;
    virtual void statusMessage(const wstring& message);
    virtual int information(
	const wstring& caption, const wstring& text,
	const wstring& button0Collector, const wstring& button1Collector,
	const wstring& button2Collector, int defaultButtonNumber, 
	int escapeButtonNumber) const;
    virtual int warning(
	const wstring& caption, const wstring& text,
	const wstring& button0Collector, const wstring& button1Collector,
	const wstring& button2Collector, int defaultButtonNumber, 
	int escapeButtonNumber) const;
    virtual int critical(
	const wstring& caption, const wstring& text,
	const wstring& button0Collector, const wstring& button1Collector,
	const wstring& button2Collector, int defaultButtonNumber, 
	int escapeButtonNumber) const;
    virtual bool savePasswords() const;
=====================================================================
Found a 54 line (233 tokens) duplication in the following files: 
Starting at line 276 of D:\home\eCora_PM\PM\i18n\Conversions.cc
Starting at line 368 of D:\home\eCora_PM\PM\i18n\Conversions.cc

		    if (c == 0)
		    {
			src = 0;
			break;
		    }
		    src++;
		    continue;
		}
		else if (c < 0xC0)
		{
		    // Spurious 10XXXXXX byte is invalid.
		    goto bad_input;
		}
		if (c < 0xE0)
		{
		    wc = static_cast<wchar_t>(c & 0x1F) << 6;
		    count = 1;
		    if (c < 0xC2) goto bad_input;
		}
		else if (c < 0xF0)
		{
		    wc = static_cast<wchar_t>(c & 0x0F) << 12;
		    count = 2;
		}
#if WCHAR_T_BITS == 32
		else if (c < 0xF8)
		{
		    wc = static_cast<wchar_t>(c & 0x07) << 18;
		    count = 3;
		}
		else if (c < 0xFC)
		{
		    wc = static_cast<wchar_t>(c & 0x03) << 24;
		    count = 4;
		}
		else if (c < 0xFE)
		{
		    wc = static_cast<wchar_t>(c & 0x01) << 30;
		    count = 5;
		}
#endif // WCHAR_T_BITS == 32
		else goto bad_input;
		src++;
	    }
	    else
	    {
		wc = MBSTATE_VALUE(ps) << 6;
		count = MBSTATE_COUNT(ps);
	    }

	    for (;;)
	    {
		c = static_cast<unsigned char>(*src++) ^ 0x80;
		if (!(c < 0x40)) goto bad_input_backup2;
=====================================================================
Found a 28 line (233 tokens) duplication in the following files: 
Starting at line 44 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\DiffDBFinder.cpp
Starting at line 246 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\DiffDBFinder.cpp

    const InsTable ftn = from.getTable(EI::FILES_TABLE);

    CRowComp file_comparer(ftn.getColumns(), fto.getColumns());
    file_comparer[EI::FILE_NAME_ATTR] = DefaultComp();
    file_comparer[EI::REL_PATH_ATTR] = DefaultComp();

    InsFilter filter_o(fto.getColumns());
    filter_o[EI::SHARED_FILE_ATTR] = InsEValueFilter(ECORA_TEXT("0")); // non shared files
    RowCont rfo = RowSelector::select(fto.getRows(), filter_o); // rows files old

    InsFilter filter_n(ftn.getColumns());
    filter_n[EI::SHARED_FILE_ATTR] = InsEValueFilter(ECORA_TEXT("0")); // non shared files
    RowCont rfn = RowSelector::select(ftn.getRows(), filter_n); // row files new

    // Find files which differ by path
    RowCont rcd = RowSelector::select_diff(rfn, rfo, file_comparer);

    // Find files with less file versions (since in uninstall), but equal pathes
    CRowComp file_inv_comparer(fto.getColumns(), ftn.getColumns());
    file_inv_comparer[EI::FILE_NAME_ATTR] = DefaultComp();
    file_inv_comparer[EI::REL_PATH_ATTR] = DefaultComp();

    RowCont first_eq = RowSelector::select_eq(rfn, rfo, file_comparer);
    RowCont second_eq = RowSelector::select_eq(rfo, rfn, file_inv_comparer);

    CRowGComp version_comparer(ftn.getColumns(), fto.getColumns());
    // Less or equal campare
    version_comparer[EI::VERSION_ATTR] = InsVersion::LCompare();
=====================================================================
Found a 55 line (230 tokens) duplication in the following files: 
Starting at line 132 of D:\home\eCora_PM\PM\patchManager\main.cpp
Starting at line 117 of D:\home\eCora_PM\PM\pmWindowsService\service.cpp

} 
#endif 

///////////////////////////////////////////////////////////////////////////////
wstring  
installationDirectory()
{
     // Return installation directory
    ProductionClass pc;
    wstring keyName = pc.baseKey(pc.productName() + L"\\" + pc.productMajorVersion());

    wstring value;
    try 
    {
        value = Registry::value(keyName + L"\\InstallationPath");
    }
    catch (GenericException&)
    {
        throw GenericException(
            __FILE__, __LINE__, L"installationDirectory", L"",
            L"Could not find installation directory in the registry. "
            L"Please re-run the setup program.");
    }

    wstring::size_type index;
    while ((index = value.find(L'\\')) != wstring::npos)
	value[index] = L'/';
    
    if (value.size() > 0 && value[value.size() - 1] == L'/')
	value = value.substr(0, value.size() - 1);

    mkpath(value + L"/");

    return value;
}

com::ILog::Level 
logLevel()
{
     // Return installation directory
    ProductionClass pc;
    wstring keyName = pc.baseKey(pc.productName() + L"\\" + pc.productMajorVersion());

    int value;
    try 
    {
        value = Registry::value(keyName + L"\\Settings\\logLevel");
    }
    catch (GenericException&)
    {
        value = com::ILog::Debug;
    }

    return static_cast<com::ILog::Level>(value);
}
=====================================================================
Found a 30 line (229 tokens) duplication in the following files: 
Starting at line 1508 of D:\home\eCora_PM\PM\customPatch\CustomPatchMainDlg.cpp
Starting at line 952 of D:\home\eCora_PM\PM\customPatch\ExportWizard.cpp

    if (m_table->numCols() == 0)
    {
        return;
    }

    QWidget *saver = new QWidget(this, QString(name()) + QString("Table"));
    QTable *clon = new QTable(saver, "clon");

    saver->resize(m_table->width() + 100, m_table->height() + 100);
    clon->move(10, 10);
    clon->resize(m_table->size());
    clon->setNumCols(m_table->numCols());
    for (int i = 0; i < m_table->numCols(); i++)
    {
        clon->horizontalHeader()->resizeSection(i,
            m_table->horizontalHeader()->sectionSize(i));
    }
    int srt = m_table->horizontalHeader()->sortIndicatorSection();
    if (srt != -1)
    {
        Qt::SortOrder sorder = m_table->horizontalHeader()->sortIndicatorOrder();
        clon->horizontalHeader()->setSortIndicator(srt, sorder);
        clon->sortColumn(srt, sorder == Qt::Ascending);
    }

    saveConfigDialog(saver, qs2ws(QString::number(m_table->numCols())));
    delete saver;
}

void ExportWizard::restoreConfigTable()
=====================================================================
Found a 21 line (227 tokens) duplication in the following files: 
Starting at line 38 of D:\home\eCora_PM\PM\fs\LocalFileSystem.h
Starting at line 41 of D:\home\eCora_PM\PM\fs\RemoteFileSystem.h

			       const wstring& glob = L"*");
    virtual Type type(const wstring& fullPath);
    virtual int size(const wstring& fullPath);
    virtual void rename(const wstring& oldPath, const wstring& newPath);
    virtual void remove(const wstring& fullPath);
    virtual void rmdir(const wstring& fullPath);
    virtual void deltree(const wstring& fullPath, bool stopOnError);
    virtual void mkdir(const wstring& fullPath);
    virtual void mkpath(const wstring& fullPath);
    virtual void create(const wstring& fullPath);
    virtual int read(const wstring& file, void* buffer, 
		     int bufferSize, int seekpos = 0);
    virtual int write(const wstring& file, void* buffer, int bufferSize,
		      int seekpos = 0);
    virtual void file2wstring(const wstring& file, wstring& content);
    virtual void wstring2file(const wstring& file, const wstring& content);
    virtual void file2utf8string(const wstring& file, utf8string& content);
    virtual void utf8string2file(const wstring& file, 
				 const utf8string& content);
    virtual int cp(const wstring& src, const wstring& dst);
    virtual wstring mkstemp(const wstring& file);
=====================================================================
Found a 51 line (224 tokens) duplication in the following files: 
Starting at line 17 of D:\home\eCora_PM\PM\network\LoginParameters.h
Starting at line 17 of D:\home\eCora_PM\PM\network\network\LoginParameters.h

namespace network {

class LoginParameters
{
  public:
    LoginParameters(const wstring& hostname,
		    const wstring& loginName, 
		    const wstring& loginPassword,
		    const wstring& loginPrompt,
		    int loginDelay,
	            ProtocolType protocol,
	            int port,
	            const wstring& arguments,
                    const wstring& clientDir) :
	m_hostname(hostname),
	m_loginUserName(loginName),
	m_loginPassword(loginPassword),
	m_loginPrompt(loginPrompt),
	m_loginDelay(loginDelay),
	m_protocol(protocol),
	m_port(port),
	m_arguments(arguments),
	m_clientDir(clientDir)
    {}

    ~LoginParameters() {}
    
    wstring hostname() const { return m_hostname; }	
    wstring username() const { return m_loginUserName; }
    wstring password()  const{ return m_loginPassword; }
    wstring loginPrompt() const { return m_loginPrompt; }
    int loginDelay() const { return m_loginDelay; }
    ProtocolType getProtocol() const { return m_protocol; }
    int port() const { return m_port; }
    wstring arguments() const { return m_arguments; }
    wstring clientDir() const { return m_clientDir; }

  private:
    wstring m_hostname;      // hostname or ip address for remote machine.  
    wstring m_loginUserName; // Account user name
    wstring m_loginPassword; // Acount password
    wstring m_loginPrompt;   // Prompt to look for after login (optional)
    int m_loginDelay;        // Time to wait after sending password (optional)

    ProtocolType m_protocol; // Protocol to use.
    int m_port;              // Connection port.
    wstring m_arguments;     // Optional arguments to pass to the application.
    wstring m_clientDir;
};

} // namespace patchRepository
=====================================================================
Found a 32 line (223 tokens) duplication in the following files: 
Starting at line 570 of D:\home\eCora_PM\PM\pmDaoDbImpl\DaoDbImplUnitTest.h
Starting at line 652 of D:\home\eCora_PM\PM\pmDaoDbImpl\DaoDbImplUnitTest.h

        bool moreSystems = iSystem->last();
        while (moreSystems)
        {
            wstring scanId = iSystem->getScanId();
            wstring systemScanId = iSystem->getSystemScanId();
            wstring systemId = iSystem->getSystemId();
            wstring computerName = iSystem->getName();
            wstring ipAddress = iSystem->getIpAddress();
            wstring os = iSystem->getOs();
            wstring osVersionId = iSystem->getOsVersionId();
            wstring osLanguage = iSystem->getOsLanguage();
            wstring status = iSystem->getStatus();
            int isServer = iSystem->getServer();

            pmDaoInterfaces::IWindowsSystemExtension* iWindowsSystemExtension = iSystem->getWindowsSystemExtension();

            TS_ASSERT(iWindowsSystemExtension->first());

            TS_ASSERT(iWindowsSystemExtension->getDomain() == L"BSP");
            TS_ASSERT(iWindowsSystemExtension->getWinDir() == L"C:\\WINNT40");
            TS_ASSERT(iWindowsSystemExtension->getSqlDir() == L"C:\\Program Files\\Microsoft SQL Server\\MSSQL");
            TS_ASSERT(iWindowsSystemExtension->getSqlSharedCodeDir() ==
                L"C:\\Program Files\\Microsoft SQL Server\\80\\COM\\");
            TS_ASSERT(iWindowsSystemExtension->getExchangeDir() == L"C:\\Program Files\\Exchange 2000\\");
            TS_ASSERT(iWindowsSystemExtension->getProgramFilesDir() == L"C:\\Program Files");
            TS_ASSERT(iWindowsSystemExtension->getCommonFilesDir() == L"C:\\Program Files\\Common Files");

            TS_ASSERT(!iWindowsSystemExtension->next());

            pmDaoInterfaces::IActivity* iActivity = iSystem->getActivities();

            bool moreActivities = iActivity->last();
=====================================================================
Found a 76 line (222 tokens) duplication in the following files: 
Starting at line 1689 of D:\home\eCora_PM\PM\agent\afCommon\WbemHelper.cpp
Starting at line 1316 of D:\home\eCora_PM\PM\wmi\WmiCollector.cpp

    if (!(Authority == NULL || wcslen(Authority) == 0 ||
        !_wcsnicmp(Authority, L"NTLMDOMAIN:", 11)))
        return E_INVALIDARG;

    // The ntlm case is more complex.  There are four cases
    // 1)  Authority = NTLMDOMAIN:name" and User = "User"
    // 2)  Authority = NULL and User = "User"
    // 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
    // 4)  Authority = NULL and User = "domain\user"

    // first step is to determine if there is a backslash in the user
    // name somewhere between the
    // second and second to last character

    WCHAR * pSlashInUser = NULL;
    if (User)
    {
        WCHAR * pEnd = User + wcslen(User) - 1;
        for (pSlashInUser = User; pSlashInUser <= pEnd; pSlashInUser++)
            if (*pSlashInUser == L'\\')
                // dont think forward slash is allowed!
                break;
        if (pSlashInUser > pEnd)
            pSlashInUser = NULL;
    }

    if (Authority && wcslen(Authority) > 11)
    {
        if (pSlashInUser)
            return E_INVALIDARG;

        AuthArg = SysAllocString(Authority + 11);
        if (User)
            UserArg = SysAllocString(User);
        return S_OK;
    }
    else if (pSlashInUser)
    {
        int iDomLen = pSlashInUser - User;
        WCHAR cTemp[MAX_PATH];
        wcsncpy(cTemp, User, iDomLen);
        cTemp[iDomLen] = 0;
        AuthArg = SysAllocString(cTemp);
        if (wcslen(pSlashInUser + 1))
            UserArg = SysAllocString(pSlashInUser + 1);
    }
    else
        if (User)
            UserArg = SysAllocString(User);

    return S_OK;
}


//***************************************************************************
//
//  SCODE GetAuthImp
//
//  DESCRIPTION:
//
//  Gets the authentication and impersonation levels for a current interface.
//
//  PARAMETERS:
//
//  pFrom               the interface to be tested.
//  pdwAuthLevel    Set to the authentication level
//  pdwImpLevel    Set to the impersonation level
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE GetAuthImp(IUnknown * pFrom, DWORD * pdwAuthLevel, DWORD * pdwImpLevel)
{
=====================================================================
Found a 35 line (220 tokens) duplication in the following files: 
Starting at line 32 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\SelfTest.h
Starting at line 20 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\dummy.h

    ~dummy();

// AgentConnectionBase interface
    virtual bool requestJob(const JobData& job_data, tostream& stream);

    virtual bool putJobStatus(const JobData& job_data,
        const tstring& job_id, const tstring& job_status);

    virtual bool downloadJobData(const JobData& job_data, const tstring& job_id,
        const tstring& temp_name, const tstring& dest_path, const tstring& session_id);

    virtual bool uploadJobRequestData(const JobData& job_data, const tstring& job_id,
        const tstring& result_name, const tstring& job_path, const tstring& session_id);

    virtual bool registerAgent(const tstring& serial_num, int job_req_interval, tostream& agent_id);

    virtual bool unregisterAgent(const tstring& serial_num, const tstring& agent_id);

    virtual bool downloadExternalFile(const tstring& url, const tstring& targetFile,
                              const tstring& user, const tstring& pswd);

    virtual bool downloadInternalFile(const tstring& srcPath, const tstring& destPath);
    
// InstallerBase interface
    virtual bool install(const tstring& package, const tstring& version);

    virtual bool uninstallAll();

    virtual bool uninstall(const tstring& package);

    virtual tstring getSharedFilesFolder() const;

    virtual tstring getPackageProgramFolder(const tstring& package_name) const;

    virtual void cleanup();
=====================================================================
Found a 46 line (217 tokens) duplication in the following files: 
Starting at line 830 of D:\home\eCora_PM\PM\pmAgentManagement\OptionalAgentDeployWizard.cpp
Starting at line 535 of D:\home\eCora_PM\PM\pmAgentManagement\OptionalAgentUninstallWizard.cpp

OptionalAgentUninstallWizard::refreshSelectionWindow()
{
    try
    {
        m_lvData.clear();
        // FIXME: Is there a maximum size for queries?
        if (m_sysKeys.size())
        {
            // Note we have the unique key in the query. We need it later.
            // We need the
            QString selectStr = "SELECT DeviceName, UniqueKey, UserName "
                                            "FROM WindowsSystem WHERE UniqueKey =  '%1' ";
            QString orClause = " OR UniqueKey = '%1' ";

            QString queryStr = selectStr.arg(ws2qs(m_sysKeys[0]));
            for (int i = 1; i < m_sysKeys.size(); ++i)
            {
                queryStr = queryStr + orClause.arg(ws2qs(m_sysKeys[i]));
            }

            QSqlQuery q = m_db->exec(qs2ws(queryStr));

            while (q.next())
            {
                // Build up a vector of ScanSettings for use in communication with the threads.
                QString systemName = q.value(0).asString();
                QString systemId = q.value(1).asString();
                wstring userName = qs2ws(q.value(2).asString());

                QString installStatus = "";
                if (m_agentManager->hasAgent(qs2ws(systemId)))
                {
                    if (userName.empty())
                    {
                        installStatus = QObject::tr("Invalid");
                    }
                    else
                    {
                        installStatus = QObject::tr("Installed");
                    }
                }
                else
                    installStatus = QObject::tr("Not Installed");

                // Find the list view item named 'systemName'.
                QListViewItem* lvi = m_uninstallSelectionListView->findItem(systemName, 0, Qt::ExactMatch);
=====================================================================
Found a 30 line (215 tokens) duplication in the following files: 
Starting at line 313 of D:\home\eCora_PM\PM\patchTest\DiffAnalyzer.cpp
Starting at line 350 of D:\home\eCora_PM\PM\patchTest\DiffAnalyzer.cpp

                itrProduct != winSystem->end(); ++itrProduct)
        {
            // there are some not supported products that will break everything
            if (0 == (*itrProduct)->product().length())
                continue;

            DiffElement<pmUI::ProductInfo, DiffStatus>* element = new DiffElement<pmUI::ProductInfo, DiffStatus>(*itrProduct);
            root->addChild(element);

            // add hotfixes
            pmUI::PatchContainer::iterator itrPatch;
            for (itrPatch = (*itrProduct)->beginPatch(); itrPatch != (*itrProduct)->endPatch(); ++itrPatch)
            {
                if (qs2ws(m_qsPatchFound) == (*itrPatch)->getStatus())
                {
                    DiffElement<pmUI::PatchInfo, DiffStatus>* patch = new DiffElement<pmUI::PatchInfo, DiffStatus>(*itrPatch);
                    element->addChild(patch);
                }
            }

            // add sevice packs
            pmUI::ServicePackContainer::iterator itrSrvPack;
            for (itrSrvPack = (*itrProduct)->beginServicePack(); itrSrvPack != (*itrProduct)->endServicePack(); ++itrSrvPack)
            {
                // as far as I've seen the reporting of a service pack is always a sing of missing it
                DiffElement<pmUI::ServicePackInfo, DiffStatus>* servicePack = 
                    new DiffElement<pmUI::ServicePackInfo, DiffStatus>(*itrSrvPack);
                element->addChild(servicePack);
            }
        }
=====================================================================
Found a 43 line (210 tokens) duplication in the following files: 
Starting at line 24 of D:\home\eCora_PM\PM\pmDbProvider\FileChangeInfoDbProvider.cpp
Starting at line 24 of D:\home\eCora_PM\PM\pmDbProvider\_FileChangeInfoDbProvider.cpp

namespace pmDbProvider {

FileChangeInfoDbProvider::FileChangeInfoDbProvider(QueryManager* qm) : m_qm(qm)
{
}

FileChangeInfoDbProvider::~FileChangeInfoDbProvider()
{
}

vector<FileChangeInfo*>
FileChangeInfoDbProvider::getFileChangeInfos(const wstring& patchId, const wstring& language)
{
    assert(m_qm);

    SqlQuery query;
    query.addSelectColumn(L"fileChange", L"path", L"path");
    query.addSelectColumn(L"fileChange", L"version", L"version");
    query.addSelectColumn(L"fileChange", L"commandId", L"commandId");
    query.addSelectColumn(L"fileChange", L"checksum", L"checksum");

    query.addColumnCondition(L"fileChange", L"languageFK",
        LanguageInfoDbProvider::getLanguageId(patchId, language, m_qm));

    m_qm->exec(&query);

    vector<FileChangeInfo*> result;
    while (query.next())
    {
        FileChangeInfo* fileChangeInfo = new FileChangeInfo;

        fileChangeInfo->setPath(query.value(L"path"));
        fileChangeInfo->setVersion(query.value(L"version"));
        fileChangeInfo->setCommand(query.value(L"commandId"));
        fileChangeInfo->setChecksum(query.value(L"checksum"));

        result.push_back(fileChangeInfo);
    }

    return result;
}

} // namespace pmDbProvider
=====================================================================
Found a 70 line (210 tokens) duplication in the following files: 
Starting at line 16 of D:\home\eCora_PM\PM\network\Result.cpp
Starting at line 16 of D:\home\eCora_PM\PM\network\network\Result.cpp

namespace network {

Result::Result(const Status& status, const wstring& message, long fileTime)
    : m_status(status), m_message(message), m_fileTime(fileTime)
{
}

Result::~Result()
{
}

Result::Status 
Result::status() const 
{ 
    return m_status; 
}

bool 
Result::success() const 
{ 
    return m_status == Success; 
}

bool 
Result::error() const 
{ 
    return m_status == Error; 
}

bool 
Result::cancelled() const 
{ 
    return m_status == Cancelled; 
}

wstring 
Result::message() const 
{ 
    return m_message; 
}

wstring 
Result::toString() const
{
    wstring s;
    if (success())
	s = L"Success: ";
    else if (error())
	s = L"Error: ";
    else if (cancelled())
	s = L"Cancelled: ";
    s += message();
    return s;
}

void
Result::setStatus(Status stat)
{
    m_status = stat;    
}


wostream& 
operator<<(wostream& out, const Result& r)
{
    out << r.toString() << endl;
    return out;
}

} // namespace network
=====================================================================
Found a 55 line (209 tokens) duplication in the following files: 
Starting at line 24 of D:\home\eCora_PM\PM\network\Ftp.h
Starting at line 24 of D:\home\eCora_PM\PM\network\network\Ftp.h

namespace network {

class FtpPrivate;

/**
 * An implementation of an FTP client, for accessing FTP sites on the network.
 *
 * An FTP access requires a username and a password.  The login credentials
 * can be passed in the URL, such as ftp://root:pass@www.ecora.com/blah, or
 * a username and password can be provided via the setUserName() and 
 * setPassword() functions.  If no username or password is provided, 
 * then default values will be used: username: anonymous, pass: info@ecora.com
 */
class Ftp : public com::INetwork
{

  public:

    Ftp(IUnknown* pUnkOuter = 0);
    virtual ~Ftp();

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(
	const GUID& iid, void** ptr);
    virtual unsigned long STDMETHODCALLTYPE AddRef();
    virtual unsigned long STDMETHODCALLTYPE Release();

    /**
     * Implementation of the Client interface
     */
    virtual bool url2wstring(
        const wstring& url, wstring* content = 0, 
        bool runInThread = true, com::NetworkResult** result = 0);
    virtual bool url2file(
        const wstring& url, const wstring& file, 
        bool runInThread = true, com::NetworkResult** result = 0);
    
    virtual void useProxy(const wstring& addr, const wstring& login, 
        const wstring& pass, const bool useNTLM);
    
    virtual void setCredentials(const wstring& login, const wstring& pass);
    
    virtual void addListener(com::NetworkListener* listener);
    virtual void removeListener(com::NetworkListener* listener);

    virtual void abort();

    virtual void freeResult(com::NetworkResult*) const;

  private:

    FtpPrivate* p;
};


} // namespace network
=====================================================================
Found a 42 line (209 tokens) duplication in the following files: 
Starting at line 34 of D:\home\eCora_PM\PM\daoDbImpl\CDocCache.cpp
Starting at line 51 of D:\home\eCora_PM\PM\pmDbCache\CDocCache.cpp

}


bool CDocCache::getItem(wstring Key, CRegistryCacheItem **item)
{
    m_pRWLocker->EnterReader();
    InterlockedIncrement(&m_CallCount);//statistics
    map<wstring, CCacheItem*>::iterator ItemIterator = m_mItems.find(Key);
    if (ItemIterator != m_mItems.end())
    {
        InterlockedIncrement(&m_HitCount);//statistics
        InterlockedIncrement(&m_mItems[Key]->HitCount);//statistics
        m_pRWLocker->LeaveReader();
        *item = (CRegistryCacheItem*)m_mItems[Key];
        return true;
    }
    m_pRWLocker->LeaveReader();
    return false;
}

bool CDocCache::putItem(wstring Key, CRegistryCacheItem *item)
{
    m_pRWLocker->EnterWriter();

    map<wstring, CCacheItem*>::iterator ItemIterator = m_mItems.find(Key);
    if (ItemIterator != m_mItems.end())
    {
        m_pRWLocker->LeaveWriter();
        return false;
    }

    item->HitCount = 0;//statistics
    m_mItems[Key] = item;
    m_PutCount++;//statistics

    m_pRWLocker->LeaveWriter();
    return true;
}

bool CDocCache::getItem(wstring Key, CFileCacheItem **item)
{
    m_pRWLocker->EnterReader();
=====================================================================
Found a 26 line (209 tokens) duplication in the following files: 
Starting at line 115 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\FilesInstaller.cpp
Starting at line 199 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\FilesInstaller.cpp

    static const tstring funk_name = ECORA_TEXT("FilesInstaller::rollback()");
    ACE_DEBUG ((LM_DEBUG, ECORA_TEXT("%s\n"), funk_name.c_str()));
    // Allow local copy for pdb will valid.
    const boost::shared_ptr<InstallDB> pdb = m_context->m_db;
    const InstallDB& db = *pdb;

    const InsTable& ft = db.getTable(EI::FILES_TABLE);
    const InstallerConfig& config = InstallerConfig::instance();
    const tstring module_name = db.getModule().m_name;

    const tstring program_prefix = 
        config.getProgramFilesFolder() + ECORA_TEXT("/") + module_name;
    std::vector<tstring> pathes =
        InstallerUtils::relPathesFromFTable(ft, program_prefix, config.getProgramFilesFolder());

    const tstring temp_prefix = 
        config.getTempFolder() + ECORA_TEXT("/") + module_name;
    std::vector<tstring> temp_pathes =
        InstallerUtils::relPathesFromFTable(ft, temp_prefix, temp_prefix);

    std::vector<tstring>::size_type size = pathes.size();
    assert(pathes.size() == temp_pathes.size());
    for (std::vector<tstring>::size_type ii = 0; ii < size; ++ii)
    {
        try
        {
=====================================================================
Found a 47 line (205 tokens) duplication in the following files: 
Starting at line 2489 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 902 of D:\home\eCora_PM\PM\patchRepository\RepositorySettingsQT.cpp

	unixSettings->setFtProtocol(qs2ws(m_unixFTProtocol->currentText()));

	unixSettings->setCredentialsAvailable(true);

	if (m_advancedUnix)
	{
	    unixSettings->setTConnectionDelay(m_advancedUnix->tConnectionDelay());
	    unixSettings->setTLoginPrompt(m_advancedUnix->tLoginPrompt());
	    unixSettings->setTRootConnectionDelay(m_advancedUnix->tRootConnectionDelay());
	    unixSettings->setTRootLoginPrompt(m_advancedUnix->tRootLoginPrompt());
	    unixSettings->setTPort(m_advancedUnix->tPort());

	    unixSettings->setFtPort(m_advancedUnix->ftPort());

	}

	if (unixSettings)
	    m_repositories.push_back(unixSettings);
    }
    if (m_originalUnixSettings && unixSettings)
    {
        if (!m_originalUnixSettings->matches(unixSettings))
	{
	    log(L"patchRepository", Log::Debug,
		L"Unix repository settings need to be saved - don't match original.");
	    needToSave = true;
	}
    }
    else if (m_originalUnixSettings || unixSettings)
    {
        log(L"patchRepository", Log::Debug,
	    L"Unix repository settings need to be saved - added or deleted.");
	needToSave = true;
    }

    if (!needToSave)
    {
	log(L"patchRepository", Log::Debug, L"No repository setting changes - no save");
	if (m_dsnChanged)
	{
	    wstring errMessage;
	    m_pIRepositoryManager->reloadRepositories(false);
	    m_pIRepositoryManager->updateEvent(errMessage);
	}

	m_pISettings->setSetting(L"repositoryDatabaseCleanup",
	    (m_removeUnusedStatus->isChecked() ? L"true" : L"false"));
=====================================================================
Found a 63 line (205 tokens) duplication in the following files: 
Starting at line 23 of D:\home\eCora_PM\PM\network\CurlImpl.h
Starting at line 23 of D:\home\eCora_PM\PM\network\network\CurlImpl.h

using namespace std;

namespace com { class NetworkListener; }

namespace network {

typedef enum {
        NONE, 
        BASIC, 
        DIGEST, 
        GSSNEGOTIATE, 
        NTLM
} AuthenticationType;

class CurlImpl
{
  public:

    CurlImpl(const wstring& userAgentLocation);
    virtual ~CurlImpl();

    void useProxy(
        const wstring& proxy, const wstring& user, 
        const wstring& password, const bool useNTLM);
    void setCredentials(const wstring& login, const wstring& pass);
    void progress(double dltotal, double dlnow, double ultotal, double ulnow);
    bool aborted() const;
    
    void setAborted(bool yes);
    void addListener(com::NetworkListener*);
    void removeListener(com::NetworkListener*);
    
    wstring mapErrorMessage(int code);

    void setConnectionTimeout(int timeInSeconds);
    void setOperationTimeout(int timeInSeconds);


//  int debugCallback(CURL* handle, curl_infotype infoType, char* data, size_t dataSize, void *); 
    
  protected:
    
    CURL* m_handle;
    
    curl_version_info_data* m_curlVersion;

    vector<const char*> m_garbage;
    set<com::NetworkListener*> m_listeners;
    
    wstring m_login;
    wstring m_password;
    
    wstring m_proxy;
    wstring m_proxyUser;
    wstring m_proxyPassword;

    AuthenticationType m_proxyAuthentication;

    // Set to true if a client wants to abort a download/upload
    volatile bool m_aborted;
};

} // namespace network
=====================================================================
Found a 46 line (203 tokens) duplication in the following files: 
Starting at line 731 of D:\home\eCora_PM\PM\remoteModel\RemoteFactory.cpp
Starting at line 796 of D:\home\eCora_PM\PM\remoteModel\RemoteFactory.cpp

    pNewPatch = new RemoteSqlPatch(pPatch->getPatchId());
    pmPushBaseModel::ISqlPatch* pSqlPatch = dynamic_cast<pmPushBaseModel::ISqlPatch*>(pNewPatch);
    if (pSqlPatch)
    {
        pSqlPatch->setServicePack(isServicePack);
        pSqlPatch->setSqlInstanceName(instance);
        pSqlPatch->setSqlInstanceLocation(instanceLoc);

        //air sept
        if (L"SQL 2000" == shortName ||
            L"SQL 2005" == shortName || L"SQL 2005 x64" == shortName ||
            L"SQL 2008" == shortName || L"SQL 2008 x64" == shortName)
        {
            pSqlPatch->setType(pmPushBaseModel::ISqlPatch::Sql2000);
        }
        else if (L"SQL 7.0" == shortName)
        {
            pSqlPatch->setType(pmPushBaseModel::ISqlPatch::Sql7);
        }
        else if (L"MSDE 1.0" == shortName)
        {
            pSqlPatch->setType(pmPushBaseModel::ISqlPatch::Msde1);
        }
        else if (L"MSDE 2000" == shortName ||
            L"SQL 2005 Express" == shortName || L"SQL 2005 Express x64" == shortName ||
            L"SQL 2008 Express" == shortName || L"SQL 2008 Express x64" == shortName)
        {
            pSqlPatch->setType(pmPushBaseModel::ISqlPatch::Msde2000);
        }
        else
        {
            throw GenericException(__FILE__, __LINE__, L"LocalFactory::newWindowsPatch", L"",
                L"Unknown product: " + shortName);
        }
    }
    else
    {
        throw GenericException(__FILE__, __LINE__, L"LocalFactory::newWindowsPatch", L"",
                L"Failed to create Sql patch.");
    }
    return pNewPatch;
}

/*
*/
pmPushBaseModel::IPatch* RemoteFactory::newOfficePatch(wstring& patchId)
=====================================================================
Found a 36 line (203 tokens) duplication in the following files: 
Starting at line 67 of D:\home\eCora_PM\PM\pmOAService\Actions.cpp
Starting at line 87 of D:\home\eCora_PM\PM\pmServices\DbManager.cpp

    HANDLE hMutex = NULL;
    PACL paclNewDacl = NULL;

    __try{
	// Create the everyone sid
	if (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0,
					  0, 0, 0, 0, 0, 0, &psidEveryone))
	{
	    psidEveryone = NULL ;
	    __leave;
	}

	int nSidSize = GetLengthSid(psidEveryone);
	int nAclSize = nSidSize * 2 + sizeof(ACCESS_ALLOWED_ACE) + sizeof(ACCESS_DENIED_ACE) + sizeof(ACL);
	paclNewDacl = (PACL) LocalAlloc(LPTR, nAclSize);
	if (!paclNewDacl)
	   __leave;
	if (!InitializeAcl(paclNewDacl, nAclSize, ACL_REVISION))
	   __leave;
	if (!AddAccessDeniedAce(paclNewDacl, ACL_REVISION, WRITE_DAC | WRITE_OWNER, psidEveryone))
	   __leave;
	// I am using GENERIC_ALL here so that this very code can be applied to
	// other objects. Specific access should be applied when possible.
	if (!AddAccessAllowedAce(paclNewDacl, ACL_REVISION, GENERIC_ALL, psidEveryone))
	   __leave;

	SECURITY_DESCRIPTOR sd;
	if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
	   __leave;
	if (!SetSecurityDescriptorDacl(&sd, TRUE, paclNewDacl, FALSE))
	   __leave;

	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(sa);
	sa.bInheritHandle = FALSE;
	sa.lpSecurityDescriptor = &sd;
=====================================================================
Found a 65 line (201 tokens) duplication in the following files: 
Starting at line 84 of D:\home\eCora_PM\PM\pmDbProvider\ScanWinProductDbProvider.cpp
Starting at line 467 of D:\home\eCora_PM\PM\pmDbProvider\ScanWinProductDbProvider.cpp

    query.exec(L"SELECT * FROM #ProductsTable ORDER BY ProductVersionId, InstanceName");

    qPatches.exec(
        L"SELECT DISTINCT "
            L"          #ProductsTable.ProductVersionId AS ProductVersionID, "
            L"          patchStatus.patchFK AS patchId, "
            L"          patchStatus.status AS PatchStatus, "
            L"          patchStatus.comment AS PatchComment, "
            L"          patchStatus.uninstallData AS PatchUninstallData, "
            L"          windowsPatchExtension.sqNumber AS PatchSeqNumber, "
            L"          container.id AS PatchArticleId, "
            //L"          #ProductsTable.SystemLanguage AS OsLanguage, " // #12074 //MM
            L"          #ProductsTable.ProductLanguage AS ProductLanguage, " // #12074 //MM
            L"          #ProductsTable.InstanceName AS ProductInstanceName " // #8889 //MM
            L"INTO #PatchesTable "
            L"FROM  windowsPatchExtension INNER JOIN "
            L"          affects INNER JOIN "
            L"          patchStatus ON affects.patchFK = patchStatus.patchFK INNER JOIN "
            L"          containsRelation INNER JOIN "
            L"          container ON containsRelation.containerFK = container.id ON patchStatus.patchFK = "
            L"              containsRelation.patchFK ON "
            L"          windowsPatchExtension.patchFK = containsRelation.patchFK RIGHT OUTER JOIN "
            L"          #ProductsTable ON patchStatus.productInstance = #ProductsTable.InstanceName AND affects.versionFK = "
            L"              #ProductsTable.ProductVersionId AND "
            //L"          patchStatus.systemScanFK = #ProductsTable.SystemScanID "); //MM #9137
            L"          patchStatus.systemScanFK = #ProductsTable.SystemScanId ");//MM #9137


    qPatches.exec(
        L"SELECT    #PatchesTable.*, "
            L"          container.CIAC_assessment   AS CIAC_assessment, "
            L"          container.CIAC_severity     AS CIAC_severity, "
            L"          container.CIAC_bulletin     AS CIAC_bulletin, "
            L"          patch.name                  AS PatchName, "
            L"          patch.pushException         AS pushException, "
            L"          sbid.sbid                   AS sbid, "
            L"          [language].id               AS LanguageID "
            L"FROM  [language] RIGHT OUTER JOIN "
            //L"          #PatchesTable ON [language].lang = #PatchesTable.OsLanguage AND [language].patchFK = " // #12074 //MM
            L"          #PatchesTable ON [language].lang = #PatchesTable.ProductLanguage AND [language].patchFK = " // #12074 //MM
            L"          #PatchesTable.patchId LEFT OUTER JOIN "
            L"          container INNER JOIN "
            L"          sbid ON container.id = sbid.containerFK INNER JOIN "
            L"          patch ON sbid.patchFK = patch.id ON #PatchesTable.patchId = sbid.patchFK AND "
            L"          #PatchesTable.PatchArticleId = sbid.containerFK "
            L"ORDER BY #PatchesTable.ProductVersionID, ProductInstanceName " //MM #8889 & #9137
            );
    qPatches.addSelectColumn(L"Tbl", L"ProductVersionId");
    qPatches.addSelectColumn(L"Tbl", L"PatchID");
    qPatches.addSelectColumn(L"Tbl", L"PatchStatus");
    qPatches.addSelectColumn(L"Tbl", L"PatchComment");
    qPatches.addSelectColumn(L"Tbl", L"PatchUninstallData");
    qPatches.addSelectColumn(L"Tbl", L"PatchSeqNumber");
    qPatches.addSelectColumn(L"Tbl", L"ArticleID");
    //qPatches.addSelectColumn(L"Tbl", L"OsLanguage"); // #12074 //MM
    qPatches.addSelectColumn(L"Tbl", L"ProductLanguage"); // #12074 //MM
    qPatches.addSelectColumn(L"Tbl", L"ProductInstanceName"); // #8889 // MM
    qPatches.addSelectColumn(L"Tbl", L"CIAC_assessment");
    qPatches.addSelectColumn(L"Tbl", L"CIAC_severity");
    qPatches.addSelectColumn(L"Tbl", L"CIAC_bulletin");
    qPatches.addSelectColumn(L"Tbl", L"PatchName");
    qPatches.addSelectColumn(L"Tbl", L"PushException");
    qPatches.addSelectColumn(L"Tbl", L"sbID");
    qPatches.addSelectColumn(L"Tbl", L"LanguageID");
    qPatches.printStatement();
=====================================================================
Found a 7 line (200 tokens) duplication in the following files: 
Starting at line 444 of D:\home\eCora_PM\PM\fksec\main.cpp
Starting at line 452 of D:\home\eCora_PM\PM\fksec\main.cpp

	manualsid = _T( "S-1-5-32" );
	out << _T( "sid prefixes are " ) << ( emptysid.EqualPrefix( manualsid )? _T( "" ): _T( "not " ) ) << _T( "equal [1]" ) << std::endl;
	out << _T( "sid prefixes are " ) << ( manualsid.EqualPrefix( emptysid )? _T( "" ): _T( "not " ) ) << _T( "equal [2]" ) << std::endl;
	out << _T( "sids are " ) << ( emptysid == manualsid? _T( "" ): _T( "not " ) ) << _T( "equal [1]" ) << std::endl;
	out << _T( "sids are " ) << ( manualsid == emptysid? _T( "" ): _T( "not " ) ) << _T( "equal [2]" ) << std::endl;
	out << _T( "sids are " ) << ( emptysid != manualsid? _T( "" ): _T( "not " ) ) << _T( "unequal [1]" ) << std::endl;
	out << _T( "sids are " ) << ( manualsid != emptysid? _T( "" ): _T( "not " ) ) << _T( "unequal [2]" ) << std::endl;
=====================================================================
Found a 29 line (200 tokens) duplication in the following files: 
Starting at line 57 of D:\home\eCora_PM\PM\agent\AgentManager\AgentManagerClient\AgentJobListWidgetUI.ui.h
Starting at line 53 of D:\home\eCora_PM\PM\agent\AgentManager\AgentManagerClient\AssignmentListWidgetUI.ui.h

        IJobAssignmentInfoPtr spJobAssignment = spAssignments->GetItem(i);

        SYSTEMTIME st;
        QString qstrCreationTime;

        if (::VariantTimeToSystemTime(spJobAssignment->CreationTime, &st))
        {
            QDateTime creationTime(QDate(st.wYear, st.wMonth, st.wDay), 
                QTime(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds));
            creationTime = creationTime.addSecs((-60) * (tzi.Bias + tzi.StandardBias + tzi.DaylightBias)); //add UTC offset
            qstrCreationTime = creationTime.toString(Qt::LocalDate);
        }

        int secs = 0;//spJobAssignment->Interval;
        int days = secs / (60 * 60 *24);
        secs = secs % (60 * 60 *24);
        QString qstrPeriodicity;
        QTime qt(secs / (60 * 60), (secs / 60) % 60, secs % 60);

        if (days > 0)
        {
            qstrPeriodicity = QString("%1.%2").arg(days).arg(qt.toString("hh:mm"));
        }
        else
        {
            qstrPeriodicity = qt.toString("hh:mm");
        }

        QString qstrDelay;// = QString("%1 min").arg(spJobAssignment->Delay / 60);
=====================================================================
Found a 32 line (196 tokens) duplication in the following files: 
Starting at line 247 of D:\home\eCora_PM\PM\patchManager\PolicyAnalyzer.cpp
Starting at line 332 of D:\home\eCora_PM\PM\patchManager\PolicyAnalyzer.cpp

    itPatch = policy->beginPatchRule();
    
    for (; itPatch != policy->endPatchRule(); ++itPatch)
    {
        if ((*itPatch)->selected() == false)
            continue;
        
        // check if pair<patchId, productName> is already done
        if (tmpDuplicates.find((*itPatch)->patchId()) != tmpDuplicates.end())
            continue;
        
        // create a new policy in patchManager based on policy in policyManager
        // do not deaallocate the pointer
        pmUI::PolicyInfo* pmPolicy = new pmUI::PolicyInfo();
        
        pmPolicy->setPolicyId(policy->policyId());
        pmPolicy->setNamePolicy(policy->name());
        pmPolicy->setDescriptionPolicy(policy->description());
        
        // check if there is at least on patch which doesn't comply with the policy rule
        if (system()->addPolicyInfo(pmPolicy,
            (*itPatch)->product(),
            (*itPatch)->productVersionId(),
            (*itPatch)->patchId(),
            (*itPatch)->rule(),
            (*itPatch)->isServicePack()) == pmUI::DisplayPolicyCompliance::POLICY_NOT_COMPLY)
            comply = pmUI::DisplayPolicyCompliance::POLICY_NOT_COMPLY;
        
        tmpDuplicates.insert((*itPatch)->patchId());
    }
    
    return comply;
=====================================================================
Found a 51 line (196 tokens) duplication in the following files: 
Starting at line 109 of D:\home\eCora_PM\PM\idbXml\DbFields.cpp
Starting at line 96 of D:\home\eCora_PM\PM\idb\DbFields.cpp

    return (iter->second & EncodedField);
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
bool DbFields::isEncoded(const QString& qsName)
{
    QValueVector<QPair<QString, int> >::iterator iter;
    for (iter = m_fields.begin(); iter != m_fields.end(); ++iter)
    {
        if (qsName == iter->first)
        {
            return isEncoded(iter);
        }
    }

    return false;//or an error, field has to be found
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
QString DbFields::encode(QString& qsValue)
{
    _ASSERTE(m_pEncryption);
    return m_pEncryption ? ws2qs(m_pEncryption->encrypt(qs2ws(qsValue))) : qsValue;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
QString DbFields::decode(QString& qsValue)
{
    _ASSERTE(m_pEncryption);
    return m_pEncryption ? ws2qs(m_pEncryption->decrypt(qs2ws(qsValue))) : qsValue;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void DbFields::setFieldDisplay(QString qsName, QString qsDisplay)
{
    m_fieldDisplayNames[qsName] = qsDisplay;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
QString DbFields::getFieldDisplayName(const QString& qsName) const
{
    if (m_fieldDisplayNames.end() != m_fieldDisplayNames.find(qsName))
        return m_fieldDisplayNames[qsName];
    else
        return qsName;
}
=====================================================================
Found a 24 line (195 tokens) duplication in the following files: 
Starting at line 206 of D:\home\eCora_PM\PM\snoopy\listbox.cpp
Starting at line 243 of D:\home\eCora_PM\PM\snoopy\listbox.cpp

			int curSel = 0;
			TCHAR* sit = _tcsstr(
			    m_labels[m_available[curSel]].c_str(), _T("ou="));
			PCTSTR s = sit ? sit + 3 :
			    m_labels[m_available[curSel]].c_str();
			WAddExtentEntry(sWnd, s);
			int addedStringIndex =
			    SendMessage(sWnd, LB_ADDSTRING,
					(WPARAM)(0), (LPARAM)s);
			for (int j = m_lastSelected; j > addedStringIndex; j--)
			    m_selected[j] = m_selected[j - 1];
			m_selected[addedStringIndex] = m_available[curSel];
                        IncreaseSelectionNumber(s);
			//m_lastSelected++;
			//m_lastAvailable--;
			for (j = curSel; j < m_lastAvailable; ++j)
			    m_available[j] = m_available[j + 1];
			WRemoveExtentEntry(aWnd, curSel);
			SendMessage(aWnd, LB_DELETESTRING, (WPARAM)curSel, 0);
		    }
 		    SetDlgItemText(hDlg, 
 			IDC_RNUMBER, _itot(m_lastSelected, buf, 10));
 		    SetDlgItemText(hDlg, 
 			IDC_LNUMBER, _itot(m_lastAvailable, buf, 10));
=====================================================================
Found a 23 line (194 tokens) duplication in the following files: 
Starting at line 1328 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 1330 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

    map< wstring, vector<int> > values;
    while (sqlQuery.next())
    {
        wstring wsKey = qs2ws(sqlQuery.value(1).toString());
        if (values.find(wsKey) != values.end())
        {
            values[wsKey].push_back(sqlQuery.value(0).toInt());
        }
        else
        {
            vector<int> v;
            v.push_back(sqlQuery.value(0).toInt());
            pair< wstring, vector<int> > p(wsKey, v);
            values.insert(p);
        }
    }
    
    map< wstring, vector<int> >::iterator it = values.begin();
    for (it; it != values.end(); it++)
    {
        //wcout << it->first << endl;
        sort(it->second.begin(), it->second.end());
        for (int j = 0; j < it->second.size() - (resultsNumber); j++)
=====================================================================
Found a 23 line (194 tokens) duplication in the following files: 
Starting at line 38 of D:\home\eCora_PM\PM\agent\agent\Library\unzlib\ioapi.h
Starting at line 34 of D:\home\eCora_PM\PM\zlib\ioapi.h

typedef voidpf (ZCALLBACK *open_file_func) OF((voidpf opaque, const char* filename, int mode));
typedef uLong  (ZCALLBACK *read_file_func) OF((voidpf opaque, voidpf stream, void* buf, uLong size));
typedef uLong  (ZCALLBACK *write_file_func) OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
typedef long   (ZCALLBACK *tell_file_func) OF((voidpf opaque, voidpf stream));
typedef long   (ZCALLBACK *seek_file_func) OF((voidpf opaque, voidpf stream, uLong offset, int origin));
typedef int    (ZCALLBACK *close_file_func) OF((voidpf opaque, voidpf stream));
typedef int    (ZCALLBACK *testerror_file_func) OF((voidpf opaque, voidpf stream));

typedef struct zlib_filefunc_def_s
{
    open_file_func      zopen_file;
    read_file_func      zread_file;
    write_file_func     zwrite_file;
    tell_file_func      ztell_file;
    seek_file_func      zseek_file;
    close_file_func     zclose_file;
    testerror_file_func zerror_file;
    voidpf              opaque;
} zlib_filefunc_def;



void fill_fopen_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
=====================================================================
Found a 43 line (192 tokens) duplication in the following files: 
Starting at line 135 of D:\home\eCora_PM\PM\patchRepository\Patch.cpp
Starting at line 194 of D:\home\eCora_PM\PM\patchRepository\PatchQuery.cpp

void UnixPatchQuery::initSelector()
{
    com::ISettings* pISettings;
    if (m_services)
    {
        m_services->QueryInterface(IID_ISettings, (void**)&pISettings);

        if (!pISettings)
        {
            wstring message = L"Unable to get repository settings.";
            throw GenericException(__FILE__, __LINE__, L"PatchRepository", 
                                L"", message);
        }
    }
    else
    {
        wstring message = L"Unable to get repository settings - services not available.";
        throw GenericException(__FILE__, __LINE__, L"PatchRepository", 
                                L"", message);
    }    

    wstring p = pISettings->setting(m_system + L"UrlProtocol");
    if (p.size() == 0)
	p = DEFAULT_PROTOCOL;
    else
    {
	if (_wcsicmp(p.c_str(), HTTP_PROTOCOL) == 0)
	    p = HTTP_PROTOCOL;
	else
	    p = FTP_PROTOCOL;
    }
    wstring s = pISettings->setting(m_system + L"UrlSign");
    if (s.size() == 0)
	s = DEFAULT_SIGN;
    else
    {
	if (_wcsicmp(s.c_str(), SIGNED_FILE) == 0)
	    s = SIGNED_FILE;
	else
	    s = UNSIGNED_FILE;
    }

    m_selector = p + s;
=====================================================================
Found a 24 line (191 tokens) duplication in the following files: 
Starting at line 21 of D:\home\eCora_PM\PM\pmDaoInterfaces\ICustomProduct.h
Starting at line 19 of D:\home\eCora_PM\PM\pmDaoInterfaces\IProduct.h

class IProduct : public virtual ::daoBase::IDao
{
  public:
    virtual wstring getVersionId() const = 0;
    virtual wstring getSystemScanId() const = 0;
    virtual wstring getName() const = 0;
    virtual wstring getShortName() const = 0;
    virtual wstring getVersion() const = 0;
    virtual wstring getInstance() const = 0;
    virtual wstring getLocation() const = 0;
    virtual wstring getLanguage() const = 0;
    virtual wstring getStatus() const = 0;

    virtual void setVersionId(const wstring&) = 0;
    virtual void setSystemScanId(const wstring&) = 0;
    virtual void setName(const wstring&) = 0;
    virtual void setShortName(const wstring&) = 0;
    virtual void setVersion(const wstring&) = 0;
    virtual void setInstance(const wstring&) = 0;
    virtual void setLocation(const wstring&) = 0;
    virtual void setLanguage(const wstring&) = 0;
    virtual void setStatus(const wstring&) = 0;

    virtual IPatch* addPatch() = 0;
=====================================================================
Found a 51 line (189 tokens) duplication in the following files: 
Starting at line 155 of D:\home\eCora_PM\PM\pmPushUnixBaseImpl\Task.cpp
Starting at line 247 of D:\home\eCora_PM\PM\pmPushWinBaseImpl\Task.cpp

}
void
Task::accept(pmPushBaseModel::Visitor& v)
{
    pmPushBaseModel::IJob::iterator it;
    if (v.depthFirst())
    {
        for (it = begin(); end() != it; ++it)
        {
            if (*it)
            {
                (*it)->accept(v);
            }
            else
            {
                return;
            }
        }
        v.visit(this); 
    }
    else
    {
        v.visit(this); 
        for (it = begin(); end() != it; ++it)
        {
            if (*it)
            {
                (*it)->accept(v);
            }
            else
            {
                return;
            }
        }
    }
}
void
Task::acceptNoVisit(pmPushBaseModel::Visitor& v)
{
    pmPushBaseModel::IJob::iterator it;
    for (it = begin(); end() != it; ++it)
    {
        if (*it)
        {
            (*it)->accept(v);
        }
    }
}

void 
Task::setAppIface(IUnknown* appIface) 
=====================================================================
Found a 53 line (188 tokens) duplication in the following files: 
Starting at line 94 of D:\home\eCora_PM\PM\pmPushUnixBaseImpl\Domain.cpp
Starting at line 123 of D:\home\eCora_PM\PM\pmPushWinBaseImpl\Domain.cpp

    m_computers.push_back(com);
    
}
void
Domain::accept(pmPushBaseModel::Visitor& v)
{
    pmPushBaseModel::IDomain::iterator it;
    //list<IComputer*>::iterator it;
    if (v.depthFirst())
    {
        for (it = begin(); end() != it; ++it)
        {
            //IComputer* p = dynamic_cast<IComputer*>(*it);
            if (*it)
            {
                (*it)->accept(v);
            }
            else
            {
                return;
            }
        }
        v.visit(this); 
    }
    else
    {
        v.visit(this); 
        for (it = begin(); end() != it; ++it)
        {
            //IComputer* p = dynamic_cast<IComputer*>(*it);
            if (*it)
            {
                (*it)->accept(v);
            }
            else
            {
                return;
            }
        }
    }
}
void
Domain::acceptNoVisit(pmPushBaseModel::Visitor& v)
{
    pmPushBaseModel::IDomain::iterator it;
    for (it = begin(); end() != it; ++it)
    {
        if (*it)
        {
            (*it)->accept(v);
        }
    }
}
=====================================================================
Found a 162 line (188 tokens) duplication in the following files: 
Starting at line 55 of D:\home\eCora_PM\PM\patchRepository\UnixStorage.h
Starting at line 45 of D:\home\eCora_PM\PM\patchRepository\WindowsStorage.h

    ~WindowsStorage();

    /**
     * Connect to device on which repository resides
     *
     */
    void connect();

    /**
     * Connected?
     * @return m_connected
     */
    bool isConnected();

    /**
     * Are we REALLY still connected?
     * @return m_connected and can still access the repository
     */
    bool isConnectionAlive();

    /**
     * Disconnect from device on which repository resides
     *
     */
    void disconnect();

    /**
     * Does repository exist?
     *
     * @return true if exists
     */
    bool exists();

    /**
     * Create repository
     *
     */
    void create();

    /**
     * Is enough space available?
     *
     * @param neededSpace
     * @return true if more than neededSpace available
     */
    bool isSpaceAvailable(ULONGLONG neededSpace);

    /**
     * Does directory or file exist in repository?
     *
     * @param file file path relative to repository
     * @return true if exists
     */
    bool fileExists(const wstring& file);

    /**
     * Get the size of the file in the repository
     *
     * @param file file path relative to repository
     * @return file size
     */
    unsigned long fileSize(const wstring& file);

    // FIXME remove
    /**
     * Get the last modified date/time of the file in the repository
     *
     * @param file file path relative to repository
     * @return file last modified time
     */
    //time_t fileLastModified(const wstring& file);

    /**
     * Get the version of the file in the repository
     *
     * @param file file path relative to repository
     * @return file version
     */
    //wstring fileVersion(const wstring& file);

    /**
     * Create the directory (as sub-directory in repository path)
     *
     * @param directory
     */
    virtual void mkDir(const wstring& directory);

    /**
     * Remove the directory (sub-directory in repository path)
     * remove any files and remove directory
     *
     * @param directory
     */
    virtual bool rmDir(const wstring& directory);

    /**
     * Remove the directory (sub-directory in repository path)
     * remove any files and remove directory
     * throws the GenericException exception if error occurs
     *
     * @param directory
     */
    virtual void rmDirExc(const wstring& directory);

    /**
     * Get directory listing
     *
     * @param directory
     */
    vector<wstring> dir(const wstring& directory, int filter);

    /**
     * Add the file into the repository
     * (for unix, file is downloaded to temp location on PM machine, then moved to NFS server)
     *
     * @param srcFile
     * @param destination file path relative to repository
     */
    void addFile(const wstring& srcFile, const wstring& destination,
	ft_progress_callback callback, void* clientp);

    /**
     * Delete the file from the repository
     *
     * @param file file path relative to repository
     */
    virtual bool deleteFile(const wstring& file);

    /**
     * Delete the file from the repository
     * throws the GenericException exception if error occurs
     *
     * @param file file path relative to repository
     */
    virtual void deleteFileExc(const wstring& file);

    /**
     * Validate the file (checksum)
     *
     * @param file file path relative to repository
     * @return true if valid
     */
    bool validateMd5(const wstring& file, const wstring& checksum);

    /**
     * Is the file valid?  (Checksum)
     *
     * @param file file path relative to repository
     * @param checksum to compare against
     * @return calcChecksum calculated checksum
     * @return checksum
     */
    bool validateMd5(const wstring& file, const wstring& checksum, wstring& calcChecksum);

    /**
     * Move the file to a target device
     *
     * @param srcFile file path relative to repository
     * @param destFile path for file on destination device
     * @param destDevice destination device info
     */
    void moveFile(const wstring& srcFile, const wstring& destFile,
=====================================================================
Found a 39 line (187 tokens) duplication in the following files: 
Starting at line 574 of D:\home\eCora_PM\PM\idb\DbContainer.cpp
Starting at line 617 of D:\home\eCora_PM\PM\idb\DbContainer.cpp

        return S_OK;


    QSqlIndex index = m_pCursor->primaryIndex();
    QSqlIndex filter = m_pCursor->index(KEY);
    m_pCursor->setValue(KEY, qsKey);
    // BUGFIX #16305
    //m_pCursor->select(filter, index);
    m_pCursor->select(QString(KEY) + "=N'" + escapeSQLString(qsKey) + "'"); // BUGFIX #16305
    m_pCursor->setFilter("");

    if (m_pCursor->next())
    {
        QValueVector<QPair<QString, int> >::iterator itr;
        for (itr = m_fields.begin(); itr != m_fields.end(); ++itr)
        {
            QString qsValue = m_pCursor->value(itr->first).toString();
            if (itr->second & DbFields::EncodedField)
            {
                HRESULT hr = pObject->setEncodedFieldValue(itr->first, qsValue);
                IfFailHrRetVal(hr, hr);
            }
            else
            {
                HRESULT hr = pObject->setFieldValue(itr->first, qsValue);
                IfFailHrRetVal(hr, hr);
            }
        }
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
HRESULT DbContainer::registerObjectType(IUnknown* pUnkObject)
=====================================================================
Found a 40 line (185 tokens) duplication in the following files: 
Starting at line 103 of D:\home\eCora_PM\PM\winPushActions\WinPushActionHelper.cpp
Starting at line 103 of D:\home\eCora_PM\PM\winUIActions\WinUIActionHelper.cpp

WinUIActionHelper::dumpWindowsHierarchy(const wstring& fileName, const wstring& parentName)
{
    m_windowIdx = 0;

    if (m_windowsHierarchyDoc)
    {
        delete m_windowsHierarchyDoc;
        m_windowsHierarchyDoc = 0;
        delete m_crtWindowElem;
        m_crtWindowElem = 0;
    }
    m_windowsHierarchyDoc = new QDomDocument();

    m_crtWindowElem = new QDomElement();
    *m_crtWindowElem = m_windowsHierarchyDoc->createElement("ParentWindow");
    m_windowsHierarchyDoc->appendChild(*m_crtWindowElem);

    if (parentName != L"")
    {
        m_crtWindowElem->setAttribute("caption", ws2utf8s(parentName).c_str());

        HWND parentHwnd = getWindowHandle(parentName, NULL);

        ostringstream oss;
        oss << parentHwnd;
        m_crtWindowElem->setAttribute("handle", oss.str().c_str());

        EnumChildWindows(parentHwnd, EnumWindowsProc, 0);
    }
    else
    {
        m_crtWindowElem->setAttribute("caption", "Desktop");

        EnumChildWindows(NULL, EnumWindowsProc, 0);
    }

    QFile f(ws2qs(fileName));
    if (!f.open(IO_WriteOnly))
    {
        throw GenericException(__FILE__, __LINE__, L"WinUIActionHelper::dumpWindowsHierarchy", L"",
=====================================================================
Found a 32 line (185 tokens) duplication in the following files: 
Starting at line 20 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\restart.h
Starting at line 20 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\system_update.h

    ~system_update();

// AgentConnectionBase interface
    virtual bool requestJob(const JobData& job_data, tostream& stream);

    virtual bool putJobStatus(const JobData& job_data,
        const tstring& job_id, const tstring& job_status);

    virtual bool downloadJobData(const JobData& job_data, const tstring& job_id,
        const tstring& temp_name, const tstring& dest_path, const tstring& session_id);

    virtual bool uploadJobRequestData(const JobData& job_data, const tstring& job_id,
        const tstring& result_name, const tstring& job_path, const tstring& session_id);

    virtual bool registerAgent(const tstring& serial_num, int job_req_interval, tostream& agent_id);

    virtual bool unregisterAgent(const tstring& serial_num, const tstring& agent_id);

// InstallerBase interface
    virtual bool install(const tstring& package, const tstring& version);

    virtual bool uninstallAll();

    virtual bool uninstall(const tstring& package);

    virtual tstring getSharedFilesFolder() const;

    virtual tstring getPackageProgramFolder(const tstring& package_name) const;

  private:
    bool m_job_sent;
};
=====================================================================
Found a 25 line (184 tokens) duplication in the following files: 
Starting at line 1538 of D:\home\eCora_PM\PM\customPatch\CustomPatchMainDlg.cpp
Starting at line 784 of D:\home\eCora_PM\PM\customPatch\ImportWizard.cpp

    QWidget *saver = new QWidget(this, QString(name()) + QString("Table"));
    QTable *clon = new QTable(saver, "clon");

    clon->setNumCols(m_table->numCols());
    if (restoreConfigDialog(saver, qs2ws(QString::number(m_table->numCols()))))
    {
        for (int i = 0; i < m_table->numCols(); i++)
        {
            m_table->horizontalHeader()->resizeSection(i,
                clon->horizontalHeader()->sectionSize(i));
        }
        int srt = clon->horizontalHeader()->sortIndicatorSection();
        if (srt != -1)
        {
            Qt::SortOrder sorder = clon->horizontalHeader()->sortIndicatorOrder();
            m_table->horizontalHeader()->setSortIndicator(srt, sorder);
            m_table->sortColumn(srt, sorder == Qt::Ascending);
        }
    }

    delete saver;
    m_table->repaint();
}

void ImportWizard::saveConfigSplit()
=====================================================================
Found a 31 line (183 tokens) duplication in the following files: 
Starting at line 20 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\cancel_job.h
Starting at line 20 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\restart.h

    ~restart();

// AgentConnectionBase interface
    virtual bool requestJob(const JobData& job_data, tostream& stream);

    virtual bool putJobStatus(const JobData& job_data,
        const tstring& job_id, const tstring& job_status);

    virtual bool downloadJobData(const JobData& job_data, const tstring& job_id,
        const tstring& temp_name, const tstring& dest_path, const tstring& session_id);

    virtual bool uploadJobRequestData(const JobData& job_data, const tstring& job_id,
        const tstring& result_name, const tstring& job_path, const tstring& session_id);

    virtual bool registerAgent(const tstring& serial_num, int job_req_interval, tostream& agent_id);

    virtual bool unregisterAgent(const tstring& serial_num, const tstring& agent_id);

// InstallerBase interface
    virtual bool install(const tstring& package, const tstring& version);

    virtual bool uninstallAll();

    virtual bool uninstall(const tstring& package);

    virtual tstring getSharedFilesFolder() const;

    virtual tstring getPackageProgramFolder(const tstring& package_name) const;

  private:
    bool m_job_sent;
=====================================================================
Found a 36 line (181 tokens) duplication in the following files: 
Starting at line 362 of D:\home\eCora_PM\PM\NetDiscover\WindowsComputerInfo.cpp
Starting at line 199 of D:\home\eCora_PM\PM\snoopy\reglook.cpp

RegBuff::getServices(wstring& wsConnectName, 
                     auto_ptr<ENUM_SERVICE_STATUS>& pService, 
                     DWORD& dwCount, 
                     DWORD dwType)
{
    USES_CONVERSION;
//    CSCManager scm(GetRealServerName(),
    CSCManager scm(wsConnectName.c_str(),
		   SERVICES_ACTIVE_DATABASE, GENERIC_READ);
    DWORD resumeHandle = 0, ret = ERROR_SUCCESS;
    DWORD bytes = 0;

    if (!EnumServicesStatus(scm.GetSCManager(), dwType,
			    SERVICE_STATE_ALL, NULL, 0,
			    &bytes, &dwCount, &resumeHandle))
	ret = GetLastError();

    auto_ptr<ENUM_SERVICE_STATUS> service(
	reinterpret_cast<LPENUM_SERVICE_STATUS>(new char[bytes]));

    if (ret == ERROR_MORE_DATA)
    {
	if (!EnumServicesStatus(scm.GetSCManager(), dwType,
				SERVICE_STATE_ALL, service.get(), bytes,
				&bytes, &dwCount, &resumeHandle))
	    ret = GetLastError();
	else
	    ret = ERROR_SUCCESS;
    }

    if (ret != ERROR_SUCCESS)
	throw WinErrorException(
	    __FILE__, __LINE__, L"EnumServicesStatus", ret);

    pService = service;
}
=====================================================================
Found a 43 line (179 tokens) duplication in the following files: 
Starting at line 368 of D:\home\eCora_PM\PM\repository\BTree.h
Starting at line 485 of D:\home\eCora_PM\PM\repository\BTree.h

            vector<wstring>& values, DataId& foundId, 
            PFilterFunc pfFilterCallback, void* pFilterData)
        {
            gist_cursor_t cursor;
            bool differentId = false;
            
#ifndef NDEBUG
            internalCheck(id);
#endif
            
            if (m_btIndex.fetch_init(cursor, qp) != RCOK)
            {
                throw GenericException(
                    __FILE__, __LINE__,
                    L"BTree::get", L"", L"cannot initialize cursor");
            }
            keys.clear(); values.clear();
            for (bool eof = false; !eof;)
            {
                smsize_t keysz = gist_p::max_tup_sz;
                smsize_t datasz = gist_p::max_tup_sz;
                
                if (m_btIndex.fetch(
                    cursor, m_keyBuff1, 
                    keysz, m_dataBuff, datasz, eof) != RCOK)
                {
                    if (!eof)
                    {               
                        cursor.reset();
                    }
                    throw GenericException(__FILE__, __LINE__,
                        L"", L"BTree::get",
                        L"cannot fetch from cursor");
                }
                
                if (!eof)
                {
                    wstring key;
                    
                    StrBTreeExtension::restore(m_keyBuff1, &key);
                    foundId = dataId(m_dataBuff);
                    if (foundId == id)
                    {
=====================================================================
Found a 34 line (178 tokens) duplication in the following files: 
Starting at line 51 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivePurgeDefs.cpp
Starting at line 84 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivePurgeDefs.cpp

void ArchivePurgeDefs::operator=(ArchivePurgeDefs& defs)
{
    archiveDataSourceName = defs.archiveDataSourceName;
    archiveUserName = defs.archiveUserName;
    archivePassword = defs.archivePassword;

    archiveTaskDefsFilePath = defs.archiveTaskDefsFilePath;
    purgeTaskDefsFilePath = defs.purgeTaskDefsFilePath;

    useArchiveDataFeature = defs.useArchiveDataFeature;
    usePurgeDataFeature = defs.usePurgeDataFeature;
    
    archiveRules = defs.archiveRules;
    keepActiveResultsNumber = defs.keepActiveResultsNumber;
    keepScansOnline[0] = defs.keepScansOnline[0];
    keepScansOnline[1] = defs.keepScansOnline[1];
    keepScansOnline[2] = defs.keepScansOnline[2];

    purgeRules = defs.purgeRules;
    keepArchiveResultsNumber = defs.keepArchiveResultsNumber;
    storeArchiveScans[0] = defs.storeArchiveScans[0];
    storeArchiveScans[1] = defs.storeArchiveScans[1];
    storeArchiveScans[2] = defs.storeArchiveScans[2];
    
    useSheduledArchive = defs.useSheduledArchive;
    runArchiveOnPMClose = defs.runArchiveOnPMClose;
    
    useSheduledPurge = defs.useSheduledPurge;
    runPurgeOnPMClose = defs.runPurgeOnPMClose;
    
    purgeRunTimeData = defs.purgeRunTimeData;
}

void ArchivePurgeDefs::save(/*const ArchivePurgeDefs* s*/)
=====================================================================
Found a 28 line (178 tokens) duplication in the following files: 
Starting at line 20 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\cancel_job.h
Starting at line 25 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\resume_updownload.h

    virtual void finalize();

// AgentConnectionBase interface
    virtual bool requestJob(const JobData& job_data, tostream& stream);

    virtual bool putJobStatus(const JobData& job_data,
        const tstring& job_id, const tstring& job_status);

    virtual bool downloadJobData(const JobData& job_data, const tstring& job_id,
        const tstring& temp_name, const tstring& dest_path, const tstring& session_id);

    virtual bool uploadJobRequestData(const JobData& job_data, const tstring& job_id,
        const tstring& result_name, const tstring& job_path, const tstring& session_id);

    virtual bool registerAgent(const tstring& serial_num, int job_req_interval, tostream& agent_id);

    virtual bool unregisterAgent(const tstring& serial_num, const tstring& agent_id);

// InstallerBase interface
    virtual bool install(const tstring& package, const tstring& version);

    virtual bool uninstallAll();

    virtual bool uninstall(const tstring& package);

    virtual tstring getSharedFilesFolder() const;

    virtual tstring getPackageProgramFolder(const tstring& package_name) const;
=====================================================================
Found a 40 line (177 tokens) duplication in the following files: 
Starting at line 154 of D:\home\eCora_PM\PM\winPushActions\WinPushActionHelper.cpp
Starting at line 154 of D:\home\eCora_PM\PM\winUIActions\WinUIActionHelper.cpp

WinUIActionHelper::enumWindows(HWND hwnd)
{
    wchar_t windowCaption[200];
    int captionSize = GetWindowText(hwnd, windowCaption, 200);

    QDomElement newWindowElem = m_windowsHierarchyDoc->createElement("Window");
    m_crtWindowElem->appendChild(newWindowElem);

    newWindowElem.setAttribute("index", ++m_windowIdx);

    if (captionSize)
    {
        newWindowElem.setAttribute("caption", ws2utf8s(windowCaption).c_str());
    }
    else
    {
        newWindowElem.setAttribute("caption", "No caption");
    }

    ostringstream hwndOss;
    hwndOss << hwnd;
    newWindowElem.setAttribute("handle", hwndOss.str().c_str());

    ostringstream ctrlIdOss;
    ctrlIdOss << GetDlgCtrlID(hwnd);
    newWindowElem.setAttribute("ctrlId", ctrlIdOss.str().c_str());

    QDomElement savedWindowElem = *m_crtWindowElem;
    *m_crtWindowElem = newWindowElem;

    int savedWindowIdx = m_windowIdx;
    m_windowIdx = 0;

    EnumChildWindows(hwnd, EnumWindowsProc, 0);

    *m_crtWindowElem = savedWindowElem;
    m_windowIdx = savedWindowIdx;
}

HWND
=====================================================================
Found a 56 line (177 tokens) duplication in the following files: 
Starting at line 236 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\DADEProvider.cpp
Starting at line 160 of D:\home\eCora_PM\PM\agent\agent\apps\Connector\AFPAnalyzer.cpp

}

namespace
{
    class XMLCh2Ch
    {
      public:
        XMLCh2Ch(const XMLCh* const toTranscode);
        ~XMLCh2Ch();
        const char* localForm() const;
      private :
        char* m_localForm;
    };
    class Ch2XMLCh
    {
      public:
        Ch2XMLCh(const char* const toTranscode);
        ~Ch2XMLCh();

        const XMLCh* unicodeForm() const;
      private :
        XMLCh* m_unicodeForm;
    };
} // unnamed namespace

XMLCh2Ch::XMLCh2Ch(const XMLCh* const toTranscode)
{
    m_localForm = XMLString::transcode(toTranscode);
}

XMLCh2Ch::~XMLCh2Ch()
{
    XMLString::release(&m_localForm);
}

const char* XMLCh2Ch::localForm() const
{
    return m_localForm;
}

Ch2XMLCh::Ch2XMLCh(const char* const toTranscode)
{
    m_unicodeForm = XMLString::transcode(toTranscode);
}

Ch2XMLCh::~Ch2XMLCh()
{
    XMLString::release(&m_unicodeForm);
}

const XMLCh* Ch2XMLCh::unicodeForm() const
{
    return m_unicodeForm;
}

tstring CAFPXMLChUtils::convert(const XMLCh* const toConvert)
=====================================================================
Found a 34 line (176 tokens) duplication in the following files: 
Starting at line 497 of D:\home\eCora_PM\PM\customPatch\ExportWizard.cpp
Starting at line 434 of D:\home\eCora_PM\PM\customPatch\ImportWizard.cpp

void ImportWizard::checkParents(QCheckListItem* item)
{
    if (item != 0)
    {
        QCheckListItem* child = (QCheckListItem*)item->firstChild();
        bool allChecked = true;
        bool allUnchecked = true;
        while (child != 0 && (allUnchecked || allChecked))
        {
            child->setTristate(true);
            if (child->state() == QCheckListItem::On)
                allUnchecked = false;
            else if (child->state() == QCheckListItem::Off)
                allChecked = false;
            else
            {
                allChecked = false;
                allUnchecked = false;
            }
            child->setTristate(false);
            child = (QCheckListItem*)child->nextSibling();
        }
        if (allChecked)
            item->setOn(true);
        else if (allUnchecked)
            item->setOn(false);
        else
            item->setState(QCheckListItem::NoChange);
        item = (QCheckListItem*)item->parent();
        checkParents(item);
    }
}

void ImportWizard::onPageChange(const QString& pageTitle)
=====================================================================
Found a 75 line (176 tokens) duplication in the following files: 
Starting at line 239 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\DADEProvider.cpp
Starting at line 19 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Parser\XmlUtils.cpp

namespace
{
    ///////////////////////////////////////////////////////////////////////////////
    //  This is a simple class that lets us do easy (though not terribly efficient)
    //  trancoding of XMLCh data to local code page for display.
    ///////////////////////////////////////////////////////////////////////////////
    class XMLCh2Ch
    {
      public:
        XMLCh2Ch(const XMLCh* const toTranscode);
        ~XMLCh2Ch();

        const char* localForm() const;
      private :
        ///////////////////////////////////////////////////////////////////////////
        //  Private data members
        //
        //  fLocalForm
        //      This is the local code page form of the string.
        ///////////////////////////////////////////////////////////////////////////
        char* m_localForm;
    };

    ///////////////////////////////////////////////////////////////////////////////
    //  This is a simple class that lets us do easy (though not terribly efficient)
    //  trancoding of char* data to XMLCh data.
    ///////////////////////////////////////////////////////////////////////////////
    class Ch2XMLCh
    {
      public:
        Ch2XMLCh(const char* const toTranscode);
        ~Ch2XMLCh();

        const XMLCh* unicodeForm() const;
      private :
        XMLCh* m_unicodeForm;
    };
} // unnamed namespace

XMLCh2Ch::XMLCh2Ch(const XMLCh* const toTranscode)
{
    // Call the private transcoding method
    m_localForm = XMLString::transcode(toTranscode);
}


XMLCh2Ch::~XMLCh2Ch()
{
    XMLString::release(&m_localForm);
}


const char* XMLCh2Ch::localForm() const
{
    return m_localForm;
}


Ch2XMLCh::Ch2XMLCh(const char* const toTranscode)
{
    m_unicodeForm = XMLString::transcode(toTranscode);
}

Ch2XMLCh::~Ch2XMLCh()
{
    XMLString::release(&m_unicodeForm);
}


const XMLCh* Ch2XMLCh::unicodeForm() const
{
    return m_unicodeForm;
}

tstring XMLChUtils::convert(const XMLCh* const toConvert)
=====================================================================
Found a 41 line (176 tokens) duplication in the following files: 
Starting at line 110 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\EcoraRCSetup.cpp
Starting at line 222 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\PatchSetup\PatchSetup.cpp

		ReportMessage(_T("\nEcora Reporting Center patch finished."));
	}
	catch (bool e) {
		if (!e) {
			ReportMessage(_T("\nEcora Reporting Center patch install failed."));
		}
	}

	CloseLog();
	CoUninitialize();

	return 0;
}

void RunAndWait(LPTSTR cmd)
{

	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	TCHAR	lpErrorMessage[1024];

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
			_stprintf(lpErrorMessage, _T("\nCan't create process. Command line:\n %s\n"), cmd);
			ReportError(lpErrorMessage, __LINE__);
			throw false;
	}

	WaitForSingleObject(pi.hProcess, INFINITE);

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
}

void OpenLog()
{

	hLog = OpenEventLog(NULL, _T("Application"));
=====================================================================
Found a 24 line (175 tokens) duplication in the following files: 
Starting at line 98 of D:\home\eCora_PM\PM\idbXml\IdbXmlTest.cpp
Starting at line 158 of D:\home\eCora_PM\PM\idbXml\IdbXmlTest.cpp

    OutputDebugString(L"\nRetrieve updated Objects\n");
    {
        MyObject ObjectTest[Objects];
        for (idx = 0; idx < pContainer->getSize(); ++idx)
        {
            (IUnknown*)(&ObjectTest[idx])->AddRef();
            HRESULT hr = ObjectTest[idx].QueryInterface(IID_IUnknown, (void**)&pUnknown);
            if (SUCCEEDED(hr))
            {
                pContainer->retrieveObject(pUnknown, idx);
                for (iter = ObjectFields.begin(); iter != ObjectFields.end(); ++iter)
                {
                    OutputDebugString(L" ");
                    CComQIPtr<IDbObject> pObject(&ObjectTest[idx]);
                    QString qsValue;
                    pObject->getFieldValue(iter->first, qsValue);
                    OutputDebugString(qs2ws(iter->first).c_str());
                    OutputDebugString(L" ");
                    OutputDebugString(qs2ws(qsValue).c_str());
                }
                OutputDebugString(L"\n");
            }
        }
    }
=====================================================================
Found a 41 line (173 tokens) duplication in the following files: 
Starting at line 143 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.h
Starting at line 74 of D:\home\eCora_PM\PM\patchRepository\WinSolRepoSettings.h

  public slots:
    virtual void onWindows();
    virtual void onUnix();
    virtual void onAdvanced();
    virtual void onBrowse();
    virtual void onDownloadBrowse();
    virtual void onOk();
    virtual void onCancel();

    bool update();
    void loadPMAgents();
  protected:
    WinRepoSettings* m_winWidget;
    SolRepoSettings* m_solWidget;

  private:
    bool test();
    bool checkValidityAfterTest();
    bool checkValidityOfTempDownloadDir();

    wstring determineUNCPath(const wstring& path);
    bool isLocalPath(const wstring& path);
    wstring convertSlashes(const wstring& path);

    //Sergey Sokolov - Fix bug 14378
    wstring convertBackSlashes(const wstring& path);

    wstring getHostName();

    IUnknown* m_services;
    com::ISettings* m_pISettings;
    IRepositoryManager* m_pIRepositoryManager;
    QWidget* m_parent;
    vector<RepositorySettings*> m_repositories;
    UnixRepositorySettings* m_advancedUnix;
    wstring m_errorMessage;
    bool m_dialog;
    RepositorySettingsDlgQT* m_pDialog;
    RepositorySettings* m_originalWindowsSettings;
    RepositorySettings* m_originalUnixSettings;
    bool m_dsnChanged;
=====================================================================
Found a 26 line (173 tokens) duplication in the following files: 
Starting at line 220 of D:\home\eCora_PM\PM\daoXmlImpl\XmlDaoBase.cpp
Starting at line 148 of D:\home\eCora_PM\PM\pmDaoXmlImpl\XmlDaoBase.cpp

}

void
XmlDaoBase::processSelectCriteria(const daoBase::XmlMetaElement& metaElem, const daoBase::CriteriaBase* criteria,
    const QDomElement& entity, EntityList* resEntities)
{
    assert(!metaElem.getAttribute().empty());
    assert(!metaElem.getCriteriaAttribute().empty());
    assert(criteria);
    assert(resEntities);

    EntityList entitiesWithName;
    entitiesByName(metaElem.getName(), entity, &entitiesWithName);

    EntityList::iterator entityWithNameIt = entitiesWithName.begin();
    for (; entityWithNameIt != entitiesWithName.end(); ++entityWithNameIt)
    {
        QDomElement attrElem = entityWithNameIt->namedItem(ws2qs(metaElem.getAttribute())).toElement();

        if (!attrElem.isNull() &&
            qs2ws(attrElem.text()) == criteria->getAttrValue(metaElem.getCriteriaAttribute()))
        {
            resEntities->push_back(*entityWithNameIt);
        }
    }
}
=====================================================================
Found a 34 line (173 tokens) duplication in the following files: 
Starting at line 185 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\RepositoryChanger.cpp
Starting at line 326 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\RepositoryChanger.cpp

    ACE_DEBUG ((LM_DEBUG, ECORA_TEXT("RepositoryChanger::registerComponents().\n")));

    typedef InsTable::ColumnCont ColumnCont;
    typedef ColumnCont::size_type size_type;
    typedef InsTable::RowCont RowCont;
    typedef RowCont::const_iterator rcit;

    const boost::shared_ptr<AgentInstallerContext> pctx =
        boost::static_pointer_cast<AgentInstallerContext>(m_context);


    // Insert in rep_components records about rep_shared_files (NOTE: that is diff)
    // which are components in module configuration file
    //        [copy to rep_components
    //            [select rep_shared_files which
    //                [select 
    //                    [select shared_files from files]
    //                which components]
    //            ]
    //        ] 
    const InstallDB& db = *(pctx->m_db);
    InstallDB& rep = *(pctx->m_prep);
    const InsTable& ftbl = db.getTable(EI::FILES_TABLE);
    const InsTable& ctbl = db.getTable(EI::COMPONENTS_TABLE);
    InsTable& rep_ftbl = rep[EI::REP_SHARED_FILES_TABLE];
    InsTable& rep_ctbl = rep[EI::REP_COMPONENTS_TABLE];

    InsFilter filter(ftbl.getColumns());
    filter[EI::SHARED_FILE_ATTR] = InsEValueFilter(ECORA_TEXT("1"));

    CRowComp cmp_f_c(ftbl.getColumns(), ctbl.getColumns());
    cmp_f_c[EI::FILE_ATTR] = DefaultComp();

    CRowComp cmp_rc_rf(rep_ctbl.getColumns(), ftbl.getColumns());
=====================================================================
Found a 22 line (172 tokens) duplication in the following files: 
Starting at line 84 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\SolarisPatchAnalyzer.cpp
Starting at line 113 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\SolarisPatchAnalyzer.cpp

    map<wstring, IdbRecord*>::iterator it = m_dbPackages.begin();
    for (; it != m_dbPackages.end(); ++it)
    {
        IdbRecord* r = dynamic_cast<IdbRecord*>(it->second);
        if (r)
            delete r;
    }

    it = m_dbPatches.begin();
    for (; it != m_dbPatches.end(); ++it)
    {
        IdbRecord* r = dynamic_cast<IdbRecord*>(it->second);
        if (r)
            delete r;
    }
    map<wstring, vector<SolarisArchitecture*> >:: iterator iii = m_dbArchitecture.begin();
    for (; iii !=  m_dbArchitecture.end(); ++iii)
    {
        vector<SolarisArchitecture*> va = iii->second;
        for (int i = 0; i < va.size(); ++i)
            delete va[i];
    }
=====================================================================
Found a 18 line (172 tokens) duplication in the following files: 
Starting at line 145 of D:\home\eCora_PM\PM\pmDataProcessor\CustomProduct.cpp
Starting at line 178 of D:\home\eCora_PM\PM\pmDataProcessor\WindowsPatch.cpp

                vector<cRegCacheElement*>::iterator itReg = item->m_vRegCache.begin();
                for (;itReg != item->m_vRegCache.end(); itReg++)
                {
                    DpContainer* registryChange = new DpContainer(L"RegistryChange", getIDbManager(), getDbConnection(), false);
                    if (registryChange)
                    {
                        registryChange->addAttribute(L"Path", ((cRegCacheElement*)(*itReg))->path);
                        registryChange->addAttribute(L"KeyName", ((cRegCacheElement*)(*itReg))->keyName);
                        registryChange->addAttribute(L"Type", ((cRegCacheElement*)(*itReg))->type);
                        registryChange->addAttribute(L"Mode", ((cRegCacheElement*)(*itReg))->mode);
                        registryChange->addAttribute(L"ExpectedValue", ((cRegCacheElement*)(*itReg))->expectedValue);
                        registryChanges.addContainer(registryChange);
                    }
                }
            }
        }
        else
        {
=====================================================================
Found a 18 line (172 tokens) duplication in the following files: 
Starting at line 69 of D:\home\eCora_PM\PM\pmDataProcessor\CustomProduct.cpp
Starting at line 102 of D:\home\eCora_PM\PM\pmDataProcessor\WindowsPatch.cpp

                vector<cFileCacheElement *>::iterator itFile = item->m_vFileCache.begin();
                for (;itFile != item->m_vFileCache.end(); itFile++)
                {
                    DpContainer* fileChange = new DpContainer(L"FileChange", getIDbManager(), getDbConnection(), false);
                    if (fileChange)
                    {
                        fileChange->addAttribute(L"Path", ((cFileCacheElement*)(*itFile))->path);
                        fileChange->addAttribute(L"Version", ((cFileCacheElement*)(*itFile))->version);
                        fileChange->addAttribute(L"Revision", ((cFileCacheElement*)(*itFile))->revision);
                        fileChange->addAttribute(L"CommandId", ((cFileCacheElement*)(*itFile))->commandID);
                        fileChange->addAttribute(L"Checksum", ((cFileCacheElement*)(*itFile))->checksum);
                        fileChanges.addContainer(fileChange);
                    }
                }
            }
        }
        else
        {
=====================================================================
Found a 24 line (171 tokens) duplication in the following files: 
Starting at line 836 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp
Starting at line 886 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp

        m_newPatch->m_regs[i] = cr;
        m_tableReg->setItem(num, 0,
            new ESTableItem(m_tableReg, QTableItem::Never, cr->m_registryKey));
        m_tableReg->setItem(num, 1,
            new ESTableItem(m_tableReg, QTableItem::Never, m_info->m_regTypes[cr->m_regType]));
        m_tableReg->setItem(num, 2,
            new ESTableItem(m_tableReg, QTableItem::Never, cr->m_value));
        QString data = cr->m_data;
        data = data.replace('\n', ' ');
        m_tableReg->setItem(num, 3,
            new ESTableItem(m_tableReg, QTableItem::Never, data));
        m_changed = true;
        int col = m_tableReg->horizontalHeader()->sortIndicatorSection();
        if (col >= 0)
        {
            m_tableReg->sortColumn(col,
                m_tableReg->horizontalHeader()->sortIndicatorOrder() == Qt::Ascending,
                true);
        }
    }
    checkRegButtons();
}

void PatchProperties::removeReg()
=====================================================================
Found a 25 line (171 tokens) duplication in the following files: 
Starting at line 44 of D:\home\eCora_PM\PM\agent\agent\apps\Client\AgentSvc\InstallConfigurator\InstallConfigurator.cpp
Starting at line 271 of D:\home\eCora_PM\PM\agent\agent\apps\Client\AgentSvc\main.cpp

        tstring root_path = settings[REG_AGENTSVC_INSTALL_PATH];
                   
        root_path += ECORA_TEXT("/log");
        if (ACE_OS::access(root_path.c_str(), 0))
        {
            ACE_OS::mkdir(root_path.c_str());
        }
        
        tstring LogFile = root_path + ECORA_INSTALLATION_LOG;
        std::auto_ptr<tofstream> plog_ostream(new tofstream(LogFile.c_str(), ios::out | ios::app));
        
        if (!ACE_OS::freopen(LogFile.c_str(), ACE_TEXT("a+"), stderr))
        {
            ACE_OS::perror (argv[0]);
        }
        
        if (!ACE_OS::freopen(LogFile.c_str(), ACE_TEXT("a+"), stdout))
        {
            ACE_OS::perror (argv[0]);
        }
        
        if (*plog_ostream)
        {
            ACE_LOG_MSG->msg_ostream(plog_ostream.release(), 1);
            ACE_LOG_MSG->open(argv[0], ACE_Log_Msg::STDERR | ACE_Log_Msg::OSTREAM, 0);
=====================================================================
Found a 50 line (170 tokens) duplication in the following files: 
Starting at line 351 of D:\home\eCora_PM\PM\smuggle\SmuggleTest.cc
Starting at line 192 of D:\home\eCora_PM\PM\utils\LogTest.cc

	    &threads[i], &threadAttributes[i], runThread, 0);
	Thread id = threads[i];
#endif // !_WIN32

	wcout << L"Thread " << i << L" id=" << id
	      << L", status=" << status << endl;
    }

    wcout << L"All " << nthreads
	  << L" threads are working now.  Wait...\n";

    for (int j = 0; j < nthreads; j++)
    {
	wcout << L"Joining thread " << j << L"... ";

	void* result = 0;
#ifdef _WIN32
	DWORD status = WaitForMultipleObjectsEx(
	    1, &threads[j], TRUE, INFINITE, FALSE);
#else // !_WIN32
	int status = pthread_join(threads[j], &result);
#endif // !_WIN32

	if (!ThreadStatusOk(status))
	{
	    wcout << L"failed\n";
	    continue;
	}
	wcout << L"done (";

	if (result)
	{
	    error = reinterpret_cast<int>(result);
	    wcout << L"code=" << result;
	}
	else
	    wcout << L"ok";

	wcout << L")\n";
    }

    delete[] threads;
    delete[] threadAttributes;

    return error;
}


static const wstring s_help =
L" -h [-t threads]\n\
=====================================================================
Found a 26 line (170 tokens) duplication in the following files: 
Starting at line 82 of D:\home\eCora_PM\PM\agent\agent\Library\Services\RegSettings.cpp
Starting at line 82 of D:\home\eCora_PM\PM\agent\agent\apps\Client\AgentSvc\Settings.cpp

CSetting::operator tstring() const
{
    DWORD type = REG_SZ;
    DWORD cBuf = 0;

    // Data length
    LONG res = ::RegQueryValueEx(m_key,
        m_name.c_str(),
        0, &type, 0, &cBuf);
    if (ERROR_SUCCESS != res)
        throw std::logic_error(("Could not read registry value length for " +
            TStringConverter::convert<std::string>(m_name)).c_str());

    boost::scoped_array<BYTE> buf(new BYTE[cBuf]);

    // String itself
    res = ::RegQueryValueEx(m_key,
        m_name.c_str(),
        0, &type, buf.get(), &cBuf);
    if (ERROR_SUCCESS != res)
        throw std::logic_error(("Could not read registry value data for " +
            TStringConverter::convert<std::string>(m_name)).c_str());

    tstring retVal = reinterpret_cast<const TCHAR*>(buf.get());
    return retVal;
}
=====================================================================
Found a 37 line (169 tokens) duplication in the following files: 
Starting at line 934 of D:\home\eCora_PM\PM\unix-collector\UnixConnection.cc
Starting at line 429 of D:\home\eCora_PM\PM\unix-collector\UnixDeviceCollector.cc

UnixDeviceCollector::tokenize(const bstring& s)
{ 
    bstring::size_type f = 0, l;
    vector<bstring> ss;
 
    if (!s.empty())
    { 
	while ((s[f] == ' ') || (s[f] == '\t'))
	    ++f;

        while (true)
        { 	    
            l = s.find(' ', f);
	    bstring::size_type x = s.find('\t', f);
	    
	    if (x < l)
		l = x;
	    
            ss.push_back(bstring(s, f, l - f));
	    
            if (l == bstring::npos)
                break;
	    
	    while ((s[l] == ' ') || (s[l] == '\t'))
		++l;
	    
            f = l;
	    
	    if (f == s.size())
		break;
        }
    }
    return ss;
}


void
=====================================================================
Found a 41 line (169 tokens) duplication in the following files: 
Starting at line 607 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h
Starting at line 655 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h

    void testDirWithFileOnlyFilter()
    {
        /** scenario:
        1. create _empty_ storage
        2. add _one_ file there
        3. get directory content
            and make sure there is only one file we add (set Files filter)
        4. remove this file
        */

        TS_ASSERT_THROWS_NOTHING(load());
        WindowsStorage storage(m_resources[WindowsStoragePathExistTest],
            g_App->services());

        // make sure environment set up for test
        try
        {
            storage.connect();
            if (storage.exists())
            {
                QDir d(QDir::convertSeparators(ws2qs(
                    m_resources[WindowsStoragePathExistTest])));
                d.rmdir(d.path());
            }
        }
        catch (GenericException&)
        {
            TS_FAIL("Couldn't set up environment for test.");
        }

        TS_ASSERT_THROWS_NOTHING(storage.create());
        TS_ASSERT_EQUALS(storage.exists(), true);
        // storage is created
        // let's add file there
        fs::FileSystem* fs = g_App->appServices()->disk()->systemHome();
        wstring fileName = L"testsettings.xml";
        wstring fullName = fs->fullPath (fileName);
        TS_ASSERT_THROWS_NOTHING (storage.addFile(fullName, fileName, 0, 0));
        // file added
        // getting the directory content
        vector<wstring> dirList = storage.dir (L"", QDir::Files);
=====================================================================
Found a 19 line (169 tokens) duplication in the following files: 
Starting at line 118 of D:\home\eCora_PM\PM\patchManager\SystemTabBuilder.cpp
Starting at line 290 of D:\home\eCora_PM\PM\patchManager\SystemTabBuilder.cpp

    m_listview->addColumn(QObject::tr("Rollback"), 70);
    m_listview->addColumn(QObject::tr("System/Unbundled"), 100);
    m_listview->addColumn(QObject::tr("Status"), 100);
    m_listview->addColumn(QObject::tr("Risk"), 100);
    m_listview->addColumn(QObject::tr("Patch Name"), 80);
    m_listview->addColumn(QObject::tr("Recommended"), 80);
    m_listview->addColumn(QObject::tr("Security"), 50);
    m_listview->addColumn(QObject::tr("Y2K"), 30);
    m_listview->addColumn(QObject::tr("Prerequisites"), 75);
    m_listview->addColumn(QObject::tr("Special Instructions"), 100);
    m_listview->addColumn(QObject::tr("Packages"), 100);

    m_listview->setColumnAlignment(5, Qt::AlignCenter);

    m_listview->setAllColumnsShowFocus(TRUE);
    m_listview->setShowSortIndicator(TRUE);
}

void 
=====================================================================
Found a 25 line (169 tokens) duplication in the following files: 
Starting at line 43 of D:\home\eCora_PM\PM\network\Ftp.h
Starting at line 39 of D:\home\eCora_PM\PM\network\GeneralClient.h

    virtual ~GeneralClient();

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(
	const GUID& iid, void** ptr);
    virtual unsigned long STDMETHODCALLTYPE AddRef();
    virtual unsigned long STDMETHODCALLTYPE Release();


    /**
     * See com/INetwork.h for a description of the following functions.
     */

    virtual bool url2wstring(
        const wstring& url, wstring* content = 0, 
        bool runInThread = true, com::NetworkResult** result = 0);
    virtual bool url2file(
        const wstring& url, const wstring& file, 
        bool runInThread = true, com::NetworkResult** result = 0);
    virtual void useProxy(const wstring& addr, const wstring& login, 
        const wstring& pass, const bool useNTLM);
    virtual void setCredentials(const wstring& login, const wstring& pass);
    virtual void addListener(com::NetworkListener* listener);
    virtual void removeListener(com::NetworkListener* listener);
    virtual void abort();
    virtual void freeResult(com::NetworkResult* result) const;
=====================================================================
Found a 30 line (169 tokens) duplication in the following files: 
Starting at line 141 of D:\home\eCora_PM\PM\adsi\ADSIExports.h
Starting at line 90 of D:\home\eCora_PM\PM\adsi\StdAfx.h

typedef IADs *PIADs;

#include "errormsg.h"		// tstring must be defined 

// boolean to string macro
#define B2SZ(n) ((n) ? _T("1") : _T("0"))


typedef HRESULT (__stdcall * ADSI_GetObject)
    (LPWSTR lpszPathName, REFIID riid, VOID **ppObject);
typedef HRESULT (__stdcall * ADSI_OpenObject)
    (LPWSTR lpszPathName, LPWSTR lpszUserName, LPWSTR lpszPassword, 
     DWORD dwReserved, REFIID riid, VOID FAR * FAR *ppObject);
typedef HRESULT (__stdcall * ADSI_BuildEnumerator)
    (IADsContainer *pADsContainer, IEnumVARIANT **ppEnumVariant);
typedef HRESULT (__stdcall * ADSI_EnumerateNext)
    (IEnumVARIANT *pEnumVariant, ULONG cElements, VARIANT FAR *pvar, 
     ULONG FAR *pcElementsFetched);
typedef HRESULT (__stdcall * ADSI_FreeEnumerator)(IEnumVARIANT *pEnumVariant);
typedef HRESULT (__stdcall * ADSI_GetLastError)
    (LPDWORD lpError, LPWSTR lpErrorBuf, DWORD dwErrorBufLen, 
     LPWSTR lpNameBuf, DWORD dwNameBufLen);
typedef BOOL (__stdcall * ADSI_FreeADsMem)(LPVOID pMem);

extern ADSI_GetObject g_fpGetObject;
extern ADSI_OpenObject g_fpOpenObject;
extern ADSI_BuildEnumerator g_fpBuildEnumerator;
extern ADSI_EnumerateNext g_fpEnumerateNext;
extern ADSI_FreeEnumerator g_fpFreeEnumerator;
extern ADSI_GetLastError g_fpGetLastError;
=====================================================================
Found a 29 line (168 tokens) duplication in the following files: 
Starting at line 977 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 865 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::loadGroups");
    // internal database
    CComQIPtr<com::IAppDatabase> pAppDatabase(g_App->services());
    _IfNullPtrRet(pAppDatabase);

    // systems container
    CComPtr<com::IDbContainer> pDbContainer;
    HRESULT hr = pAppDatabase->getDbContainer(&pDbContainer);
    _IfFailHrRet(hr);

    // load systems
    if (!groupsNode.isNull())
    {
        // register container for groups
        hr = pDbContainer->registerObjectType((IUnknown*)&idb::GroupObject());
        _IfFailHrRet(hr);

        QDomElement element = groupsNode.firstChild().toElement();
        while (!element.isNull())
        {
            QString qsKey = element.attributeNode(GroupID).value();
            if (qsKey.length())
            {
                selected[qs2ws(qsKey)] = idb::GroupObject(qsKey).clone(true);
            }
            element = element.nextSibling().toElement();
        }
    }
    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::loadGroups, exiting");
=====================================================================
Found a 44 line (167 tokens) duplication in the following files: 
Starting at line 16 of D:\home\eCora_PM\PM\network\ConnectionsExceptions.h
Starting at line 16 of D:\home\eCora_PM\PM\network\network\ConnectionsExceptions.h

using namespace std;

namespace network {

class RemoteLoginError : public GenericException
{
  public:
    RemoteLoginError(const char* file,
		   const int line,
		   const wstring& function,
		   const wstring& parameters,
		   const wstring& message) :
	GenericException(L"Connections::Remote login error",
			 file, line, function, parameters, message)
    {}
};

class InvalidRootPasswordError : public GenericException
{
  public:
    InvalidRootPasswordError(const char* file,
		   const int line,
		   const wstring& function,
		   const wstring& parameters,
		   const wstring& message) :
	GenericException(L"Connections::Invalid root password error",
			 file, line, function, parameters, message)
    {}
};

class NoConnectionError : public GenericException
{
  public:
    NoConnectionError(const char* file,
		   const int line,
		   const wstring& function,
		   const wstring& parameters,
		   const wstring& message) :
	GenericException(L"Connections::No connection error",
			 file, line, function, parameters, message)
    {}
};

} // namespace connections
=====================================================================
Found a 21 line (166 tokens) duplication in the following files: 
Starting at line 405 of D:\home\eCora_PM\PM\bzip2\blocksort.c
Starting at line 433 of D:\home\eCora_PM\PM\bzip2\blocksort.c

   i1++; i2++;
   /* 8 */
   c1 = block[i1]; c2 = block[i2];
   if (c1 != c2) return (c1 > c2);
   i1++; i2++;
   /* 9 */
   c1 = block[i1]; c2 = block[i2];
   if (c1 != c2) return (c1 > c2);
   i1++; i2++;
   /* 10 */
   c1 = block[i1]; c2 = block[i2];
   if (c1 != c2) return (c1 > c2);
   i1++; i2++;
   /* 11 */
   c1 = block[i1]; c2 = block[i2];
   if (c1 != c2) return (c1 > c2);
   i1++; i2++;
   /* 12 */
   c1 = block[i1]; c2 = block[i2];
   if (c1 != c2) return (c1 > c2);
   i1++; i2++;
=====================================================================
Found a 35 line (166 tokens) duplication in the following files: 
Starting at line 1885 of D:\home\eCora_PM\PM\agent\afCommon\WbemHelper.cpp
Starting at line 1505 of D:\home\eCora_PM\PM\wmi\WmiCollector.cpp

        char szUser[MAX_PATH], szAuthority[MAX_PATH], szPassword[MAX_PATH];

        // Fill in the indentity structure

        if (UserArg)
        {
            wcstombs(szUser, UserArg, MAX_PATH);
            authident.UserLength = strlen(szUser);
            authident.User = (LPWSTR)szUser;
        }
        if (AuthArg)
        {
            wcstombs(szAuthority, AuthArg, MAX_PATH);
            authident.DomainLength = strlen(szAuthority);
            authident.Domain = (LPWSTR)szAuthority;
        }
        if (pPassword)
        {
            wcstombs(szPassword, pPassword, MAX_PATH);
            authident.PasswordLength = strlen(szPassword);
            authident.Password = (LPWSTR)szPassword;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
    }
    sc = CoSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT,
                        RPC_C_AUTHZ_NONE, NULL,
                        dwAuthLevel, dwImpLevel,
                        &authident, EOAC_NONE);

    if (UserArg)
        SysFreeString(UserArg);
    if (AuthArg)
        SysFreeString(AuthArg);
    return sc;
}
=====================================================================
Found a 25 line (165 tokens) duplication in the following files: 
Starting at line 213 of D:\home\eCora_PM\PM\pmPush\OptimizerTest.h
Starting at line 261 of D:\home\eCora_PM\PM\pmPush\OptimizerTest.h

    void testBasicOptimization()
    {
        vector<AnnotatedAction*> sequence1 = createActionSequence(
            L"namespace",
            L"action1", L"", L"param1", L"value1", L"param2", L"value2", NULL,
            L"action2", L"", L"param5", L"value5", NULL,
            L"action3", L"", NULL,
            L"reboot", L"", L"meta:cost", L"1", NULL,
            NULL);

        vector<AnnotatedAction*> sequence2 = createActionSequence(
            L"namespace",
            L"action21", L"", L"param1", L"value1", L"param2", L"value2", NULL,
            L"action22", L"", L"param5", L"value5", NULL,
            L"action23", L"", NULL,
            L"reboot", L"", L"meta:cost", L"1", NULL,
            NULL);

        vector<AnnotatedAction*> sequence3 = createActionSequence(
            L"namespace",
            L"action1", L"", L"param1", L"value1", L"param2", L"value2", NULL,
            L"action2", L"", L"param5", L"value5", NULL,
            L"action3", L"", NULL,
            L"reboot", L"", L"meta:cost", L"1", NULL,
            NULL);
=====================================================================
Found a 31 line (165 tokens) duplication in the following files: 
Starting at line 325 of D:\home\eCora_PM\PM\daoXmlImpl\XmlDaoBase.cpp
Starting at line 168 of D:\home\eCora_PM\PM\pmDaoXmlImpl\XmlDaoBase.cpp

            qs2ws(attrElem.text()) == criteria->getAttrValue(metaElem.getCriteriaAttribute()))
        {
            resEntities->push_back(*entityWithNameIt);
        }
    }
}

void
XmlDaoBase::processSelectCondition(const daoBase::XmlMetaElement& metaElem, const daoBase::CriteriaBase* criteria,
    const QDomElement& entity, EntityList* resEntities)
{
    assert(!metaElem.getAttribute().empty());
    assert(resEntities);

    EntityList entitiesWithName;
    entitiesByName(metaElem.getName(), entity, &entitiesWithName);

    EntityList::iterator entityWithNameIt = entitiesWithName.begin();
    for (; entityWithNameIt != entitiesWithName.end(); ++entityWithNameIt)
    {
        QDomElement attrElem = entityWithNameIt->namedItem(ws2qs(metaElem.getAttribute())).toElement();

        if (!attrElem.isNull() && qs2ws(attrElem.text()) == metaElem.getValue())
        {
            resEntities->push_back(*entityWithNameIt);
        }
    }
}

void
XmlDaoBase::processReturn(const daoBase::XmlMetaElement& metaElem, const daoBase::CriteriaBase* criteria,
=====================================================================
Found a 32 line (164 tokens) duplication in the following files: 
Starting at line 75 of D:\home\eCora_PM\PM\daoDbImpl\CDocCache.cpp
Starting at line 93 of D:\home\eCora_PM\PM\pmDbCache\CDocCache.cpp

    InterlockedIncrement(&m_CallCount);//statistics
    map<wstring, CCacheItem*>::iterator ItemIterator = m_mItems.find(Key);
    if (ItemIterator != m_mItems.end())
    {
        InterlockedIncrement(&m_HitCount);//statistics
        InterlockedIncrement(&m_mItems[Key]->HitCount);//statistics
        *item = (CFileCacheItem*)m_mItems[Key];
        m_pRWLocker->LeaveReader();
        return true;
    }
    m_pRWLocker->LeaveReader();
    return false;
}

bool CDocCache::putItem(wstring Key, CFileCacheItem *item)
{
    m_pRWLocker->EnterWriter();

    map<wstring, CCacheItem*>::iterator ItemIterator = m_mItems.find(Key);
    if (ItemIterator != m_mItems.end())
    {
        m_pRWLocker->LeaveWriter();
        return false;
    }

    item->HitCount = 0;
    m_mItems[Key] = item;
    m_PutCount++;//statistics

    m_pRWLocker->LeaveWriter();
    return true;
}
=====================================================================
Found a 21 line (163 tokens) duplication in the following files: 
Starting at line 281 of D:\home\eCora_PM\PM\snoopy\listbox.cpp
Starting at line 319 of D:\home\eCora_PM\PM\snoopy\listbox.cpp

			int curSel = 0;
			TCHAR* sit = _tcsstr(
			    m_labels[m_selected[curSel]].c_str(), _T("ou="));
			PCTSTR s = sit ? sit + 3 :
			    m_labels[m_selected[curSel]].c_str();
			WAddExtentEntry(aWnd, s);
			int addedStringIndex =
			    SendMessage(aWnd, LB_ADDSTRING,
					(WPARAM)(0), (LPARAM)s);
			for (int j = m_lastAvailable;
			     j > addedStringIndex; j--)
			    m_available[j] = m_available[j - 1];
			m_available[addedStringIndex] = m_selected[curSel];
                        DecreaseSelectionNumber(s);
			//m_lastAvailable++;
			//m_lastSelected --;
			for (j = curSel; j < m_lastSelected; ++j)
			    m_selected[j] = m_selected[j + 1];
			WRemoveExtentEntry(sWnd, curSel);
			SendMessage(sWnd, LB_DELETESTRING, (WPARAM)curSel, 0);
		    }
=====================================================================
Found a 36 line (163 tokens) duplication in the following files: 
Starting at line 650 of D:\home\eCora_PM\PM\daoXmlImpl\XmlDaoBase.cpp
Starting at line 411 of D:\home\eCora_PM\PM\pmDaoXmlImpl\XmlDaoBase.cpp

    return getRelatedEntities(relEntityTagName, *m_crtEntity);
}

XmlDaoBase::EntityList
XmlDaoBase::getRelatedEntities(const wstring& relEntityTagName, const QDomElement& entity)
{
    assert(!entity.isNull());

    QDomNodeList entityElemList = entity.elementsByTagName(ws2qs(relEntityTagName));

    EntityList entityList;
    for (unsigned int entElemIdx = 0; entElemIdx < entityElemList.length(); ++entElemIdx)
    {
        QDomElement entity = entityElemList.item(entElemIdx).toElement();
        assert(!entity.isNull());

        entityList.push_back(entity);
    }

    return entityList;
}

void
XmlDaoBase::clearEntityRefs()
{
    m_entities.clear();
    m_crtEntity = m_entities.end();
}

void
XmlDaoBase::removeEntities()
{
    EntityList::iterator entityIt = m_entities.begin();
    for (; entityIt != m_entities.end(); ++entityIt)
    {
        entityIt->clear();
=====================================================================
Found a 29 line (162 tokens) duplication in the following files: 
Starting at line 313 of D:\home\eCora_PM\PM\pmPush\OptimizerTest.h
Starting at line 355 of D:\home\eCora_PM\PM\pmPush\OptimizerTest.h

            L"end", L"", L"meta:cost", L"1", L"meta:endsMode", L"unique", NULL,
            NULL);

        vector<AnnotatedAction*> sequence2 = createActionSequence(
            L"namespace",
            L"start", L"", L"meta:cost", L"1", NULL,
            L"middle2", L"", L"param5", L"value5", NULL,
            L"end", L"", L"meta:cost", L"1", NULL,
            NULL);

        Optimizer opt;
        opt.addActionSequence(sequence1);
        opt.addActionSequence(sequence2);

        vector<AnnotatedAction*> result = opt.optimizeSequence();
        Analysis an = analyzeOutput(result);

        // See comment in previous test
        int location = an[L"middle"].front();
        TS_ASSERT(location > 0 && location < result.size() - 1);
        TS_ASSERT_EQUALS(result[location - 1]->name(), L"start");
        TS_ASSERT_EQUALS(result[location + 1]->name(), L"end");
        TS_ASSERT_EQUALS(result.size(), 5);
    }

    /**
     * Verify that action sequences whose locks to not match up get exceptions thrown
     */
    void testBadLockedSequences()
=====================================================================
Found a 33 line (162 tokens) duplication in the following files: 
Starting at line 74 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\OfficePatch.cpp
Starting at line 73 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\SqlPatch.cpp

SqlPatch::prepareForPushAgent(bool useRepo, bool transferOnly)
{
    HRESULT hr;
    patchRepository::IRepositoryManager* repo = 0;
    hr = appIface()->QueryInterface(IID_IRepositoryManager, reinterpret_cast<void**>(&repo));
    if (FAILED(hr))    
    {
        throw GenericException(__FILE__, __LINE__, L"Patch::prepareForPush", 
                                L"", L"Failed to obtain an interface to the repository.");        
    }

    wstring repoPath = repo->uncPath(langKey(), getPmSelectData()->getHostId(),
        pmPushBaseModel::IComputer::OptionalAgent); // AltRepo FIX by StUV
    
    if (!repoPath.empty())
    {
        wstring dir = repoPath + L"\\";
        setFullRepoPath(dir + displayName());
        setDir(dir);
    }

    unsigned long size = 0;
    if (!useRepo || transferOnly)
    {
        size = repo->patchSize(langKey());
    }

    repo->Release();

    return size;
}

unsigned long 
=====================================================================
Found a 32 line (162 tokens) duplication in the following files: 
Starting at line 593 of D:\home\eCora_PM\PM\hostManager\ObjectView.cpp
Starting at line 665 of D:\home\eCora_PM\PM\hostManager\ObjectView.cpp

    for (int idx = 0; idx < iSelections; ++idx)
    { 
        QTableSelection selection = EsDataTableObject->selection(iCounter);
        int iTopRow = selection.topRow();
        int iBottomRow = selection.bottomRow();

        iProgressSize = iBottomRow - iTopRow  + 1;
    }

    m_pControl->setTotalSteps(iProgressSize);
    iProgressSize = 0;

    for (idx = 0; idx < iSelections; ++idx)
    { 
        QTableSelection selection = EsDataTableObject->selection(idx);

        int iTopRow = selection.topRow();
        int iBottomRow = selection.bottomRow();

        for (int iter = iTopRow; iter <= iBottomRow; ++iter)
        { 
            // get device key
            if (deviceCursor->seek(iter))
            { 
                QString qsKey = deviceCursor->value(0).toString();
                //extract device key
                TDevice device(m_pServices);
                hr = m_pDbContainer->retrieveObject(qsKey, (IUnknown*)&device);
                _IfFailHrRet(hr);

                //add relation
                hr = m_pRelation->removeRelation((IUnknown*)&group, (IUnknown*)&device);
=====================================================================
Found a 26 line (162 tokens) duplication in the following files: 
Starting at line 155 of D:\home\eCora_PM\PM\configWizard\ConfigWizard.cpp
Starting at line 1058 of D:\home\eCora_PM\PM\patchManager\PatchUpdate.cpp

        DWORD hHandle;
        long nVersion = 0, nSubVersion = 0, nBuild1 = 0, nBuild2 = 0;
        int nInfoSize = GetFileVersionInfoSize((wchar_t*)szFileName.c_str(), &hHandle);
        if (nInfoSize)
        {
            wchar_t* VerInfo = new wchar_t[nInfoSize + 1];
            if (GetFileVersionInfo((wchar_t*)szFileName.c_str(), 0, nInfoSize + 1, VerInfo))
            {
                VS_FIXEDFILEINFO* lpVerInfo;
                UINT Len;

                if (VerQueryValue(VerInfo, _T("\\"), (void**)&lpVerInfo, &Len))
                {
                    DWORD dwProductVersionMS;
                    DWORD dwProductVersionLS;

                    dwProductVersionMS = lpVerInfo->dwProductVersionMS ;
                    dwProductVersionLS = lpVerInfo->dwProductVersionLS ;

                    nVersion    = HIWORD(dwProductVersionMS);
                    nSubVersion = LOWORD(dwProductVersionMS);
                    nBuild1     = HIWORD(dwProductVersionLS);
                    nBuild2     = LOWORD(dwProductVersionLS);
                }
            }
            delete VerInfo;
=====================================================================
Found a 15 line (161 tokens) duplication in the following files: 
Starting at line 266 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp
Starting at line 274 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp

void PatchProperties::onClick(int row, int col, const QPoint & point)
{
    QPopupMenu menu(this);
    menu.insertItem(tr("Add"), this, SLOT(add()), 0, 1, 1);
    menu.insertItem(tr("Edit"), this, SLOT(edit()), 0, 2, 3);
    menu.insertItem(tr("Remove"), this, SLOT(remove()), 0, 3, 3);
    if (!m_bEdit->isEnabled())
        menu.setItemEnabled(2, false);
    if (!m_bRemove->isEnabled())
        menu.setItemEnabled(3, false);
    QPoint p(point.x() + 2, point.y() + 2);
    menu.exec(p);
}

void PatchProperties::onDblClick()
=====================================================================
Found a 36 line (160 tokens) duplication in the following files: 
Starting at line 1977 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 465 of D:\home\eCora_PM\PM\patchRepository\RepositorySettingsQT.cpp

            ws2qs(path), this, "browseForDataDir", caption, true));
        // user cancelled
        if (path.empty())
        {
            log(L"patchRepository", Log::Debug, L"User cancelled - path not altered");
            return;
        }

        // qt322 returns all slashes as '/'
        // WNetGetUnversalName doesn't like this so convert them to '\\'
        path = convertSlashes(path);
        log(L"patchRepository", Log::Debug, L"user selected path " << path);

        // this will convert mapped drives to UNC format
        DWORD len = 2048;
        WCHAR buff[2048];
        UNIVERSAL_NAME_INFO* info = (UNIVERSAL_NAME_INFO*)&buff;
        DWORD result;
        if ((result = WNetGetUniversalName((LPWSTR)path.c_str(), UNIVERSAL_NAME_INFO_LEVEL, &info, &len)) == NO_ERROR)
        {
            path = buff;
            log(L"patchRepository", Log::Debug, L"Path was mapped drive " << path);
        }

        // if we still have a local path, try to see if any sub-directories are shared
        // and convert to UNC format
        if (isLocalPath(path))
        {
            path = determineUNCPath(path);
            log(L"patchRepository", Log::Debug, L"Path was local " << path);
        }

        // if we still have a local path, show error message
        // FIXME in future should allow repository to be local, but then must make sure
        // that push cannot use the "execute directly from repository" option
        if (isLocalPath(path))
=====================================================================
Found a 48 line (160 tokens) duplication in the following files: 
Starting at line 30 of D:\home\eCora_PM\PM\alerts\monitor\moduleContainer.cpp
Starting at line 27 of D:\home\eCora_PM\PM\pmServices\ModuleContainer.cpp

}

ModuleContainer::~ModuleContainer()
{
}

HRESULT
ModuleContainer::QueryInterface(const GUID& iid, void** ptr)
{
    if (m_baseObject.getUnkOuter() != 0)
    {
        return m_baseObject.getUnkOuter()->QueryInterface(iid, ptr);
    }
    else if (iid == IID_IUnknown)
    {
        *ptr = (IUnknown*)this;
        AddRef();
        return NO_ERROR;
    }
    else if (iid == IID_IModuleContainer)
    {
        *ptr = (com::IModuleContainer*)this;
        AddRef();
        return NO_ERROR;
    }
    else
    {
        *ptr = 0;
        return E_NOINTERFACE;
    }
}

unsigned long
ModuleContainer::AddRef()
{
    return m_baseObject.addRef();
}

unsigned long
ModuleContainer::Release()
{
    return m_baseObject.release(this);
}

com::IModule*
ModuleContainer::currentModule() const
{
    return (com::IModule*)m_app->currentModule();
=====================================================================
Found a 5 line (159 tokens) duplication in the following files: 
Starting at line 89 of D:\home\eCora_PM\PM\zlib\trees.h
Starting at line 111 of D:\home\eCora_PM\PM\zlib\trees.h

25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
=====================================================================
Found a 37 line (159 tokens) duplication in the following files: 
Starting at line 1625 of D:\home\eCora_PM\PM\patchManager\App.cpp
Starting at line 92 of D:\home\eCora_PM\PM\pmWindowsService\App.cpp

	L"/bin/EcoraPatchManager.exe " + wsTopic;
    return launchProgramEx(commandLine);
}

///////////////////////////////////////////////////////////////////////////////
int 
ApplicationWindow::launchProgramEx(const wstring& commandLine)
{
    auto_ptr<wchar_t> comline(new wchar_t[commandLine.size() + 1]);
    wcscpy(comline.get(), commandLine.c_str());
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    memset(&si, 0, sizeof(si));
    si.cb = sizeof(STARTUPINFO);
    si.lpDesktop = NULL;

    BOOL res = CreateProcess(
	NULL,
	comline.get(),     // lpCommandLine
	NULL,              // lpProcessAttributes
	NULL,              // lpThreadAttributes
	FALSE,             // bInheritHandles
	DETACHED_PROCESS | IDLE_PRIORITY_CLASS,  // dwCreationFlags
	NULL,              // lpEnvironment
	NULL,              // lpCurrentDirectory
	&si,               // lpStartupInfo
	&pi                // lpProcessInformation
	);

    if (!res) {
	log(L"patchManager", Log::Error, L"Unable to launch the application - " + 
	    commandLine + L": " + int2wstring(GetLastError()));
	return 1;
    }
    return 0;
}
=====================================================================
Found a 22 line (159 tokens) duplication in the following files: 
Starting at line 1037 of D:\home\eCora_PM\PM\alerts\alertsUI\BrowserQT.cc
Starting at line 1065 of D:\home\eCora_PM\PM\alerts\alertsUI\BrowserQT.cc

TriggerBrowserQT::disableTask()
{
    if (qs2ws(m_showButton->text()) != qs2ws(QObject::tr("Sho&w Templates")))
	return;

    vector<Trigger*>& triggerList = m_alertSettings->getAlertSettings()->getTriggers();
    for (QListViewItemIterator it(m_browserList->firstChild()); 
		it.current(); ++it) 
    {
        if (!it.current()->isSelected())
	    continue;
	QListViewItem* item = it.current();    
	
	wstring id = qs2ws(item->text(3));
	Trigger* trigger = 0;
	for (int i = 0; i < triggerList.size(); ++i)
	    if (triggerList[i]->getId() == id)
		trigger = triggerList[i];

	if (trigger != 0)
	{
	    trigger->setEnabled(false);
=====================================================================
Found a 28 line (159 tokens) duplication in the following files: 
Starting at line 81 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketClient.h
Starting at line 81 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketServer.h

    virtual void OnConnectionEstablished(Socket *pSocket, CIOBuffer *pAddress) = 0;
    virtual void OnConnectionClosed(Socket * /*pSocket*/) {}
    virtual void OnConnectionDestroyed() {}

    virtual void OnError(const _tstring &message);

    virtual void OnBufferCreated() {}
    virtual void OnBufferAllocated() {}
    virtual void OnBufferReleased() {}
    virtual void OnBufferDestroyed() {}

    Socket* AllocateSocket(SOCKET theSocket);

    void ReleaseSocket(Socket* pSocket);
    void DestroySocket(Socket* pSocket);
    void PostAbortiveClose(Socket* pSocket);
    void Read(Socket* pSocket, CIOBuffer* pBuffer);
    void Write(Socket* pSocket, const char* pData, size_t dataLength, bool thenShutdown);
    void Write(Socket* pSocket, CIOBuffer* pBuffer, bool thenShutdown);

    const size_t m_numThreads;
    CCriticalSection m_listManipulationSection;
        
    typedef remotetools::TNodeList<Socket> SocketList;
    SocketList m_activeList;
    SocketList m_freeList;
    
    SOCKET m_listeningSocket;
=====================================================================
Found a 27 line (159 tokens) duplication in the following files: 
Starting at line 55 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\HandleIIS.cpp
Starting at line 264 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\HandleIIS.cpp
Starting at line 440 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\HandleIIS.cpp

   	ReportMessage(hInstall, _T("NORMAL"), _T("checkVirDirExistence started"));

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        ReportError(hInstall, __FILE__, __LINE__, _T("CoInitializeEx failed. Error %d"), hr);
        return uiRet;
    }

    bufLen = 0;
    uiStat =  MsiGetPropertyW(hInstall, L"WEBSITELIST", L"", &bufLen);
    if (ERROR_MORE_DATA == uiStat)
    {
        bufLen += sizeof(WCHAR);
        siteNum = (WCHAR*)calloc(bufLen, sizeof(WCHAR));
        if (NULL == siteNum)
        {
            ReportError(hInstall, __FILE__, __LINE__, _T("Can't allocate buffer for siteNum. Error %ld"), GetLastError());
            goto l_end;
        }
        uiStat = MsiGetPropertyW(hInstall, L"WEBSITELIST", siteNum, &bufLen);
    }
    if (ERROR_SUCCESS != uiStat)
    {
        ReportError(hInstall, __FILE__, __LINE__, _T("Getting WEBSITELIST property failed. RetCode=%d"), uiStat);
        goto l_end;
    }
=====================================================================
Found a 13 line (158 tokens) duplication in the following files: 
Starting at line 103 of D:\home\eCora_PM\PM\pmXmlProvider\DataProvider.h
Starting at line 39 of D:\home\eCora_PM\PM\pmXmlProvider\EcoQueryDB.h

    void getSpID(const wstring&, const wstring&, wstring&);
    void getSpID(const wstring&, wstring&);
    void getPatchInfo(wstring&, wstring&, wstring&);
    void getSpName(const wstring&, wstring&, wstring&);
    void getNewerSpIDs(const wstring&, vector<wstring>&);
    void getPath(const wstring&, wstring&);
    void getCmdLine(const wstring&, wstring&);
    void getAllNewerSPs(const wstring&, const wstring&, 
			vector<pair<wstring, wstring> >&);
    void getSpIDFromProductAndVersion(const wstring&, const wstring&, wstring&);
    void getSpInfo(const wstring&, const wstring&, wstring&, wstring&, wstring&);
    void getSpRV(const wstring&, const wstring&, wstring&);
    void sendQueryDB(wstring whereAttributes[], 
=====================================================================
Found a 20 line (158 tokens) duplication in the following files: 
Starting at line 52 of D:\home\eCora_PM\PM\alerts\alertslib\EventTrigger.cc
Starting at line 570 of D:\home\eCora_PM\PM\alerts\alertslib\event.cc

		m_variables[i]->getName());
	    try { 
		if (varType == L"list")
		{
		    wstring tag = xmlName + L"s";
		    xml::BaseNode* base = node->query(tag.c_str(), 0);
		    xml::Node* varNode = static_cast<xml::Node*>(base);
		    vector<wstring> values;
		    if (varNode != 0)
		    {
			// get all trigger nodes, 
			vector<xml::BaseNode*> result;
			wstring nodeType = xmlName;
			varNode->query(result, nodeType.c_str(), 0);
			vector<wstring> values;
			for (int j = 0; j < result.size(); ++j)
			{
			    wstring value = getStringAttribute(static_cast<xml::Node*> (result[j]), L"name");
			    values.push_back(value);
			}
=====================================================================
Found a 27 line (157 tokens) duplication in the following files: 
Starting at line 262 of D:\home\eCora_PM\PM\pmpushWinShared\BaseUtils.cpp
Starting at line 297 of D:\home\eCora_PM\PM\pmpushWinShared\BaseUtils.cpp

BaseUtils::decrypt(const wstring& ciphertext, const wstring& certname)
{
    wstring password;
    password = Blowfish::defaultPassword();

    auto_ptr<Blowfish> fish;
    auto_ptr<Blowfish::Certificate> cert;

    if (certname.empty())
    {
        fish = auto_ptr<Blowfish>(new Blowfish(ws2utf8s(password).c_str()));
    }
    else
    {
        cert = auto_ptr<Blowfish::Certificate>(Blowfish::loadCertificate(certname));
        if (0 == cert.get())
        {
            cert = auto_ptr<Blowfish::Certificate>(Blowfish::createCertificate(certname, 64));
	    //cert = Blowfish::createCertificate(certname, 64);
        }

        fish = auto_ptr<Blowfish>(new Blowfish(*(cert.get()), ws2utf8s(password).c_str()));
    }
    
    try 
    {
	return bstring2wstring((fish.get())->decodeData(ws2utf8s(ciphertext).c_str()));
=====================================================================
Found a 48 line (157 tokens) duplication in the following files: 
Starting at line 109 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\Patch.cpp
Starting at line 389 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\Patch.cpp

}

wstring 
Patch::scanKey() const 
{
    return base()->scanKey(); 
}

void 
Patch::setScanKey(const wstring& v) 
{
    base()->setScanKey(v); 
}

wstring 
Patch::systemScanKey() const 
{
    return base()->systemScanKey(); 
}

void 
Patch::setSystemScanKey(const wstring& v) 
{
    base()->setSystemScanKey(v); 
}

wstring 
Patch::productKey() const 
{
    return base()->productKey(); 
}

void 
Patch::setProductKey(const wstring& v) 
{
    base()->setProductKey(v); 
}
wstring 
Patch::versionKey() const 
{
    return base()->versionKey(); 
}

void 
Patch::setVersionKey(const wstring& v) 
{
    base()->setVersionKey(v); 
}
=====================================================================
Found a 45 line (157 tokens) duplication in the following files: 
Starting at line 415 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h
Starting at line 955 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h

    void testMoveFile()
    {
        /**
        scenario
        1. create test file, store some content there
        2. Add this file to repository
        3. Move this file to somewhere
        3. check whether exists in new location
        4. remove repository file
        */
        TS_ASSERT_THROWS_NOTHING(load());
        wstring fileName = m_resources[TempFileName];
        wstring content = L"1234567890";

        // trying to create temp file
        fs::FileSystem* fs = g_App->appServices()->disk()->systemHome();
        try
        {

            fs->wstring2file (fileName, content);
        }
        catch (...)
        {
            TS_FAIL("Can't create temporary file");
            return;
        }

        // adding this file to repository

        WindowsStorage storage(m_resources[WindowsStoragePathExistTest], g_App->services());

        // make sure environment set up for test
        try
        {
            storage.connect();
            if (!storage.exists())
                storage.create();
        }
        catch (GenericException&)
        {
            TS_FAIL("Couldn't set up environment for test.");
        }
        wstring fullName = fs->fullPath (fileName);
        TS_ASSERT_THROWS_NOTHING(storage.addFile (fullName, fileName, 0, 0));
        TS_ASSERT_EQUALS(storage.fileExists (fileName), true);
=====================================================================
Found a 28 line (156 tokens) duplication in the following files: 
Starting at line 61 of D:\home\eCora_PM\PM\solaris-collector\SolarisDeviceCollector.cc
Starting at line 53 of D:\home\eCora_PM\PM\solaris-collector\SolarisDeviceCollectorPM.cc

    log(L"SolarisDeviceCollectorPM::testSolarisVersion()", Log::Debug,
	L"Testing for a supported version of Solaris");
    
    bstring unameResponse = m_connection->responseToCommand(
	    "/bin/uname -a", 2);
    vector<bstring> fields = tokenize(unameResponse);
    
    if ((fields.size() > 2) && fields[0] == "SunOS")
    {
            //  Get the revision.  Only Solaris > 5 is interesting.
        bstring revNumber = fields[2].substr(0, fields[2].find("."));
        if (atoi(revNumber.c_str()) >= 5)
        {
            return;
        }
    }

    wstring errorMessage;
    if (fields.size() > 2)
        errorMessage = L"uname returned: " +
	    bstring2wstring(fields[0]) + L" " + bstring2wstring(fields[2]);
    else
	errorMessage = L"uname returned: unable to parse result";

    if (unameResponse.find("Command Timeout") != string::npos)
        errorMessage += L".  Possible login problem.  ";

    throw InvalidOSError(__FILE__, __LINE__,
=====================================================================
Found a 19 line (156 tokens) duplication in the following files: 
Starting at line 278 of D:\home\eCora_PM\PM\policyManager\PatchesRulesQT.cpp
Starting at line 161 of D:\home\eCora_PM\PM\policyManager\PatchesSelectionQT.cpp

    PatchSelListItem* parentItem = static_cast<PatchSelListItem*>(item->parent());
    wstring idVersion = (parentItem ? parentItem->id() : L"-1");

    // mark as selected these two items
    ProductContainer::iterator it = m_productList.begin();
    for (; it != m_productList.end(); ++it)
    {   // check for version now
	ProductVersionContainer::iterator itVersion = (*it)->beginVersion();
	for (; itVersion != (*it)->endVersion(); ++itVersion)
	{
	    if (idVersion != L"-1" && (*itVersion)->versionId() != idVersion)
		continue;

	    PatchContainer::iterator itPatch = (*itVersion)->begin();
	    for (; itPatch != (*itVersion)->end(); ++itPatch)
	    {   
		if ((*itPatch)->patchId() == idSelected)
		{
		    if (value != DisplayStatus::POLICY_PATCH_IGNORED)
=====================================================================
Found a 37 line (156 tokens) duplication in the following files: 
Starting at line 68 of D:\home\eCora_PM\PM\daoXmlImpl\XmlDaoBase.cpp
Starting at line 60 of D:\home\eCora_PM\PM\pmDaoXmlImpl\XmlDaoBase.cpp

XmlDaoBase::getAttrValue(const wstring& attrName, const EntityList::iterator& entityIt) const
{
    QDomElement attributeElement = entityIt->namedItem(ws2qs(attrName)).toElement();
    /**
    if (attributeElement.isNull())
    {
        wstring message(L"Attribute " + attrName + L" not found!");
        throw GenericException(__FILE__, __LINE__, L"XmlDaoBase::getAttrValue", attrName, message);
    }
    */

    return qs2ws(attributeElement.text());
}

void
XmlDaoBase::setAttr(const wstring& attrName, const wstring& value)
{
    setEntityAttr(m_crtEntity, attrName, value);
}

void
XmlDaoBase::setEntityAttr(QDomElement* entity, const wstring& attrName, const wstring& value)
{
    assert(entity);

    QDomText valueElem = getDoc()->createTextNode(ws2qs(value));

    QDomElement attrElem = entity->namedItem(ws2qs(attrName)).toElement();
    if (attrElem.isNull())
    {
        attrElem = getDoc()->createElement(ws2qs(attrName));
        attrElem.appendChild(valueElem);

        entity->appendChild(attrElem);
    }
    else
    {
=====================================================================
Found a 36 line (156 tokens) duplication in the following files: 
Starting at line 34 of D:\home\eCora_PM\PM\agent\agent\Library\PsExecLib\Logger.cpp
Starting at line 316 of D:\home\eCora_PM\PM\agent\agent\Library\PsExecLib\Pipe.cpp

    USES_CONVERSION;

    va_list args;
    va_start(args, format);

    std::vector<TCHAR> buff(0x1000);

    bool res = false;

    int ret = _vsntprintf(&buff[0], buff.size() - 1, format, args);
    if (ret >= 0)
    {
        buff[ret] = 0; //protect from CRT bug
        res = true;
    }
    else
    {
        std::vector<TCHAR>::size_type size = buff.size();
        for (;;)
        {
            size *= 2;
            buff.resize(size);

            ret = _vsntprintf(&buff[0], size - 1, format, args);
            if (ret >= 0)
            {
                buff[ret] = 0; //protect from CRT bug
                res = true;
                break;
            }
        }
    }

    va_end(args);

    if (res)
=====================================================================
Found a 23 line (155 tokens) duplication in the following files: 
Starting at line 3076 of D:\home\eCora_PM\PM\patchManager\App.cpp
Starting at line 861 of D:\home\eCora_PM\PM\patchManager\PatchMeisterLicense.cc

    idb::WindowsDevice dev(g_App->services());
    hr = pDbContainer->retrieveObject(ws2qs(pk), (IUnknown*)&dev);
    if (SUCCEEDED(hr))
    {

        QString qsValue = "";
        hr = ((com::IDbObject*)&dev)->getFieldValue(idb::DeviceInfo::DomainName, qsValue);
        domain = qs2ws(qsValue);
        if (domain.size())
            domain += L"\\";
        qsValue = "";
        hr = ((com::IDbObject*)&dev)->getFieldValue(idb::DeviceInfo::DeviceName, qsValue);
        system = qs2ws(qsValue);
        return true;
    }

    hr = pDbContainer->registerObjectType((IUnknown*)&idb::UnixDevice());
    if (!SUCCEEDED(hr))
    {
        return false;
    }

    idb::UnixDevice udev(g_App->services());
=====================================================================
Found a 34 line (155 tokens) duplication in the following files: 
Starting at line 66 of D:\home\eCora_PM\PM\fksec\apis.cpp
Starting at line 164 of D:\home\eCora_PM\PM\fksec\apis.cpp
Starting at line 360 of D:\home\eCora_PM\PM\fksec\apis.cpp

		if ( ::QueryServiceObjectSecurity( hSvc, whichParts, psd, needed, &needed ) )
			rc = 0;
		else
			rc = GetLastError();

		if ( rc == ERROR_INSUFFICIENT_BUFFER && ! haveRetriedSize )
		{
			delete [] (byte *) psd;
			psd = (SECURITY_DESCRIPTOR *) new byte[needed];
			haveRetriedSize = true;
		}
		else if ( rc == ERROR_PRIVILEGE_NOT_HELD && ! haveRetriedPrivilege )
		{
			try { oldSecPrivState = secPriv.Enable(); }
			catch ( ex *e ) { delete e; }
			haveRetriedPrivilege = true;
		}
		else
			break; // unrecoverable
	}

	if ( rc == 0 )
		sd = psd;

	delete [] (byte *) psd;

	if ( haveRetriedPrivilege ) // did we fuck with the privilege?
	{
		try { secPriv.SetState( oldSecPrivState ); }
		catch ( ex *e ) { delete e; } // just ignore errors here
	}

	if ( rc )
		throw NEWEX32( errUnreadableSD, "fksec::QueryServiceObjectSecurity(): cannot read SD, see ex::GetErrWin32()", rc );
=====================================================================
Found a 33 line (155 tokens) duplication in the following files: 
Starting at line 33 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\resume_updownload.cpp
Starting at line 30 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\suspend_resume.cpp

        activation_enqueue(new shutdown_core_MR);
		return true;
    }

    stream << ECORA_TEXT("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")
           << ECORA_TEXT("<job scheduleType=\"RunByCronSchedule\" scheduleCron=\"\" priority=\"0\">\n")
           << ECORA_TEXT("<id>") << ++m_job_id << ECORA_TEXT("</id>\n")
           << ECORA_TEXT("<type>system</type>\n")
           << ECORA_TEXT("<package>system 1.0.0.1</package>\n")
           << ECORA_TEXT("<command><![CDATA[ping -n 1 127.0.0.1]]></command>\n")
           << ECORA_TEXT("<envVars>\n")
           << ECORA_TEXT("<envVar name=\"var1\"><![CDATA[val1]]></envVar>\n")
           << ECORA_TEXT("<envVar name=\"var2\"><![CDATA[val2]]></envVar>\n")
           << ECORA_TEXT("<envVar name=\"var3\"><![CDATA[val3]]></envVar>\n")
           << ECORA_TEXT("</envVars>\n")
           << ECORA_TEXT("<tempFiles>\n")
           << ECORA_TEXT("<tempFile name=\"tf1.dat\"><![CDATA[t1]]></tempFile>\n")
           << ECORA_TEXT("<tempFile name=\"tf2.dat\"><![CDATA[t2]]></tempFile>\n")
           << ECORA_TEXT("<tempFile name=\"tf3.dat\"><![CDATA[t3]]></tempFile>\n")
           << ECORA_TEXT("</tempFiles>\n")
           << ECORA_TEXT("<dataFiles>\n")
           << ECORA_TEXT("<dataFile name=\"test1.dat\">R0lGODlhcgGSALMAAAQCAEMmCZtuMFQxDS8b</dataFile>\n")
           << ECORA_TEXT("<dataFile name=\"test2.dat\">R0lGODlhcgGSALMAAAQCAEMmCZtuMFQxDS8b</dataFile>\n")
           << ECORA_TEXT("<dataFile name=\"test3.dat\">R0lGODlhcgGSALMAAAQCAEMmCZtuMFQxDS8b</dataFile>\n")
           << ECORA_TEXT("</dataFiles>\n")
           << ECORA_TEXT("<resFiles>\n")
           << ECORA_TEXT("<resFile name=\"res1.dat\"/>\n")
           << ECORA_TEXT("<resFile name=\"res2.dat\">res2</resFile>\n")
           << ECORA_TEXT("<resFile name=\"res3.dat\"><![CDATA[res3]]></resFile>\n")
           << ECORA_TEXT("</resFiles>\n")
           << ECORA_TEXT("</job>\n");

    TEST_OUT(ACE_TEXT("suspend_resume::requestJob() job_id=") << m_job_id);
=====================================================================
Found a 14 line (154 tokens) duplication in the following files: 
Starting at line 124 of D:\home\eCora_PM\PM\patchTest\DiffSummaryDlg.cpp
Starting at line 155 of D:\home\eCora_PM\PM\patchTest\DiffSummaryDlg.cpp

            newEntry->setPixmap(0, (*iter)->diffEntry(m_qsTarget)->summaryStatus().m_iconAction);
            newEntry->setText(ACTIONTYPE, (*iter)->diffEntry(m_qsTarget)->summaryStatus().m_qsInstallType);
            newEntry->setPixmap(ACTIONTYPE, (*iter)->diffEntry(m_qsTarget)->summaryStatus().m_iconInstallType);
            newEntry->setText(PRODUCT, (*iter)->displayName());
            newEntry->setPixmap(PRODUCT, *(*iter)->pixmap());
//            newEntry->setText(3, (*iter)->diffEntry(m_qsTarget)->summaryStatus().m_qsDifficulty);
            newEntry->setText(DESCRIPTION, (*iter)->diffEntry(m_qsTarget)->summaryStatus().m_qsSummaryStatus);

            setPushStatus((*iter)->diffEntry(m_qsTarget)->summaryStatus().m_qsInstallType);
            
            load((*iter), newEntry);
        }
        ++iter;
    }
=====================================================================
Found a 16 line (154 tokens) duplication in the following files: 
Starting at line 119 of D:\home\eCora_PM\PM\patchManager\SystemTabBuilder.cpp
Starting at line 332 of D:\home\eCora_PM\PM\patchManager\SystemTabBuilder.cpp

    m_listview->addColumn(QObject::tr("Rollback"), 70);
    m_listview->addColumn(QObject::tr("Status"), 100);
    m_listview->addColumn(QObject::tr("Risk"), 100);
    m_listview->addColumn(QObject::tr("Patch Name"), 80);
    m_listview->addColumn(QObject::tr("Recommended"), 80);
    m_listview->addColumn(QObject::tr("Security"), 50);
    m_listview->addColumn(QObject::tr("Y2K"), 30);
    m_listview->addColumn(QObject::tr("Prerequisites"), 75);
    m_listview->addColumn(QObject::tr("Special Instructions"), 100);
    m_listview->addColumn(QObject::tr("Packages"), 100);

    m_listview->setColumnAlignment(5, Qt::AlignCenter);

    m_listview->setAllColumnsShowFocus(TRUE);
    m_listview->setShowSortIndicator(TRUE);
}
=====================================================================
Found a 34 line (154 tokens) duplication in the following files: 
Starting at line 66 of D:\home\eCora_PM\PM\fksec\apis.cpp
Starting at line 262 of D:\home\eCora_PM\PM\fksec\apis.cpp

		if ( ::GetUserObjectSecurity( h, &whichParts, psd, needed, &needed ) )
			rc = 0;
		else
			rc = GetLastError();

		if ( rc == ERROR_INSUFFICIENT_BUFFER && ! haveRetriedSize )
		{
			delete [] (byte *) psd;
			psd = (SECURITY_DESCRIPTOR *) new byte[needed];
			haveRetriedSize = true;
		}
		else if ( rc == ERROR_PRIVILEGE_NOT_HELD && ! haveRetriedPrivilege )
		{
			try { oldSecPrivState = secPriv.Enable(); }
			catch ( ex *e ) { delete e; }
			haveRetriedPrivilege = true;
		}
		else
			break; // unrecoverable
	}

	if ( rc == 0 )
		sd = psd;

	delete [] (byte *) psd;

	if ( haveRetriedPrivilege ) // did we fuck with the privilege?
	{
		try { secPriv.SetState( oldSecPrivState ); }
		catch ( ex *e ) { delete e; } // just ignore errors here
	}

	if ( rc )
		throw NEWEX32( errUnreadableSD, "fksec::GetUserObjectSecurity(): cannot read SD, see ex::GetErrWin32()", rc );
=====================================================================
Found a 33 line (154 tokens) duplication in the following files: 
Starting at line 685 of D:\home\eCora_PM\PM\daoXmlImpl\XmlDaoBase.cpp
Starting at line 446 of D:\home\eCora_PM\PM\pmDaoXmlImpl\XmlDaoBase.cpp

        entityIt->clear();
    }

    clearEntityRefs();
}

void
XmlDaoBase::clearRelatedEntities(const wstring& relDaoId)
{
    assert(m_crtEntity != m_entities.end());

    wstring relEntContainerTagName = getRelEntContainerTagName(relDaoId);

    QDomNodeList relEntityElemList = m_crtEntity->elementsByTagName(ws2qs(relEntContainerTagName));

    for (unsigned int entElemIdx = 0; entElemIdx < relEntityElemList.length(); ++entElemIdx)
    {
        QDomNode nodeToRemove = relEntityElemList.item(entElemIdx);
        assert(!nodeToRemove.isNull());

        QDomNode nodeToRemoveNewRef = m_crtEntity->removeChild(nodeToRemove);
        assert(!nodeToRemoveNewRef.isNull());
    }
}

void
XmlDaoBase::setPersistent(bool persist)
{
    if (m_crtEntity == m_entities.end())
    {
        wstring message(L"No current entity!");
        throw GenericException(__FILE__, __LINE__, L"XmlDaoBase::setPersistent", L"", message);
    }
=====================================================================
Found a 39 line (154 tokens) duplication in the following files: 
Starting at line 214 of D:\home\eCora_PM\PM\agent\AgentManager\AMSetup\serviceCredentialsCheck\serviceCredentialsCheck.cpp
Starting at line 283 of D:\home\eCora_PM\PM\agent\agent\apps\Setup\Win32\Msi\CustomActions\CustomActionsDLL\CustomActions.cpp

    szServiceName = L"\""AGENT_SERVICE_NAME L"\"";

    if (startAgentService)
    {
        szCmd += L"/q /C \"net start ";
    }
    else
    {
        szCmd += L"/q /C \"net stop ";
    }
    szCmd = szCmd + szServiceName + L"\"";

    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    memset(&si, 0, sizeof(si));
    si.cb = sizeof(STARTUPINFO);
    si.lpDesktop = 0;
    si.dwFlags = 1; //STARTF_USESHOWWINDOW
    si.wShowWindow = SW_HIDE;
    

    BOOL retval = CreateProcess(0L,
        (wchar_t*)szCmd.GetString(), 0L, 0L, true,
        NORMAL_PRIORITY_CLASS, 0L, (wchar_t*)strPath.GetString(), &si, &pi);
    if (retval)
    {
        WaitForSingleObject(pi.hProcess, INFINITE);  // block until child done
    }
    else
    {
        return ReportInstallError(hInstall, L"Cannot stop the Agent Service!");
    }

    return ERROR_SUCCESS;
}


extern "C" __declspec(dllexport) UINT __stdcall StartAgentService(MSIHANDLE hInstall)
=====================================================================
Found a 32 line (153 tokens) duplication in the following files: 
Starting at line 137 of D:\home\eCora_PM\PM\patchManager\main.cpp
Starting at line 99 of D:\home\eCora_PM\PM\pmOAService\pmOAService.cpp

CServiceModule::installationDirectory()
{
    // Return installation directory
    ProductionClass pc;
    wstring keyName = pc.baseKey(pc.productName() + L"\\" + pc.productMajorVersion());
    
    wstring value;
    try 
    {
        value = Registry::value(keyName + L"\\InstallationPath");
    }
    catch (GenericException&)
    {
        throw GenericException(
            __FILE__, __LINE__, L"installationDirectory", L"",
            L"Could not find installation directory in the registry. "
            L"Please re-run the setup program.");
    }
    
    wstring::size_type index;
    while ((index = value.find(L'\\')) != wstring::npos)
        value[index] = L'/';
    
    if (value.size() > 0 && value[value.size() - 1] == L'/')
        value = value.substr(0, value.size() - 1);
    
    mkpath(value + L"/");
    
    return value;
}

com::ILog::Level 
=====================================================================
Found a 36 line (153 tokens) duplication in the following files: 
Starting at line 35 of D:\home\eCora_PM\PM\agent\AgentManager\AgentManagerClient\HostGroupWidgetUI.ui.h
Starting at line 11 of D:\home\eCora_PM\PM\agent\AgentManager\AgentManagerClient\HostWidgetUI.ui.h

void HostWidgetUI::btnAssign_clicked()
{
    AssignJobDlgUI dlgSelectJob(this);

    try
    { 
        dlgSelectJob.populateJobs(_spAgentManager);

        if (dlgSelectJob.exec() == QDialog::Accepted)
        {
            IJobInfoPtr spJob = dlgSelectJob.selectedJob();
            _bstr_t bstrScheduleCron(::SysAllocStringLen((LPCWSTR)dlgSelectJob.scheduleCron().unicode(), 
                 dlgSelectJob.scheduleCron().length()), false);
            /*
            spJob->AssignToComputer(_spHost->ID, dlgSelectJob.priority(), (ScheduleType)dlgSelectJob.scheduleType(), 
               bstrScheduleCron, dlgSelectJob.scheduleIdleInterval());
               
            refresh(_spAgentManager, _spHost);
            */
        }
    }
    catch (_com_error e)
    {
        QString errorMessage(QString("%1 \nError Code: 0x%2").arg(QString(e.Description())).arg((ulong)e.Error(), 0, 16));
        QMessageBox mb("Agent Manager Client", errorMessage,
            QMessageBox::Critical,
            QMessageBox::Ok,
            QMessageBox::NoButton,
            QMessageBox::NoButton);
    
        mb.exec();
    }
}


void HostWidgetUI::btnRemove_clicked()
=====================================================================
Found a 24 line (152 tokens) duplication in the following files: 
Starting at line 1539 of D:\home\eCora_PM\PM\customPatch\CustomPatchMainDlg.cpp
Starting at line 986 of D:\home\eCora_PM\PM\customPatch\ExportWizard.cpp

    QTable *clon = new QTable(saver, "clonTab");

    clon->setNumCols(m_table->numCols());
    if (restoreConfigDialog(saver, qs2ws(QString::number(m_table->numCols()))))
    {
        for (int i = 0; i < m_table->numCols(); i++)
        {
            m_table->horizontalHeader()->resizeSection(i,
                clon->horizontalHeader()->sectionSize(i));
        }
        int srt = clon->horizontalHeader()->sortIndicatorSection();
        if (srt != -1)
        {
            Qt::SortOrder sorder = clon->horizontalHeader()->sortIndicatorOrder();
            m_table->horizontalHeader()->setSortIndicator(srt, sorder);
            m_table->sortColumn(srt, sorder == Qt::Ascending);
        }
    }

    delete saver;
    m_table->repaint();
}

void ExportWizard::saveConfigSplit()
=====================================================================
Found a 22 line (150 tokens) duplication in the following files: 
Starting at line 912 of D:\home\eCora_PM\PM\winPushActions\DelayTaskAction.cpp
Starting at line 104 of D:\home\eCora_PM\PM\winPushActions\ScheduleTaskAction.cpp

    xml::Node* actionNode = actionHeader(SCHEDULETASK, id);

    xml::Node* parametersNode = new xml::Node(Parameters);
    actionNode->push_back(parametersNode);

    xml::Node* parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, Domain);
    parameterNode->addAttribute(Value, domain);
    parametersNode->push_back(parameterNode);

    parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, NetName);
    parameterNode->addAttribute(Value, computer);
    parametersNode->push_back(parameterNode);

    parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, UserName);
    parameterNode->addAttribute(Value, username);
    parametersNode->push_back(parameterNode);

    parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, SchedulerMode);
=====================================================================
Found a 26 line (150 tokens) duplication in the following files: 
Starting at line 551 of D:\home\eCora_PM\PM\bzip2\bzlib.c
Starting at line 709 of D:\home\eCora_PM\PM\bzip2\bzlib.c

void unRLE_obuf_to_output_SMALL ( DState* s )
{
   UChar k1;

   if (s->blockRandomised) {

      while (True) {
         /* try to finish existing run */
         while (True) {
            if (s->strm->avail_out == 0) return;
            if (s->state_out_len == 0) break;
            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;
            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );
            s->state_out_len--;
            s->strm->next_out++;
            s->strm->avail_out--;
            s->strm->total_out_lo32++;
            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
         }
   
         /* can a new run be started? */
         if (s->nblock_used == s->save_nblock+1) return;
               
   
         s->state_out_len = 1;
         s->state_out_ch = s->k0;
=====================================================================
Found a 27 line (150 tokens) duplication in the following files: 
Starting at line 40 of D:\home\eCora_PM\PM\agent\agent\Library\System\LinuxNetInterface.h
Starting at line 38 of D:\home\eCora_PM\PM\agent\agent\Library\System\SolarisNetInterface.h

                return getIfSpeed(if_name);
            }

            std::string getBestRoute(const ACE_INET_Addr& dest)
            {
                intf_t* intf;
                struct intf_entry* entry;
                struct addr address;
                addr_aton(dest.get_host_addr(), &address);
                char buff[1024];

                entry = reinterpret_cast<struct intf_entry*>(buff);
                std::memset(buff, sizeof(buff), 0);
                entry->intf_len = sizeof(buff);
                if ((intf = intf_open()) == NULL)
                    throw SystemException(errno, ECORA_TEXT("NetInterfaceImpl::getBestRoute() failure open interfaces"));

                // FIXME : this call gethostbyname - so may not work in some cases.
                // Need to remove this library
                if (intf_get_dst(intf, entry, &address) < 0)
                {
                    intf_close(intf);
                    throw SystemException(errno, ECORA_TEXT("NetInterfaceImpl::getBestRoute()")
                        ECORA_TEXT(" failure getting destination interfaces"));
                }

                std::string result = entry->intf_name;
=====================================================================
Found a 12 line (150 tokens) duplication in the following files: 
Starting at line 635 of D:\home\eCora_PM\PM\NetDiscover\AdDiscover.h
Starting at line 382 of D:\home\eCora_PM\PM\NetDiscover\IpDiscover.h

        device.setFieldValue(idb::WindowsDevice::UniqueID, qsSystemKey);
        device.setFieldValue(idb::WindowsDevice::OS, device.getOsName(dwOsVersionMajor, dwOsVersionMinor));

        // default values
        device.setFieldValue(idb::WindowsDevice::DriveShare, QString("Admin$"));
        device.setFieldValue(idb::WindowsDevice::UseRepository, QString("false"));
        device.setFieldValue(idb::WindowsDevice::SkipTasks, QString("false"));
        device.setFieldValue(idb::WindowsDevice::FreeDisk, QString("250"));
        device.setFieldValue(idb::WindowsDevice::InstTimeout, QString("60"));
        device.setFieldValue(idb::WindowsDevice::QChain, QString("true"));
        device.setFieldValue(idb::WindowsDevice::AllowReboot, QString("true"));
        device.setFieldValue(idb::WindowsDevice::ForceClose, QString("false"));
=====================================================================
Found a 21 line (149 tokens) duplication in the following files: 
Starting at line 1078 of D:\home\eCora_PM\PM\smuggle\Smuggler.cc
Starting at line 1098 of D:\home\eCora_PM\PM\smuggle\Smuggler.cc
Starting at line 1118 of D:\home\eCora_PM\PM\smuggle\Smuggler.cc

Smuggler::initHpux()
{
    vector<pair<bstring, int> > prompts;
    prompts.push_back(pair<bstring, int>("#", 0));
    prompts.push_back(pair<bstring, int>("$", 0));
    prompts.push_back(pair<bstring, int>("%", 0));
    prompts.push_back(pair<bstring, int>(">", 0));

    sendAndWait("PS3='';export PS3\n", prompts);
    sendAndWait("PS4='';export PS4\n", prompts);
    sendAndWait("unset TERM\n", prompts);
    sendAndWait("unset PROMPT_COMMAND\n", prompts);
    sendAndWait("unset MAIL\n", prompts);
    sendAndWait("unset MAILPATH\n", prompts);
    sendAndWait("unset MAIL_WARNING\n", prompts);
    sendAndWait("unset ls\n", prompts);
    sendAndWait("unset MAILCHECK\n", prompts);
}

void
Smuggler::initAix()
=====================================================================
Found a 23 line (149 tokens) duplication in the following files: 
Starting at line 61 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\OfficePatch.h
Starting at line 64 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\SqlPatch.h

    pmUI::SelectedPatch* getPmSelectData();

    wstring dir() const;
    wstring exeToLaunch() const;
    wstring switches() const;
    wstring qName() const;
    unsigned int timeout() const;
    unsigned int index() const;
    wstring wsIndex() const;
    void setTimeout(unsigned int v);
    void setExe(const wstring& e);
    void setQName(const wstring& v);

    void setSwitches(const wstring& v);
    void setDir(const wstring& v);
    void setReboot(bool v);
    void setIndex(int v);
    void install();
    void accept(pmPushBaseModel::Visitor& v);
    void setPrimaryKey(const wstring& v);
    wstring primaryKey() const;
    IUnknown* appIface() const;
    void setAppIface(IUnknown* i);
=====================================================================
Found a 27 line (149 tokens) duplication in the following files: 
Starting at line 979 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 1091 of D:\home\eCora_PM\PM\scanScheduling\TaskManager.cpp

    CComQIPtr<com::IAppDatabase> pAppDatabase(appServices());
    _IfNullPtrRet(pAppDatabase);

    // systems container
    CComPtr<com::IDbContainer> pDbContainer;
    HRESULT hr = pAppDatabase->getDbContainer(&pDbContainer);
    _IfFailHrRet(hr);

    // load systems
    if (!groupsNode.isNull())
    {
        // register container for groups
        hr = pDbContainer->registerObjectType((IUnknown*)&idb::GroupObject());
        _IfFailHrRet(hr);

        QDomElement element = groupsNode.firstChild().toElement();
        while (!element.isNull())
        {
            QString qsKey = element.attributeNode(GroupID).value();
            if (qsKey.length())
            {
                selected[qs2ws(qsKey)] = idb::GroupObject(qsKey).clone(true);
            }
            element = element.nextSibling().toElement();
        }
    }
    log(L"TaskManager", Log::Debug, L"<< loadGroups");
=====================================================================
Found a 39 line (149 tokens) duplication in the following files: 
Starting at line 39 of D:\home\eCora_PM\PM\agent\AgentManager\AMSetup\AMSetupBeta\LaunchAppEx.h
Starting at line 39 of D:\home\eCora_PM\PM\agent\AgentManager\AMSetup\AMSetup\LaunchAppEx.h
Starting at line 39 of D:\home\eCora_PM\PM\agent\agent\apps\Setup\Win32\Msi\AgentSvcInstall\AgentSvcInstallBeta\LaunchAppEx.h
Starting at line 39 of D:\home\eCora_PM\PM\agent\agent\apps\Setup\Win32\Msi\AgentSvcInstall\AgentSvcWFInstallBeta\LaunchAppEx.h
Starting at line 39 of D:\home\eCora_PM\PM\agent\agent\apps\Setup\Win32\Msi\AgentSvcInstall\AgentSvcWFInstall\LaunchAppEx.h

     prototype _LaunchAppEx(STRING, STRING, NUMBER, NUMBER, NUMBER, BYREF NUMBER);
     prototype BOOL kernel32.CreateProcessA(POINTER, BYVAL STRING, POINTER, 
               POINTER, BOOL, NUMBER, POINTER, POINTER, POINTER, 
               POINTER);
     prototype BOOL kernel32.GetExitCodeProcess(NUMBER, POINTER);
     prototype NUMBER kernel32.WaitForSingleObject(NUMBER, NUMBER);
     prototype BOOL kernel32.CloseHandle(HWND);

    typedef STARTUPINFO
    begin
        NUMBER   cb;
        POINTER  lpReserved;
        POINTER  lpDesktop;
        POINTER  lpTitle;
        NUMBER   dwX;
        NUMBER   dwY;
        NUMBER   dwXSize;
        NUMBER   dwYSize;
        NUMBER   dwXCountChars;
        NUMBER   dwYCountChars;
        NUMBER   dwFillAttribute;
        NUMBER   dwFlags;
        // the following is actually two words, but we know 
        // we want 0 as the value, so we cheat & create one NUMBER
        NUMBER    wShowWindow;
        //WORD    cbReserved2;
        POINTER  lpReserved2;
        HWND  hStdInput;
        HWND  hStdOutput;
        HWND  hStdError;
    end;

    typedef PROCESS_INFORMATION
    begin
        NUMBER hProcess;
        HWND hThread;
        NUMBER dwProcessId;
        NUMBER dwThreadId;
    end;
=====================================================================
Found a 41 line (148 tokens) duplication in the following files: 
Starting at line 351 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h
Starting at line 747 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h

    void testAddFile()
    {

        /**
        scenario:
        1. add file to storage
        2. check if it exists
        3. remove it
        */
        TS_ASSERT_THROWS_NOTHING(load());
        WindowsStorage storage(m_resources[WindowsStoragePath], g_App->services());

        // make sure environment set up for test
        try
        {
            storage.connect();
            if (!storage.exists())
                storage.create();
            //fs->file2utf8string(fileName, data);
        }
        catch (GenericException&)
        {
            TS_FAIL("Couldn't set up environment for test.");
        }
        fs::FileSystem* fs = g_App->appServices()->disk()->systemHome();
        wstring fileName = L"testsettings.xml";
        wstring fullName = fs->fullPath (fileName);
        TS_ASSERT_THROWS_NOTHING(storage.addFile (fullName, fileName, 0, 0));
        TS_ASSERT_EQUALS(storage.fileExists (fileName), true);

        try
        {
            storage.deleteFileExc (fileName);
        }
        catch (GenericException&)
        {
            TS_FAIL("Can't remove file");
        }
    }

    void testAddFileFails()
=====================================================================
Found a 49 line (148 tokens) duplication in the following files: 
Starting at line 17 of D:\home\eCora_PM\PM\network\Protocol.cpp
Starting at line 17 of D:\home\eCora_PM\PM\network\network\Protocol.cpp

using namespace network;

const wstring protocolNames[] = {
    L"noProtocol",
    L"ftp",
    L"http",
    L"https",
    L"sftp",
    L"rlogin",
    L"telnet",
    L"ssh",
    L"ssh2",
    L"rcp",
    L"scp",
    L"copy"
};


wstring
Protocol::getName(ProtocolType p)
{
    if ((p >= noProtocol) && (p <= lastProtocol))
    {
        return protocolNames[(int)p];
    }
    else
    {
        // throw exception?
        return L"noProtocol";
    }
}

wstring
Protocol::getName(int i)
{
    return getName((ProtocolType)i);
}

ProtocolType
Protocol::getProtocol(const wstring& protocol)
{
    for (int p = (int)noProtocol; p <= (int)lastProtocol; ++p)
    {
        if (protocolNames[p] == protocol)
            return (ProtocolType)p;
    }

    return noProtocol;
}
=====================================================================
Found a 46 line (147 tokens) duplication in the following files: 
Starting at line 25 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\Exceptions.h
Starting at line 28 of D:\home\eCora_PM\PM\xml\Exceptions.h

class Error : public GenericException
{
  public:
    Error(const wstring& name,
	  const char* file,
	  const int line,
	  const wstring& function,
	  const wstring& parameters = L"",
	  const wstring& message = L"",
	  const int stopLine = -1) :
	GenericException(name, file, line,
			 function, parameters, message),
	m_stopLine(stopLine) {}

    virtual ~Error() throw() {}

    /**
     * Return the line number where the parsing stopped after an error.
     * The actual error is on that line, or one of the lines above it.
     * -1 means line number information is not available.
     */
    int stopLine() const { return m_stopLine; }

    /**
     * Set the stop line number.  We provide this function since it is
     * not always possible to set that at the time the exception
     * object is created (the prototype of xmlerror() can't be changed
     * for reentrant parsers, same for YY_FATAL_ERROR).
     */
    void setStopLine(const int stopLine) { m_stopLine = stopLine; }

    /**
     * Return the description of the error and the line in the XML file
     * where it happened.
     */
    const wstring logMessage() const
    {
	wstring s = GenericException::logMessage();
	if (m_stopLine >= 0)
	    s += L" at line " + int2wstring(m_stopLine);
	return s;
    }

  private:
    int m_stopLine;
};
=====================================================================
Found a 16 line (147 tokens) duplication in the following files: 
Starting at line 32 of D:\home\eCora_PM\PM\patchManager\AgentFrameworkUninstallWizard.cpp
Starting at line 271 of D:\home\eCora_PM\PM\patchManager\SchemaMigrationWiz.cpp

    ui::help::InlineHelp tips;
    if (check_patchManager_InlineHelpVar())
    {
        tips.loadDataF(g_patchManager_inlineHelp);
    }

    tips.setHelp(cancelButton(), L"Button: Cancel");
    tips.setHelp(helpButton(), L"Help");
    tips.setHelp(nextButton(), L"Next");
    tips.setHelp(backButton(), L"Back");
    tips.setHelp(finishButton(), L"Finish");
    cancelButton()->setText(QObject::tr("&Cancel"));
    backButton()->setText(QObject::tr("< &Back"));
    nextButton()->setText(QObject::tr("&Next >"));
    finishButton()->setText(QObject::tr("&Finish"));
    helpButton()->setText(QObject::tr("&Help"));
=====================================================================
Found a 29 line (147 tokens) duplication in the following files: 
Starting at line 79 of D:\home\eCora_PM\PM\i18n\Conversions.cc
Starting at line 289 of D:\home\eCora_PM\PM\i18n\Conversions.cc

		if (c < 0xE0)
		{
		    wc = static_cast<wchar_t>(c & 0x1F) << 6;
		    count = 1;
		    if (c < 0xC2) goto bad_input;
		}
		else if (c < 0xF0)
		{
		    wc = static_cast<wchar_t>(c & 0x0F) << 12;
		    count = 2;
		}
#if WCHAR_T_BITS == 32
		else if (c < 0xF8)
		{
		    wc = static_cast<wchar_t>(c & 0x07) << 18;
		    count = 3;
		}
		else if (c < 0xFC)
		{
		    wc = static_cast<wchar_t>(c & 0x03) << 24;
		    count = 4;
		}
		else if (c < 0xFE)
		{
		    wc = static_cast<wchar_t>(c & 0x01) << 30;
		    count = 5;
		}
#endif // WCHAR_T_BITS == 32
		else goto bad_input;
=====================================================================
Found a 39 line (147 tokens) duplication in the following files: 
Starting at line 189 of D:\home\eCora_PM\PM\gist\gist_file.cc
Starting at line 240 of D:\home\eCora_PM\PM\gist\gist_file.cc

        log(L"gist", Log::Debug, L"couldn't open " << filename);
        return (eFILEERROR); // error: couldn't open
    }

    W_DO(_read_header());

    // Verify that everything is as expected
    if (strcmp(header.magicStr, magic) != 0)
    {
        ::close(fileHandle);
        log(L"gist", Log::Debug, L"magic words not found in " << filename);
        return eFILEERROR; // error: magic words not found
    }
    // verify that the ext ID still 'means' the same extension
    if (strcmp(
        header.extName, gist_ext_t::gist_ext_list[header.extId]->myName) != 0)
    {
        log(L"gist", Log::Debug, L"extension name changed in " << filename);
        ::close(fileHandle);
        return eFILEERROR;
    }

    // success!
    isOpen = true;
    fileSize = (lseek(fileHandle, 0, SEEK_END) + 1) / SM_PAGESIZE;
        // + 1: 0-based offset
    ext = gist_ext_t::gist_ext_list[header.extId];

    // re-initialize the page descriptors to get rid off remnants from 
    // prior index file
    _resetDescrs();
    htab.reset();

    return RCOK;
}
// End Bug #2383

rc_t
gist_file::flush()
=====================================================================
Found a 22 line (146 tokens) duplication in the following files: 
Starting at line 276 of D:\home\eCora_PM\PM\patchRepository\RepositoryManagerFilterSol.cpp
Starting at line 497 of D:\home\eCora_PM\PM\patchRepository\RepositoryManagerFilterWin.cpp

        RepositoryManagerGui::RepositoryManagerFilterPatchNameWinRegName, 
        qs2ws(m_lePatchName->text()));

    // save languages selection:
    typedef map<QString, unsigned short int>::const_iterator MapCI;
    QListViewItem* lviCurr = 0;
    for (MapCI mci = m_langSettings.begin(); mci != m_langSettings.end(); ++mci)
    {
        lviCurr = m_lvLang->findItem(QObject::tr(mci->first), 0, Qt::ExactMatch);
        if (lviCurr && m_lvLang->isSelected(lviCurr))
        {
            m_bsFilterSettingsMap["lang"].set(mci->second, true);
        }
        else
        {
            m_bsFilterSettingsMap["lang"].set(mci->second, false);
        }
    }
    _ultow(m_bsFilterSettingsMap["lang"].to_ulong(), str, 10);
    regSettingStr = str;
    iSettings->setSetting(
        RepositoryManagerGui::RepositoryManagerFilterLangWinRegName, 
=====================================================================
Found a 17 line (146 tokens) duplication in the following files: 
Starting at line 137 of D:\home\eCora_PM\PM\alerts\alertslib\EventTrigger.cc
Starting at line 645 of D:\home\eCora_PM\PM\alerts\alertslib\event.cc

	    wstring varType = m_variables[i]->getType();
	    if (varType == L"list")
	    {
		wstring tag = xmlName + L"s";
		xml::BaseNode* base = m_node->query(tag.c_str(), 0);
		xml::Node* varNode = static_cast<xml::Node*>(base);
		if (varNode == 0)
		{
		    varNode = new xml::Node(tag);
		    m_node->push_back(varNode);
		}
		vector<xml::BaseNode*> result;
		wstring nodeType = xmlName;
		varNode->query(result, nodeType.c_str(), 0);
		for (int j = 0; j < result.size(); ++j)
		    varNode->remove(result[j]);
		vector<wstring> values = m_variables[i]->getValues();
=====================================================================
Found a 18 line (145 tokens) duplication in the following files: 
Starting at line 60 of D:\home\eCora_PM\PM\patchManager\UpdatesCmd.cpp
Starting at line 118 of D:\home\eCora_PM\PM\patchManager\UpdatesCmd.cpp

    }
    catch (wstring& e)
    {
        log(L"patchManager", Log::User, L"Error loading database: " + e);
        if (Splash::instance() != 0) // make sure the splash is closed 
            Splash::instance()->close();
        QMessageBox::information(0, "Error", "Error loading database: " + ws2qs(e), "OK", 0);
        exit(1);
    }
    catch (exception& e)
    {
        log(L"patchManager", Log::User, L"Error loading database: " + utf8s2ws(e.what()));
        if (Splash::instance() != 0) // make sure the splash is closed 
            Splash::instance()->close();
        QMessageBox::information(0, "Error", "Error loading database: " + QString(e.what()), "OK", 0);
        exit(1);
    }
}
=====================================================================
Found a 29 line (145 tokens) duplication in the following files: 
Starting at line 155 of D:\home\eCora_PM\PM\daoXmlImpl\XmlDaoBase.cpp
Starting at line 123 of D:\home\eCora_PM\PM\pmDaoXmlImpl\XmlDaoBase.cpp

    for (; metaElemIt != m_metaInfo.end(); ++metaElemIt)
    {
        daoBase::XmlMetaElement metaElem = metaElemIt->second;

        EntityList::iterator entityIt = m_entities.begin();
        for (; entityIt != m_entities.end(); ++entityIt)
        {
            ProcessFn procFn = m_processSelector[metaElem.getType()];
            (this->*procFn)(metaElem, criteria, *entityIt, &filteredEntities);
        }

        m_entities = filteredEntities;
        filteredEntities.clear();
    }

    m_crtEntity = m_entities.begin();
}

void
XmlDaoBase::processSelectAll(const daoBase::XmlMetaElement& metaElem, const daoBase::CriteriaBase* criteria,
    const QDomElement& entity, EntityList* resEntities)
{
    assert(resEntities);

    entitiesByName(metaElem.getName(), entity, resEntities);
}

void
XmlDaoBase::processSelectCriteria(const daoBase::XmlMetaElement& metaElem, const daoBase::CriteriaBase* criteria,
=====================================================================
Found a 16 line (145 tokens) duplication in the following files: 
Starting at line 636 of D:\home\eCora_PM\PM\NetDiscover\AdDiscover.h
Starting at line 240 of D:\home\eCora_PM\PM\NetDiscover\NetDiscover.h

            device.setFieldValue(idb::WindowsDevice::OS, device.getOsName(si.sv101_version_major, si.sv101_version_minor));

            // default values
            device.setFieldValue(idb::WindowsDevice::DriveShare, QString("Admin$"));
            device.setFieldValue(idb::WindowsDevice::UseRepository, QString("false"));
            device.setFieldValue(idb::WindowsDevice::SkipTasks, QString("false"));
            device.setFieldValue(idb::WindowsDevice::FreeDisk, QString("250"));
            device.setFieldValue(idb::WindowsDevice::InstTimeout, QString("60"));
            device.setFieldValue(idb::WindowsDevice::QChain, QString("true"));
            device.setFieldValue(idb::WindowsDevice::AllowReboot, QString("true"));
            device.setFieldValue(idb::WindowsDevice::ForceClose, QString("false"));

	    pTDevice->push_back(device);

            m_mutex.unlock();
        }
=====================================================================
Found a 66 line (144 tokens) duplication in the following files: 
Starting at line 1106 of D:\home\eCora_PM\PM\agent\agent\Library\unzlib\zlib.h
Starting at line 804 of D:\home\eCora_PM\PM\zlib\zlib.h

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
=====================================================================
Found a 10 line (143 tokens) duplication in the following files: 
Starting at line 409 of D:\home\eCora_PM\PM\smsGui\SmsMediator.cpp
Starting at line 703 of D:\home\eCora_PM\PM\smsGui\SmsMediator.cpp

        pDbManager->exec(L"DELETE FROM " + qs2ws(idb::SmsLanguage().getObjectType()) + L" WHERE " + 
                         qs2ws(idb::SmsLanguage::DeploymentId)  + L" = '" + qs2ws(qsKey) + L"'");
        pDbManager->exec(L"DELETE FROM " + qs2ws(idb::SmsDistribution().getObjectType()) + L" WHERE " + 
                         qs2ws(idb::SmsDistribution::DeploymentId)  + L" = '" + qs2ws(qsKey) + L"'");
        pDbManager->exec(L"DELETE FROM " + qs2ws(idb::SmsMandatorySchedule().getObjectType()) + L" WHERE " + 
                         qs2ws(idb::SmsMandatorySchedule::DeploymentId)  + L" = '" + qs2ws(qsKey) + L"'");
    }
    catch (GenericException& e)
    {
        log(L"smsGui", Log::Error, e.userMessage());
=====================================================================
Found a 29 line (143 tokens) duplication in the following files: 
Starting at line 1107 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 995 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::selectGroupsSystems");

    int systemsCount = 0;
    int systemsSelected = 0;
    int groupsSelected = 0;
    CComQIPtr<com::IAppDatabase> pAppDatabase(g_App->services());

    WAIT_CURSOR();
    map<wstring, com::IDbObject*> selection;

    // locate systems node
    QDomElement devicesNode = selectionElem.namedItem(SelectedSystems).toElement();

    // load systems
    loadSystems(devicesNode, selection);

    // locate groups node
    QDomElement groupsNode = selectionElem.namedItem(SelectedGroups).toElement();

    // load systems
    loadGroups(groupsNode, selection);

    hostManager::HostManager selectionWnd(this);
    selectionWnd.setCaption("Systems Selection");
    selectionWnd.setServices(g_App->services());
    selectionWnd.enableTabs(true, false);
    if (!selectionWnd.loadSelection(selection))
    {
        log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::selectGroupsSystems: "
=====================================================================
Found a 19 line (143 tokens) duplication in the following files: 
Starting at line 199 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\DiffDBFinder.cpp
Starting at line 382 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\DiffDBFinder.cpp

    RowCont rsfd = findSharedFileDifference(installed, to_install);

    // now insert this additional raws into the files different table
    rcd.insert(rcd.end(), rsfd.begin(), rsfd.end());

    const InsTable ftn = to_install.getTable(EI::FILES_TABLE);
    // create file diff table
    InsTable fdt(ftn.getColumns(), rcd, EI::FILES_TABLE);

    // check : what files should be installed, and this files are components
    const InsTable& c_table = to_install.getTable(EI::COMPONENTS_TABLE);
    CRowComp key_file_comp(c_table.getColumns(), fdt.getColumns());
    key_file_comp[EI::FILE_ATTR] = DefaultComp();

    RowCont components = RowSelector::select_eq(c_table.getRows(), rcd, key_file_comp);

    InsTable cdt(to_install.getTable(EI::COMPONENTS_TABLE).getColumns(), components, EI::COMPONENTS_TABLE);

    ACE_DEBUG ((LM_DEBUG, ECORA_TEXT("UninstallDiffDB::findDifference(). FILE DIFF TABLE BEGIN:\n\n")));
=====================================================================
Found a 28 line (142 tokens) duplication in the following files: 
Starting at line 152 of D:\home\eCora_PM\PM\pmPush\Computer.cpp
Starting at line 120 of D:\home\eCora_PM\PM\remoteModel\RemoteComputer.cpp

                    accept(VariableVisitor(ap));
                    if (!ap->disable())
                    {
                        installActions.push_back(ap);
                    }
                }
                installOptimizer->addActionSequence(installActions);
            }

        }
    }

    vector<AnnotatedAction*> prepare = prepareOptimizer->optimizeSequence();
    vector<AnnotatedAction*> install = installOptimizer->optimizeSequence();

    vector<AnnotatedAction*>::iterator ait;

    vector<Action*> prepareBaseActions;
    vector<Action*> installBaseActions;

    for (ait = prepare.begin(); ait != prepare.end(); ++ait)
    {
        prepareBaseActions.push_back(*ait);
    }
    for (ait = install.begin(); ait != install.end(); ++ait)
    {
        installBaseActions.push_back(*ait);
    }
=====================================================================
Found a 33 line (142 tokens) duplication in the following files: 
Starting at line 57 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 56 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

using namespace std;


static void getPMDSN(sql::DsnQTSettings* pmDsnQTSettings, QWidget* parent)
{
    wstring defaultDsn;
    wstring defaultDb;

    com::ISettings* settings;
    g_App->services()->QueryInterface(IID_ISettings, (void**)&settings);
    if (settings != 0)
    {
        defaultDsn = settings->getDefaultDsn();
        defaultDb = settings->getDefaultDbName();
    }

    sql::Dsn* pmDsn = new sql::Dsn(g_App->services(), parent,
          defaultDsn, g_defInstance, defaultDb);

    pmDsn->readDsn();

    memcpy(pmDsnQTSettings, pmDsn->dsnSettings(), sizeof(sql::DsnQTSettings));

    //delete(pmDsn->dsnSettings());

    delete(pmDsn);
}


class Databaser
{
  public:
    QSqlDatabase *m_pDBFrom, *m_pDBTo;
=====================================================================
Found a 18 line (141 tokens) duplication in the following files: 
Starting at line 100 of D:\home\eCora_PM\PM\sql\dataMigrator.cpp
Starting at line 1637 of D:\home\eCora_PM\PM\sql\dsn.cpp

    dataSourceInfo += L"DATABASE=" + qtSettings.database + L"\n\n";
    wmemcpy(dataSourceStr, dataSourceInfo.c_str(), dataSourceInfo.size());
    for (int i = 0; i < dataSourceInfo.size(); ++i)
	if (dataSourceStr[i] == L'\n')
	    dataSourceStr[i] = L'\0';
    if (!SQLConfigDataSource(0, request, L"SQL Server",
	dataSourceStr))
    {
	DWORD iError;
	wchar_t messageBuf[1024];
	WORD strLen;
	SQLInstallerError(1, &iError, messageBuf, 1024, &strLen);

	wstring message = wstring(L"Can't create DSN: ") + messageBuf;
	log(L"database", Log::Error, message.c_str());
        throw GenericException(__FILE__, __LINE__, L"Dsn::create", L"",
                message.c_str());
    }
=====================================================================
Found a 25 line (141 tokens) duplication in the following files: 
Starting at line 645 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\UnixComputer.cpp
Starting at line 708 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\UnixComputer.cpp

{
    int postInstallId = 0;
    if (attachPostInstallScript())
        appendPostAction(
                        ExecuteAction::representation(
                                    postInstallId++,
                                    attachPostinstallScriptPath(),
                                    int2wstring(postinstallReturnCode())
                                )
                            );

    // Issue a warning
    if (postinstallWarningMessage() != L"")
        appendPostAction(BroadcastMsgAction::representation(postInstallId++,
                                    postinstallWarningMessage()));

    // Delete the model.xml file
    appendPostAction(unixPushActions::DeleteFileAction::representation(postInstallId++,
            (workingDirectory() + L"model.xml"), false));
    // Delete the state.xml file
    appendPostAction(unixPushActions::DeleteFileAction::representation(postInstallId++,
            (workingDirectory() + L"state.xml"), false));
    // Delete the script
    appendPostAction(unixPushActions::DeleteFileAction::representation(postInstallId++,
            (workingDirectory() + (dynamic_cast<Task*>(task()))->getAtScriptName()), false));
=====================================================================
Found a 41 line (141 tokens) duplication in the following files: 
Starting at line 17 of D:\home\eCora_PM\PM\network\CurlUnitTest.h
Starting at line 17 of D:\home\eCora_PM\PM\network\network\CurlUnitTest.h

class CurlUnitTest : public CxxTest::ServicedTestSuite
{
  public:
    CurlUnitTest()
    {
        m_trigger = 1;
    }


    void testCurl()
    {
        network::CurlHttpTestInterpreter* curlHttpTest = new network::CurlHttpTestInterpreter;
        try {
            curlHttpTest->run();
            for (size_t i = 0; i < curlHttpTest->m_httpTestDescriptors.size(); ++i)
            {
                if (curlHttpTest->m_httpTestDescriptors[i]->passFail() == L"Failed")
                {
                    TS_FAIL((ws2ansi(curlHttpTest->m_httpTestDescriptors[i]->failureMessage())).c_str());
                }
                else
                {
                    //  FIXME:  Need some way to show the user what it is we are doing.
                    //TS_???((ws2ansi(curlHttpTest->m_httpTestDescriptors[i]->m_testDescription)).c_str());
                }
            }
        }
        catch (...)
        {
            delete curlHttpTest;
            TS_FAIL("Un-caught exeption thrown in CurlHttpTestInterpreter.");
            throw;
        }
        delete curlHttpTest;
    }

  private:
    static int m_trigger;
};

static CurlUnitTest CurlUnitTestTrigger;
=====================================================================
Found a 40 line (141 tokens) duplication in the following files: 
Starting at line 51 of D:\home\eCora_PM\PM\alerts\monitor\module.cpp
Starting at line 78 of D:\home\eCora_PM\PM\pmServices\Module.cc

    delete m_update;
}

HRESULT
Module::QueryInterface(const GUID& iid, void** ptr)
{
    if (m_baseObject.getUnkOuter() != 0)
    {
        return m_baseObject.getUnkOuter()->QueryInterface(iid, ptr);
    }
    else if (iid == IID_IUnknown)
    {
        *ptr = (IUnknown*)this;
        AddRef();
        return NO_ERROR;
    }
    else if (iid == IID_IModule)
    {
        *ptr = (com::IModule*)this;
        AddRef();
        return NO_ERROR;
    }
    else
    {
        *ptr = 0;
        return E_NOINTERFACE;
    }
}

unsigned long
Module::AddRef()
{
    return m_baseObject.addRef();
}

unsigned long
Module::Release()
{
    return m_baseObject.release(this);
}
=====================================================================
Found a 15 line (141 tokens) duplication in the following files: 
Starting at line 140 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\InstallerDB\InsRow.cpp
Starting at line 165 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\InstallerDB\InsRow.cpp

bool CRowGComp::operator () (const InsRow& lhs, const InsRow& rhs) const
{
    typedef ValueCompMap::const_iterator vcm_cit;
    bool ret_temp_1 = true;
    bool ret_temp_2 = true;
    vcm_cit cit = m_comparers.begin();
    vcm_cit end = m_comparers.end();

    for (; cit != end; ++cit)
    {
        ret_temp_1 = (*cit).second(lhs[m_firstCol.find(cit->first)->second],
                            rhs[m_secondCol.find(cit->first)->second]);
        ret_temp_2 = (*cit).second(rhs[m_secondCol.find(cit->first)->second],
                            lhs[m_firstCol.find(cit->first)->second]);
        if (ret_temp_1 > ret_temp_2)
=====================================================================
Found a 42 line (140 tokens) duplication in the following files: 
Starting at line 263 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\UnixComputer.cpp
Starting at line 443 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\UnixComputer.cpp

    xml::Document sd;

// MODEL
    // Expand all the macros, e.g. $(ECORADIR) becomes /var/ecora
    expandVariables();
    // Set the state file name
    setSaveStateFile(ecoraDirectory() + L"/ecwrk/" + L"state.xml");

    // THE INSTALL ACTIONS
    // Get the install actions, but first re-order if necessary.
    localTask->orderPatchList();
    m_localComputer->retrieveActions();

    // Create the script now because w need the filename
    // in the post-install actions.
    if (localTask)
    {
        localTask->createAtScript(this);
    }
    // PRE- and POST- INSTALL ACTIONS
    doPreInstallActions();
    doPostInstallActions();

    // oK. Now the UnixComputer model can be serialized.
    xml::Node* ss = serialize();
    sd.push_back(ss);

    wostringstream ostr;
    sd.write(ostr);


// PUSH
    // Now the PUSH actions
    xml::Document actionSeqDoc;
    xml::Node* actSeq = new xml::Node(ActionSequence);
    actSeq->addAttribute(Id, L"bogus");  // ???
    actionSeqDoc.push_back(actSeq);

    int id = 0;
    wstring model =  L"";
    // CONNECT
    actSeq->push_back(ConnectAction::representation(id++, primaryKey(), this));
=====================================================================
Found a 22 line (140 tokens) duplication in the following files: 
Starting at line 713 of D:\home\eCora_PM\PM\bzip2\bzlib.c
Starting at line 759 of D:\home\eCora_PM\PM\bzip2\bzlib.c

   } else {

      while (True) {
         /* try to finish existing run */
         while (True) {
            if (s->strm->avail_out == 0) return;
            if (s->state_out_len == 0) break;
            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;
            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );
            s->state_out_len--;
            s->strm->next_out++;
            s->strm->avail_out--;
            s->strm->total_out_lo32++;
            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
         }
   
         /* can a new run be started? */
         if (s->nblock_used == s->save_nblock+1) return;
   
         s->state_out_len = 1;
         s->state_out_ch = s->k0;
         BZ_GET_SMALL(k1); s->nblock_used++;
=====================================================================
Found a 26 line (139 tokens) duplication in the following files: 
Starting at line 925 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 927 of D:\home\eCora_PM\PM\scanScheduling\TaskManager.cpp

    CComQIPtr<com::IAppDatabase> pAppDatabase(appServices());
    _IfNullPtrRet(pAppDatabase);

    // systems container
    CComPtr<com::IDbContainer> pDbContainer;
    HRESULT hr = pAppDatabase->getDbContainer(&pDbContainer);
    _IfFailHrRet(hr);

    // load systems
    if (!devicesNode.isNull())
    {
        QDomElement element = devicesNode.firstChild().toElement();
        while (!element.isNull())
        {
            QString qsKey = element.attributeNode(SystemID).value();
            QString qsClass = element.attributeNode(SystemClass).value();
            if (qsKey.length() && qsClass.length())
            {
                hr = pDbContainer->registerObjectType(qsClass);
                if (FAILED(hr))
                {
                    _ASSERTE(0);
                    continue;
                }

                idb::WindowsDevice device(appServices());
=====================================================================
Found a 16 line (139 tokens) duplication in the following files: 
Starting at line 389 of D:\home\eCora_PM\PM\patchManager\DisplaySolarisInfo.cpp
Starting at line 500 of D:\home\eCora_PM\PM\patchManager\DisplayWinInfo.cpp

    MsgHeaderWinSystem* msg = static_cast<MsgHeaderWinSystem*>(m_myMessage);

    if ((patchSelection & pmUI::DisplayPatchStatus::PUSH_STATUS_ICON_OFF) ||
	(patchSelection & pmUI::DisplayPatchStatus::PUSH_STATUS_ICON_ON))
    {
	msg->getPolicyInfo()->setPushStatusForPatch(msg->getPatchInfo()->getPatchId(), patchSelection);
	msg->getPolicyInfo()->setRemediationStatusForPatch(msg->getPatchInfo()->getPatchId(), patchSelection);
    }

    if ((patchSelection & pmUI::DisplayPatchStatus::ROLLBACK_STATUS_ICON_OFF) ||
	(patchSelection & pmUI::DisplayPatchStatus::ROLLBACK_STATUS_ICON_ON))
    {
	msg->getPolicyInfo()->setRollbackStatusForPatch(msg->getPatchInfo()->getPatchId(), patchSelection);
	msg->getPolicyInfo()->setRemediationStatusForPatch(msg->getPatchInfo()->getPatchId(), patchSelection);
    }
}
=====================================================================
Found a 20 line (139 tokens) duplication in the following files: 
Starting at line 210 of D:\home\eCora_PM\PM\collector\TextInterface.h
Starting at line 167 of D:\home\eCora_PM\PM\woodstock\QtInterface.h

    virtual void statusMessage(const wstring& message);

    // inherited from InterfaceCommon
    virtual int licenseLimit(const wstring& type) const
    { return m_common->licenseLimit(type); }
    virtual wstring networkCacheFile() const
    { return m_common->networkCacheFile(); }
    virtual wstring installationDirectory() const 
    { return m_common->installationDirectory(); }
    virtual QWidget* parentWindow() const 
    { return m_common->parentWindow(); }
    virtual bool trialMode() const 
    { return m_common->trialMode(); }
    virtual wstring encrypt(const wstring& in) const
    { return m_common->encrypt(in); }
    virtual wstring decrypt(const wstring& in) const
    { return m_common->decrypt(in); }
    virtual int information(const wstring& caption,
        const wstring& text,
        const wstring* pButton0Text = 0,
=====================================================================
Found a 21 line (139 tokens) duplication in the following files: 
Starting at line 75 of D:\home\eCora_PM\PM\agent\agent\Library\XMLUtils\XMLPersistObj.h
Starting at line 99 of D:\home\eCora_PM\PM\agent\agent\Library\XMLUtils\XMLPersistObj.h

                void XMLLoadDynamic_(const tstring& xml_path, const tstring& name, Obj*& obj)
            {
                using namespace XERCES_CPP_NAMESPACE;
                assert(EFile::exists(xml_path));

                XMLInit::instance();
                std::auto_ptr<XercesDOMParser> parser(new XercesDOMParser);
                std::auto_ptr<ErrorHandler> errHandler((ErrorHandler*) new HandlerBase());

                parser->setValidationScheme(XercesDOMParser::Val_Always);
                parser->setValidationSchemaFullChecking(true);
                parser->setErrorHandler(errHandler.get());

                XercesDOMParser* p = parser.get();
                p->parse(xml_path.c_str());

                XERCES_CPP_NAMESPACE::DOMDocument *doc = parser->getDocument();
                DOMElement *root = doc->getDocumentElement();

                xmlutils::LoadContext<Traits> ctx(doc, root);
                xmlutils::XMLpersist_dynamic<TList>(&ctx, obj, name, root);
=====================================================================
Found a 30 line (139 tokens) duplication in the following files: 
Starting at line 240 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\NewSetupActions.cpp
Starting at line 378 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\NewSetupActions.cpp

				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
				1000, &hSiteHandle);

			if (hRes != S_OK) {
				switch (hRes) {
					case E_ACCESSDENIED:
						ReportError(hInstall, __FILE__, __LINE__,
                            _T("IMSAdminBase->OpenKey() error: E_ACCESSDENIED"));
						break;
					case HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
                        ReportError(hInstall, __FILE__, __LINE__,
                            _T("IMSAdminBase->OpenKey() error: ERROR_INSUFFICIENT_BUFFER"));
						break;
					case E_INVALIDARG:
						ReportError(hInstall, __FILE__, __LINE__,
                            _T("IMSAdminBase->OpenKey() error: E_INVALIDARG"));
						break;
					case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
						ReportError(hInstall, __FILE__, __LINE__,
                            _T("IMSAdminBase->OpenKey() error: ERROR_PATH_NOT_FOUND"));
						break;
					case MD_ERROR_DATA_NOT_FOUND:
                        ReportError(hInstall, __FILE__, __LINE__,
                            _T("IMSAdminBase->OpenKey() error: MD_ERROR_DATA_NOT_FOUND"));
						break;
					default:
						ReportError(hInstall, __FILE__, __LINE__,
                            _T("IMSAdminBase->OpenKey() error: Failed"));
						break;
				}
=====================================================================
Found a 20 line (138 tokens) duplication in the following files: 
Starting at line 76 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.h
Starting at line 76 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.h

    void saveTaskDefFile(QDomDocument& tasksDefDoc, const wstring& filePath);

    void loadTaskSelection(scanScheduling::Task* task, map<wstring, com::IDbObject*>& selectedDevices);

    /// loads the systems contained by the task file
    void loadSystems(QDomElement& devicesNode, map<wstring, com::IDbObject*>& selected);
    /// loads task groups
    void loadGroups(QDomElement& groupsNode, map<wstring, com::IDbObject*>& selected);
    /// loads all systems related to task groups
    void loadGroupSystems(QDomElement& groupsNode, map<wstring, com::IDbObject*>& selected);
    /// appends groups to task fragment
    void appendGroups(QDomElement& root, QDict<com::IDbObject>& groups);
    /// appends systems to passed task fragment
    void appendSystems(QDomElement& root, QDict<com::IDbObject>& systems);

    void retrieveSettings();
    void updateControls();

    void startScheduledArchive();
    void startScheduledPurge();
=====================================================================
Found a 30 line (138 tokens) duplication in the following files: 
Starting at line 86 of D:\home\eCora_PM\PM\daoDbImpl\CDocCache.h
Starting at line 245 of D:\home\eCora_PM\PM\pmDbCache\CDocCache.h

    wstring isX64;//Sersok x64
};

class CFileCacheItem : public CCacheItem
{
  public:

    vector<cFileCacheElement *> m_vFileCache;
    bool empty;

    CFileCacheItem()
    {
        HitCount = -1;
        empty = true;
    };

    ~CFileCacheItem()
    {
        for_each(m_vFileCache.begin(), m_vFileCache.end(), DeleteCacheElement());
        m_vFileCache.erase(m_vFileCache.begin(), m_vFileCache.end());
    }

    inline copy(const CFileCacheItem sourceItem)
    {
        m_vFileCache.erase(m_vFileCache.begin(), m_vFileCache.end());
        m_vFileCache.insert(m_vFileCache.begin(),
                            sourceItem.m_vFileCache.begin(),
                            sourceItem.m_vFileCache.end());
        empty = sourceItem.empty;
    };
=====================================================================
Found a 25 line (137 tokens) duplication in the following files: 
Starting at line 327 of D:\home\eCora_PM\PM\pmDbProvider\ScanWinPatchDbProvider.cpp
Starting at line 199 of D:\home\eCora_PM\PM\pmDbProvider\ScanWinSpDbProvider.cpp

            l_pSpInfo->addSystemItem(l_pWinSysInfo);
            l_pWinProductInfo = NULL;
        }
        //---------- loadProductsForSystem --------------
	// #8889 MM
	//if (!l_pWinProductInfo || l_ProductVersionId != query.stringvalue(L"ProductVersionId"))
	if (!l_pWinProductInfo ||
	    l_ProductVersionId != query.stringvalue(L"ProductVersionId") ||
	    wsCurrentProductInstanceName != query.stringvalue(L"InstanceName"))
        {
            l_ProductVersionId = query.stringvalue(L"ProductVersionId");
            l_pWinProductInfo =
                dynamic_cast<pmUI::WinProductInfo*>(productDbProvider.createProduct(l_ProductVersionId, 0, 0));
            assert(l_pWinProductInfo);

            l_pWinProductInfo->setProductInstance(query.stringvalue(L"InstanceName"));
            l_pWinProductInfo->setProduct(query.stringvalue(L"ProductName"));
            l_pWinProductInfo->setProductVersion(query.stringvalue(L"VersionName"));
            l_pWinProductInfo->setShortName(query.stringvalue(L"ProductShortName"));

            l_pWinSysInfo->addItem(l_pWinProductInfo);

	    wsCurrentProductInstanceName = l_pWinProductInfo->productInstance();  // #8889 MM
        }
        l_pWinProductInfo->addServicePackItem(createSpInfo(query));
=====================================================================
Found a 27 line (137 tokens) duplication in the following files: 
Starting at line 1977 of D:\home\eCora_PM\PM\pmDataProcessor\DataProcessor.cpp
Starting at line 2036 of D:\home\eCora_PM\PM\pmDataProcessor\DataProcessor.cpp

        QString cacheState = qdbVersionQuery.value(1).toString();
        {
            int stateMask = cacheState.toInt(); 
            if (stateMask & CUSTOM_PRODUCT_UPDATED)
            {
                if (m_queriesProvider != 0 && m_queriesProvider->getCaches() != 0)
                {
                    m_queriesProvider->getCaches()->clean();
                }
            }
            if (stateMask & PARTIAL_SET_UPDATED)
            {
                if (m_queriesProvider != 0 && m_queriesProvider->getCaches() != 0)
                {
                    fillPartialScanCache();
                }
            }
            if (stateMask & NAMED_PARTIAL_SET_UPDATED)
            {
                if (m_queriesProvider != 0 && m_queriesProvider->getCaches() != 0)
                {
                    m_queriesProvider->getCaches()->m_dcNamedPartialScanApps->clean();
                    m_queriesProvider->getCaches()->m_dcNamedPartialScanPatches->clean();
                }
            }
            //need to unmark it back
            if (stateMask != 0)
=====================================================================
Found a 27 line (137 tokens) duplication in the following files: 
Starting at line 944 of D:\home\eCora_PM\PM\patchManager\DisplayBasicInfo.cpp
Starting at line 1118 of D:\home\eCora_PM\PM\patchManager\DisplayBasicInfo.cpp

		    (*itSystem)->getSystemId(),
		    scanId,
		    (*itProduct)->productInstance());

		patch->setIsServicePack(1);
        // BUG FIX #17901 by Yuri Kovalenko ->
        patch->setIsSolarisPatch(0);
        // BUG FIX #17901 by Yuri Kovalenko <-

		patch->setLanguageId((*itSp)->languageId()); //MM

		int pushSelection = pmUI::DisplayPatchStatus::PUSH_STATUS_ICON_OFF;
		int rollbackSelection = pmUI::DisplayPatchStatus::ROLLBACK_STATUS_ICON_OFF;

		bool isSelected = g_App->getListView()->globalInfo()->getSelection(patch,
		    pushSelection, rollbackSelection);

		if (isSelected)
    		    (*itSp)->setPushStatus(pushSelection);
		else    // reset it anyway (see IIS, OS)
		    if ((*itSp)->getPushStatus() & pmUI::DisplayPatchStatus::PUSH_STATUS_ICON_ON)
			(*itSp)->setPushStatus(pmUI::DisplayPatchStatus::PUSH_STATUS_ICON_OFF);

		delete patch;
	    }
	}
    }
=====================================================================
Found a 31 line (137 tokens) duplication in the following files: 
Starting at line 46 of D:\home\eCora_PM\PM\daoDbImpl\CDocCache.h
Starting at line 201 of D:\home\eCora_PM\PM\pmDbCache\CDocCache.h

};

class CRegistryCacheItem : public CCacheItem
{
  public:

    vector<cRegCacheElement *> m_vRegCache;

    bool empty;
    //wstring path;

    CRegistryCacheItem()
    {
        HitCount = -1;
        empty = true;
    };

    ~CRegistryCacheItem()
    {
        for_each(m_vRegCache.begin(), m_vRegCache.end(), DeleteCacheElement());
        m_vRegCache.erase(m_vRegCache.begin(), m_vRegCache.end());
    };

    inline copy(const CRegistryCacheItem sourceItem)
    {
        m_vRegCache.erase(m_vRegCache.begin(), m_vRegCache.end());
        m_vRegCache.insert(m_vRegCache.begin(),
                            sourceItem.m_vRegCache.begin(),
                            sourceItem.m_vRegCache.end());
        empty = sourceItem.empty;
    }
=====================================================================
Found a 39 line (137 tokens) duplication in the following files: 
Starting at line 602 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp
Starting at line 955 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp

void PatchProperties::checkRegButtons()
{
    if (m_tableReg->numSelections() == 0)
    //numSelections() = 1 even if more than 1 rows are selected
    {
        m_bEdit->setEnabled(false);
        m_bRemove->setEnabled(false);
        return;
    }
    //num - number of selected rows;
    int num = 0;
    int i = 0;
    while (i < m_tableReg->numRows())
    {
        if (m_tableReg->isRowSelected(i))
        {
            num++;
            if (2 == num)
            {
                m_bEdit->setEnabled(false);
                m_bRemove->setEnabled(true);
                return;
            }
        }
        i++;
    }
    if (1 == num)
    {
        m_bEdit->setEnabled(true);
        m_bRemove->setEnabled(true);
    }
    else
    {
        m_bEdit->setEnabled(false);
        m_bRemove->setEnabled(false);
    }
}

void PatchProperties::importCom()
=====================================================================
Found a 39 line (137 tokens) duplication in the following files: 
Starting at line 431 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp
Starting at line 566 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp

void PatchProperties::checkFileButtons()
{
    if (m_tableFile->numSelections() == 0)
    //numSelections() = 1 even if more than 1 rows are selected
    {
        m_bEdit->setEnabled(false);
        m_bRemove->setEnabled(false);
        return;
    }
    //num - number of selected rows;
    int num = 0;
    int i = 0;
    while (i < m_tableFile->numRows())
    {
        if (m_tableFile->isRowSelected(i))
        {
            num++;
            if (2 == num)
            {
                m_bEdit->setEnabled(false);
                m_bRemove->setEnabled(true);
                return;
            }
        }
        i++;
    }
    if (1 == num)
    {
        m_bEdit->setEnabled(true);
        m_bRemove->setEnabled(true);
    }
    else
    {
        m_bEdit->setEnabled(false);
        m_bRemove->setEnabled(false);
    }
}

void PatchProperties::addLocation()
=====================================================================
Found a 39 line (137 tokens) duplication in the following files: 
Starting at line 504 of D:\home\eCora_PM\PM\alerts\alertslib\GlobalAlert.cc
Starting at line 117 of D:\home\eCora_PM\PM\alerts\upgrade\GlobalAlert.cpp

    try {
        // monitoring attributes
	m_enableMonitoring = getBooleanAttribute(m_topXmlNode, ENABLE_MONITORING_ATTR);
	
	m_monitorInterval = getIntegerAttribute(m_topXmlNode, MONITOR_INTERVAL_ATTR);
	if (m_monitorInterval < MINIMUM_INTERVAL)
	    m_monitorInterval = MINIMUM_INTERVAL;
	
	// SNMP global attributes
	m_enableSNMP = getBooleanAttribute(m_topXmlNode, ENABLE_SNMP_ATTR);
	m_snmpManager = getStringAttribute(m_topXmlNode, SNMP_MANAGER_ATTR);
	try {
	    m_snmpPort = getIntegerAttribute(m_topXmlNode, SNMP_PORT_ATTR);
	}
	catch (GenericException&)
	{
	    m_snmpPort = DEFAULT_SNMP_PORT;
	}

	// SMTP global attributes
	m_enableSMTP = getBooleanAttribute(m_topXmlNode, ENABLE_SMTP_ATTR);
	m_smtpServer = getStringAttribute(m_topXmlNode, SMTP_MANAGER_ATTR);
	try {
	    m_smtpPort = getIntegerAttribute(m_topXmlNode, SMTP_PORT_ATTR);
	}
	catch (GenericException&)
	{
	    m_smtpPort = DEFAULT_SMTP_PORT;
	}
	try {
	    m_smtpMaxAttachSize = getIntegerAttribute(m_topXmlNode, SMTP_MAX_ATTACH_ATTR);
	}
	catch (GenericException&)
	{
	    m_smtpMaxAttachSize = DEFAULT_MAX_ATTACH;
	}

	// optional parameters
	try { m_compress = getBooleanAttribute(m_topXmlNode, L"smtp-attach-compress"); }
=====================================================================
Found a 21 line (137 tokens) duplication in the following files: 
Starting at line 49 of D:\home\eCora_PM\PM\agent\AgentManager\AgentManagerClient\AgentInfoWidgetUI.ui.h
Starting at line 48 of D:\home\eCora_PM\PM\agent\AgentManager\AgentManagerClient\AgentJobListWidgetUI.ui.h

    ::GetTimeZoneInformation(&tzi);

    //populate with agent jobs
    for (int i = 0; i < nAgentJobs; i++)
    {
        IAgentJobInfoPtr spAgentJob = spAgentJobs->GetItem(i);
        IJobAssignmentInfoPtr spJobAssignment = spAgentJob->JobAssignment;
        
        //subscribe to agent job event
        _spJobChangesTracer->Subscribe(spAgentJob);

        SYSTEMTIME st;
        QString qstrCreationTime;

        if (::VariantTimeToSystemTime(spJobAssignment->CreationTime, &st))
        {
            QDateTime creationTime(QDate(st.wYear, st.wMonth, st.wDay), 
                QTime(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds));
            creationTime = creationTime.addSecs((-60) * (tzi.Bias + tzi.StandardBias + tzi.DaylightBias)); //add UTC offset
            qstrCreationTime = creationTime.toString(Qt::LocalDate);
        }
=====================================================================
Found a 23 line (137 tokens) duplication in the following files: 
Starting at line 574 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\HandleIIS.cpp
Starting at line 734 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\HandleIIS.cpp

    _tcscpy(virDir, ptr + 1);


    swprintf(adsPath, L"IIS://localhost/W3SVC/%d/ROOT/%s", siteNum, virDir);

    hr = ADsGetObject(adsPath, IID_IADsContainer, (void**) &pAdsCont);
    if (FAILED(hr))
    {
        GetADSIErrorMessage(hr, errorMsg);
        ReportError(hInstall, __FILE__, __LINE__, _T("AdsGetObject('%s') failed. %s"), adsPath, errorMsg);
        goto l_end;
    }

    hr = pAdsCont->QueryInterface(IID_IADs, (void**)&pAds);
    if (FAILED(hr))
    {
        GetADSIErrorMessage(hr, errorMsg);
        ReportError(hInstall, __FILE__, __LINE__, _T("QueryInterface(IID_IADs) failed. %s"), adsPath, errorMsg);
        goto l_end;
    }

    VariantInit(&var);
    hr = pAds->Get(L"AuthFlags", &var);
=====================================================================
Found a 20 line (137 tokens) duplication in the following files: 
Starting at line 84 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\HandleIIS.cpp
Starting at line 303 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\HandleIIS.cpp

    swprintf(adsPath, L"IIS://localhost/W3SVC/%s/ROOT", siteNum);
    hr = ADsGetObject(adsPath, IID_IADsContainer, (void**) &pAdsCont);
    if (FAILED(hr))
    {
        GetADSIErrorMessage(hr, errorMsg);
        ReportError(hInstall, __FILE__, __LINE__, _T("AdsGetObject(%s) failed. %s"), adsPath, errorMsg);
        goto l_end;
    }

    hr = pAdsCont->QueryInterface(IID_IADs, (void**)&pAds);
    if (FAILED(hr))
    {
        GetADSIErrorMessage(hr, errorMsg);
        ReportError(hInstall, __FILE__, __LINE__, _T("QueryInterface(IID_IADs) failed. %s"), adsPath, errorMsg);
        goto l_end;
    }

    VariantInit(&var);
    hr = pAds->Get(L"ScriptMaps", &var);
    if (SUCCEEDED(hr))
=====================================================================
Found a 10 line (136 tokens) duplication in the following files: 
Starting at line 279 of D:\home\eCora_PM\PM\fksec\main.cpp
Starting at line 289 of D:\home\eCora_PM\PM\fksec\main.cpp

	out << _T( "Different types:" ) << std::endl;
	out << _T( "a0 == a1: " ) << (bool) ( a0 == a1 ) << std::endl;
	out << _T( "a1 == a0: " ) << (bool) ( a1 == a0 ) << std::endl;
	out << _T( "a0 != a1: " ) << (bool) ( a0 != a1 ) << std::endl;
	out << _T( "a1 != a0: " ) << (bool) ( a1 != a0 ) << std::endl;
	out << _T( "a0 <  a1: " ) << (bool) ( a0 <  a1 ) << std::endl;
	out << _T( "a1 <  a0: " ) << (bool) ( a1 <  a0 ) << std::endl << std::endl;

	a1 = a0;
	a1.SetInheritance( VALID_INHERIT_FLAGS );
=====================================================================
Found a 27 line (135 tokens) duplication in the following files: 
Starting at line 640 of D:\home\eCora_PM\PM\winPushActions\DelayTaskAction.cpp
Starting at line 769 of D:\home\eCora_PM\PM\winPushActions\DelayTaskAction.cpp

DelayTaskAction::scheduleForReboot()
{
    using namespace actionsInterpreter;
    wstring domain;
    wstring computer;
    wstring application;
    wstring userName;
    wstring taskName;
    wstring comment;
    wstring password;
    wstring pwd;
    bool installImmediate;
    wstring installTime;

    if (!getParameter(Domain, &domain) ||
        !getParameter(NetName, &computer) ||
        !getParameter(Directory, &pwd) ||
        !getParameter(Application, &application) ||
        !getParameter(UserName, &userName) ||
        !getParameter(TaskName, &taskName) ||
        !getParameter(Text, &comment) ||
        !getParameter(Password, &password) ||
        !getParameter(InstallImmediate, &installImmediate) ||
        !getParameter(Time, &installTime))
    {
        m_message = L"Failed: unable to obtain parameters";
        log(L"scheduleForReboot", Log::Error, m_message); // BUG FIX #23445 by Yug
=====================================================================
Found a 25 line (135 tokens) duplication in the following files: 
Starting at line 153 of D:\home\eCora_PM\PM\print\Format.cc
Starting at line 188 of D:\home\eCora_PM\PM\print\Format.cc

Format::Format(Multiplexer& m, const wstring& name, const wstring& path,
	       const wstring& extension, const wstring& type) :
    m_name(name),
    m_type(type),
    m_file(path + extension),
    m_standalone(true),
    m_multiplexer(0),
    m_insideErrorValue(false),
    m_insideDefaultValue(false),
    m_insideUnknownValue(false),
    m_insideNote(false),
    m_insideXRef(false),
    m_insideHint(false),
    m_insideWarning(false),
    m_insideBold(false),
    m_insideItalic(false),
    m_insideUnderline(false),
    m_insideVerbatim(false),
    m_insideFixed(false),
    m_insideURL(false),
    m_insideColor(0),
    m_insideCenter(0),
    m_insideQuote(0),
    m_insideParagraph(0),
    m_chapter(m.chapterNumber()),
=====================================================================
Found a 23 line (135 tokens) duplication in the following files: 
Starting at line 2356 of D:\home\eCora_PM\PM\pmAnalysisWinProvider\AnalyzeOffice.cpp
Starting at line 2601 of D:\home\eCora_PM\PM\pmAnalysisWinProvider\AnalyzeOffice.cpp

AnalyzeOffice2010::getLanguage(const wstring& prod)
{
    wstring lang;
    wstring productSKU = getSkuGivenProduct(prod);

    // Check each GUID for this product.
    vector<wstring>::iterator it = m_keys.begin();
    for (; it != m_keys.end(); ++it)
    {
        wstring currSKU = (*it).substr(10, 4);
        if (currSKU == productSKU)
        {
                wstring lcid = (*it).substr(15, 4);
                lang = pmCollectorWinProvider::GetLCID::getLCID(static_cast<int>(wcstol(lcid.c_str(), NULL, 16)));
                break;
        }
    }
    if (lang.empty()) 
        lang = m_wsLanguage;
    return lang;
}

wstring 
=====================================================================
Found a 31 line (135 tokens) duplication in the following files: 
Starting at line 69 of D:\home\eCora_PM\PM\fksec\apis.cpp
Starting at line 458 of D:\home\eCora_PM\PM\fksec\apis.cpp

		rc = ::RegGetKeySecurity( hk, whichParts, psd, &needed );

		if ( rc == ERROR_INSUFFICIENT_BUFFER && ! haveRetriedSize )
		{
			delete [] (byte *) psd;
			psd = (SECURITY_DESCRIPTOR *) new byte[needed];
			haveRetriedSize = true;
		}
		else if ( rc == ERROR_PRIVILEGE_NOT_HELD && ! haveRetriedPrivilege )
		{
			try { oldSecPrivState = secPriv.Enable(); }
			catch ( ex *e ) { delete e; }
			haveRetriedPrivilege = true;
		}
		else
			break; // unrecoverable
	}

	if ( rc == 0 )
		sd = psd;

	delete [] (byte *) psd;

	if ( haveRetriedPrivilege ) // did we fuck with the privilege?
	{
		try { secPriv.SetState( oldSecPrivState ); }
		catch ( ex *e ) { delete e; } // just ignore errors here
	}

	if ( rc )
		throw NEWEX32( errUnreadableSD, "fksec::RegGetKeySecurity(): cannot read SD, see ex::GetErrWin32()", rc );
=====================================================================
Found a 17 line (135 tokens) duplication in the following files: 
Starting at line 183 of D:\home\eCora_PM\PM\daoXmlImpl\XmlDaoBase.cpp
Starting at line 223 of D:\home\eCora_PM\PM\daoXmlImpl\XmlDaoBase.cpp

XmlDaoBase::processSelectCriteria(const daoBase::XmlMetaElement& metaElem, const daoBase::CriteriaBase* criteria,
    const QDomElement& entity, EntityList* resEntities)
{
    assert(!metaElem.getAttribute().empty());
    assert(!metaElem.getCriteriaAttribute().empty());
    assert(criteria);
    assert(resEntities);

    EntityList entitiesWithName;
    entitiesByName(metaElem.getName(), entity, &entitiesWithName);

    EntityList::iterator entityWithNameIt = entitiesWithName.begin();
    for (; entityWithNameIt != entitiesWithName.end(); ++entityWithNameIt)
    {
        QDomElement attrElem = entityWithNameIt->namedItem(ws2qs(metaElem.getAttribute())).toElement();

        if (!attrElem.isNull() &&
=====================================================================
Found a 21 line (135 tokens) duplication in the following files: 
Starting at line 555 of D:\home\eCora_PM\PM\bzip2\bzlib.c
Starting at line 759 of D:\home\eCora_PM\PM\bzip2\bzlib.c

   } else {

      while (True) {
         /* try to finish existing run */
         while (True) {
            if (s->strm->avail_out == 0) return;
            if (s->state_out_len == 0) break;
            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;
            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );
            s->state_out_len--;
            s->strm->next_out++;
            s->strm->avail_out--;
            s->strm->total_out_lo32++;
            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
         }
   
         /* can a new run be started? */
         if (s->nblock_used == s->save_nblock+1) return;
   
         s->state_out_len = 1;
         s->state_out_ch = s->k0;
=====================================================================
Found a 26 line (135 tokens) duplication in the following files: 
Starting at line 154 of D:\home\eCora_PM\PM\alerts\alertslib\util.cc
Starting at line 619 of D:\home\eCora_PM\PM\i18n\Conversions.cc

utf8s2ws(const utf8string& s)
{
    if (s.empty())
	return L"";


#ifndef _WIN32
    mbstate_t ps;
    memset(&ps, '\0', sizeof(mbstate_t));

    const char* tmp = s.c_str();
    size_t length = s.dataLength();

    wstring result;
    //leave room for the 0
    result.resize(length + 1);
    length = mbsrtowcs(&result[0], &tmp, length + 1, &ps);

    if (length == static_cast<size_t>(-1))
        throw invalid_argument("utf8string");

    result.resize(length);
#else
    size_t length = s.size();
    LPWSTR pszDest = new WCHAR[length + 1];
    if (!::MultiByteToWideChar(
=====================================================================
Found a 23 line (135 tokens) duplication in the following files: 
Starting at line 29 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\SelfTest.h
Starting at line 22 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\resume_updownload.h

    ~resume_updownload();

// AgentConnectorBase interface
    virtual void finalize();

// AgentConnectionBase interface
    virtual bool requestJob(const JobData& job_data, tostream& stream);

    virtual bool putJobStatus(const JobData& job_data,
        const tstring& job_id, const tstring& job_status);

    virtual bool downloadJobData(const JobData& job_data, const tstring& job_id,
        const tstring& temp_name, const tstring& dest_path, const tstring& session_id);

    virtual bool uploadJobRequestData(const JobData& job_data, const tstring& job_id,
        const tstring& result_name, const tstring& job_path, const tstring& session_id);

    virtual bool registerAgent(const tstring& serial_num, int job_req_interval, tostream& agent_id);

    virtual bool unregisterAgent(const tstring& serial_num, const tstring& agent_id);

// InstallerBase interface
    virtual bool install(const tstring& package, const tstring& version);
=====================================================================
Found a 42 line (135 tokens) duplication in the following files: 
Starting at line 46 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\Blowfish.cpp
Starting at line 44 of D:\home\eCora_PM\PM\utils\Blowfish.cc

union aword
{
    unsigned long dword;
    unsigned char byte[4];
    struct
    {
	unsigned int byte0 : 8;
	unsigned int byte1 : 8;
	unsigned int byte2 : 8;
	unsigned int byte3 : 8;
    } w;
};
#else // !WORDS_BIGENDIAN
union aword
{
    unsigned long dword;
    unsigned char byte[4];
    struct
    {
	unsigned int byte3 : 8;
	unsigned int byte2 : 8;
	unsigned int byte1 : 8;
	unsigned int byte0 : 8;
    } w;
};
#endif // !WORDS_BIGENDIAN


#ifdef WORDS_VAX
// BADC - vax
union aword
{
    unsigned long dword;
    unsigned char byte[4];
    struct
    {
	unsigned int byte1 : 8;
	unsigned int byte0 : 8;
	unsigned int byte3 : 8;
	unsigned int byte2 : 8;
    } w;
};
=====================================================================
Found a 22 line (134 tokens) duplication in the following files: 
Starting at line 255 of D:\home\eCora_PM\PM\patchManager\PolicyAnalyzer.cpp
Starting at line 308 of D:\home\eCora_PM\PM\patchManager\PolicyAnalyzer.cpp

            if ((*itPatch)->selected() == false)
                continue;

            // create a new policy in patchManager based on policy in policyManager
            // do not deaallocate the pointer
            pmUI::PolicyInfo* pmPolicy = new pmUI::PolicyInfo();
            
            pmPolicy->setPolicyId(policy->policyId());
            pmPolicy->setNamePolicy(policy->name());
            pmPolicy->setDescriptionPolicy(policy->description());
                        
            // check if there is at least on patch which doesn't comply with the policy rule
            if (system()->addPolicyInfo(pmPolicy,
                (*itPatch)->product(),
                (*itPatch)->productVersionId(),
                (*itPatch)->patchId(),
                (*itPatch)->rule(),
                (*itPatch)->isServicePack()) == pmUI::DisplayPolicyCompliance::POLICY_NOT_COMPLY)
                comply = pmUI::DisplayPolicyCompliance::POLICY_NOT_COMPLY;
            
            tmpDuplicates.insert((*itPatch)->patchId());
        }
=====================================================================
Found a 68 line (134 tokens) duplication in the following files: 
Starting at line 15 of D:\home\eCora_PM\PM\network\Result.h
Starting at line 15 of D:\home\eCora_PM\PM\network\network\Result.h

namespace network {

/**
 * The Result class provides information about the result of a 
 * network operation.  Along with a general status result, this 
 * class can contain a more descriptive message.
 *
 * Subclasses of Result can create their own 'Result' subclasses that
 * can contain protocol-specific result information.
 */
class Result : public com::NetworkResult
{
    friend wostream& operator<<(wostream&, const Result&);

  public:

    typedef enum {
	Success, 
	Error, 
	Cancelled
    } Status;

    Result(const Status& status, const wstring& message, long fileTime = 0);
    virtual ~Result();

    /**
     * @return the status of the result
     */
    Status status() const;

    /**
     * @return true if the result status is Success
     */
    virtual bool success() const;

    /**
     * @return true if the result status is Error
     */
    virtual bool error() const;

    /**
     * @return true if the result status is Cancelled
     */
    virtual bool cancelled() const;

    /**
     * @return a descriptive text value indicating the result, or 
     * an empty string if no description is available or appropriate
     */
    virtual wstring message() const;

    virtual wstring toString() const;

    /**
     * @return the file modified time returned by the download
     */
    long fileTime() const { return m_fileTime; }    

    void setStatus(Status stat);

  private:

    Status m_status;
    wstring m_message;
    long m_fileTime;
};

} // namespace network
=====================================================================
Found a 26 line (134 tokens) duplication in the following files: 
Starting at line 370 of D:\home\eCora_PM\PM\importExport\ScanResults.cpp
Starting at line 1822 of D:\home\eCora_PM\PM\importExport\ScanResults.cpp

            CComQIPtr<com::IAppDatabase> pDatabase(m_scanResults->m_services);

            // relation
            CComPtr<com::IDbRelation> pRelation;
            HRESULT hr = pDatabase->getDbRelation(&pRelation);
            if (FAILED(hr))
            {
                log(L"ScanResults", Log::Error, L"Could not get db relation");
                return;
            }

            idb::GroupObject defaultGroup(QString(DEFAULT_GROUP));
            CComPtr<com::IDbContainer> pDbContainer;

            hr = pDatabase->getDbContainer(&pDbContainer);
            if (FAILED(hr))
            {
                log(L"ScanResults", Log::Error, L"Could not get db conatiner");
                return;
            }

            pDbContainer->registerObjectType((IUnknown*)&defaultGroup);
            pDbContainer->addObject((IUnknown*)&defaultGroup);

            hr = pDbContainer->registerObjectType(
                (IUnknown*)&idb::UnixDevice(m_scanResults->m_services));
=====================================================================
Found a 10 line (134 tokens) duplication in the following files: 
Starting at line 103 of D:\home\eCora_PM\PM\customPatch\ExportWizard.cpp
Starting at line 52 of D:\home\eCora_PM\PM\customPatch\ImportWizard.cpp

    cancelButton()->setText(tr("Cancel"));
    QToolTip::add(cancelButton(), tr("Closes window without saving"));
    QWhatsThis::add(cancelButton(), tr("Closes window without saving"));
    QToolTip::add(helpButton(), tr("Opens online help"));
    QWhatsThis::add(helpButton(), tr("Opens online help"));
    QToolTip::add(backButton(), tr("Opens previous page of the wizard"));
    QWhatsThis::add(backButton(), tr("Opens previous page of the wizard"));
    QToolTip::add(nextButton(), tr("Opens next page of the wizard"));
    QWhatsThis::add(nextButton(), tr("Opens next page of the wizard"));
    QToolTip::add(finishButton(), tr("Starts the import process"));
=====================================================================
Found a 13 line (134 tokens) duplication in the following files: 
Starting at line 355 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp
Starting at line 496 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp

    CustomFileDef* cf = m_newPatch->m_files[i];
    CustomFilesDef dlg(true, path, version, checksum, this, m_tableFile->currentRow(), m_tableFile);
    if (dlg.exec() == QDialog::Accepted)
    {
        cf->m_path = dlg.m_path;
        cf->m_version = dlg.m_version;
        cf->m_checksum = dlg.m_checksum;
        m_tableFile->setItem(num, 0,
            new ESTableItem(m_tableFile, QTableItem::Never, dlg.m_path));
        m_tableFile->setItem(num, 1,
            new ESTableItem(m_tableFile, QTableItem::Never, dlg.m_version));
        m_tableFile->setItem(num, 2,
            new ESTableItem(m_tableFile, QTableItem::Never, dlg.m_checksum));
=====================================================================
Found a 17 line (133 tokens) duplication in the following files: 
Starting at line 205 of D:\home\eCora_PM\PM\utils\Base64.cc
Starting at line 222 of D:\home\eCora_PM\PM\utils\Base64.cc

    '\177', '\177', '\177', '\177', /* 274-277 */
    '\177', '\177', '\177', '\177', /* 300-303 */
    '\177', '\177', '\177', '\177', /* 304-307 */
    '\177', '\177', '\177', '\177', /* 310-313 */
    '\177', '\177', '\177', '\177', /* 314-317 */
    '\177', '\177', '\177', '\177', /* 320-323 */
    '\177', '\177', '\177', '\177', /* 324-327 */
    '\177', '\177', '\177', '\177', /* 330-333 */
    '\177', '\177', '\177', '\177', /* 334-337 */
    '\177', '\177', '\177', '\177', /* 340-343 */
    '\177', '\177', '\177', '\177', /* 344-347 */
    '\177', '\177', '\177', '\177', /* 350-353 */
    '\177', '\177', '\177', '\177', /* 354-357 */
    '\177', '\177', '\177', '\177', /* 360-363 */
    '\177', '\177', '\177', '\177', /* 364-367 */
    '\177', '\177', '\177', '\177', /* 370-373 */
    '\177', '\177', '\177', '\177', /* 374-377 */
=====================================================================
Found a 29 line (133 tokens) duplication in the following files: 
Starting at line 530 of D:\home\eCora_PM\PM\pmDaoDbImpl\DaoDbImplUnitTest.h
Starting at line 691 of D:\home\eCora_PM\PM\pmDaoXmlImpl\DaoXmlImplUnitTest.h

        iProduct->setLanguage(L"ENU");
        iProduct->setStatus(0);

        iPatch = iProduct->addPatch();

        iPatch->setPatchId(L"rVq+g0BocGJL1iAHMt9Z+w==");
        iPatch->setStatus(L"NOTFOUND");
        iPatch->setComment(L"The file \\192.168.0.31\\C$\\WINNT\\system32\\smss.exe "
            L"has a wrong version: 4.0.1381.273. The expected version is: 4.0.1381.7152");
        iPatch->setUninstallData(L"Test uninstall string");

        iPatch = iProduct->addPatch();

        iPatch->setPatchId(L"rks2l1kDCYRhC9qpH21dtA==");
        iPatch->setStatus(L"FOUND");
        iPatch->setComment(L"Test comment");
        iPatch->setUninstallData(L"c:\\winnt\\$NtUninstallQ815021$\\hotfix.exe /u");
    }

    void addTestProducts(pmDaoInterfaces::ISystem* iSystem)
    {
        assert(iSystem);

        pmDaoInterfaces::IProduct* iProduct = iSystem->addProduct();

        iProduct->setVersionId(L"Internet Information Server 4.0 - Windows NT4 Service Pack 6a");
        iProduct->setInstance(L"Test Instance");
        iProduct->setLocation(L"Test Location");
        iProduct->setLanguage(L"ENU");
=====================================================================
Found a 32 line (133 tokens) duplication in the following files: 
Starting at line 187 of D:\home\eCora_PM\PM\patchRepository\upgrade\upgrade.cpp
Starting at line 251 of D:\home\eCora_PM\PM\patchRepository\upgrade\upgrade.cpp

	    L"' AND language.patchFK = patch.id AND location.languageFK = language.id ";

	log(L"patchRepositoryUpgrade", Log::Info, L"Query to get id: " << query);
	
	try
	{
	    PatchQueryHelper qh(m_services);
	    QSqlDatabase* db = qh.database();

	    QSqlQuery sqlQuery(ws2qs(query), db);
	    if (sqlQuery.next())
	    {
		wstring languageId = qs2ws(sqlQuery.value(0).toString());
		wstring filepath20 = qs2ws(d.absPath());

		log(L"patchRepositoryUpgrade", Log::Info, L"Language id: " << languageId);

		// try to insert the patch in a version 3 repository
		// some patches contain more than one file, so insert will look for all files
		m_repoManager30->insert(languageId, filepath20);
	    }
	}
	catch (GenericException& e)
	{
	    log(L"patchRepositoryUpgrade", Log::Error, e.userMessage());
	}
    }
}


/*  Regular patches */
void Upgrade::upgradeProduct(const wstring& product)
=====================================================================
Found a 21 line (133 tokens) duplication in the following files: 
Starting at line 96 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\persistent_mr.h
Starting at line 121 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\persistent_mr.h

    virtual ~uninstall_MR();
    virtual int call(void);

    template <class Context>
    inline void XMLpersist(Context* ctx, const tstring& name, DOMElement* parent)
    {
        DOMElement* el = ctx->getElement(parent, name);
        ecora::xmlutils::XMLpersist<Context>(ctx,
            dynamic_cast<afw::Persistent_Method_Request&>(*this),
            ACE_TEXT("Base"), el);
        ecora::xmlutils::XMLpersist(ctx, m_package, ACE_TEXT("Package"), el);
        ecora::xmlutils::XMLpersist(ctx, m_jr, ACE_TEXT("JobRequest"), el);
    }

  private:
    CJobReq m_jr;
    tstring m_package;
    ACE_Future<afw::CResult> m_res;
};

class insert_request_MR : public afw::Persistent_Method_Request
=====================================================================
Found a 20 line (132 tokens) duplication in the following files: 
Starting at line 1082 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 970 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::appendSystems");

    QDomElement systemsNode = root.ownerDocument().createElement(SelectedSystems);
    root.appendChild(systemsNode);

    QDictIterator<com::IDbObject> itrSystem(systems);
    while (itrSystem.current())
    {
        QString qsKey = itrSystem.currentKey();
        QString qsClass = itrSystem.current()->getObjectType();
        if (qsKey.length() && qsClass.length())
        {
            QDomElement element = root.ownerDocument().createElement(SystemTagName);
            element.setAttribute(SystemID, qsKey);
            element.setAttribute(SystemClass, qsClass);
            systemsNode.appendChild(element);
        }
        ++itrSystem;
    }
    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::appendSystems, exiting");
=====================================================================
Found a 21 line (132 tokens) duplication in the following files: 
Starting at line 2391 of D:\home\eCora_PM\PM\pmAnalysisWinProvider\AnalyzeOffice.cpp
Starting at line 2636 of D:\home\eCora_PM\PM\pmAnalysisWinProvider\AnalyzeOffice.cpp

        log(L"pmAnalysisWinProvider", Log::Debug, L"Office2010::identifyOfficeLanguage: 0ffice 2010 language: ENU");
        return L"ENU";
    }
    else
    {
        pmServices::RegKey openKey(0);
        DWORD index = -1;
        if (RegOpenKeyEx(m_connectionKey->key(), regLocation.c_str(), 0, KEY_ALL_ACCESS | flag, openKey.pKey()) != ERROR_SUCCESS)
            return L"";
        while (true)
        {
            TCHAR keyName[1024];
            BYTE keyData[1024];
            DWORD keyNameLen;
            keyNameLen = 1023;
            memset(keyData, 0, sizeof(keyData));
            ++index;
                
            if (RegEnumValue(openKey.key(), index, keyName, &keyNameLen, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
            {
                log(L"pmAnalysisWinProvider", Log::Debug, L"Office2010::identifyOfficeLanguage: 0ffice 2010 language: Unknown");
=====================================================================
Found a 13 line (132 tokens) duplication in the following files: 
Starting at line 57 of D:\home\eCora_PM\PM\network\PtyConnection.cpp
Starting at line 320 of D:\home\eCora_PM\PM\unix-collector\UnixConnection.cc

    log(L"UnixConnection::login()", Log::Debug,
	L"Login to remote server.");
	
    vector<pair<bstring, int> > possible;
    possible.push_back(pair<bstring, int>("(yes/no)? ", QUESTION));
    possible.push_back(pair<bstring, int>("(yes/no)?", QUESTION));
    possible.push_back(pair<bstring, int>("(y/n)?", QUESTION));
    possible.push_back(pair<bstring, int>("? (y/n)", QUESTION));
    possible.push_back(pair<bstring, int>("? (yes/no)", QUESTION));
    
    // Various ways of prompting for a user name:
    possible.push_back(pair<bstring, int>("ogin:", USER));
    possible.push_back(pair<bstring, int>("OGIN:", USER));
=====================================================================
Found a 11 line (132 tokens) duplication in the following files: 
Starting at line 1199 of D:\home\eCora_PM\PM\hostManager\SystemsDeleteWizard.cpp
Starting at line 1023 of D:\home\eCora_PM\PM\pmAgentManagement\OptionalAgentDeployWizard.cpp

            QSqlQuery q = m_db->exec(qs2ws(queryStr));
            while (q.next())
            {
                // Build up a vector of ScanSettings for use in communication with the threads.
                wstring systemName = qs2ws(q.value(0).asString());
                wstring domainName = qs2ws(q.value(2).asString());
                wstring ipAddress = qs2ws(q.value(3).asString());
                wstring systemId = qs2ws(q.value(4).asString());
                wstring userName = qs2ws(q.value(5).asString());
                wstring passwd = qs2ws(q.value(6).asString());
                passwd = pmServices::Utils::decrypt(passwd);
=====================================================================
Found a 15 line (131 tokens) duplication in the following files: 
Starting at line 61 of D:\home\eCora_PM\PM\woodstock\QtInterface.h
Starting at line 119 of D:\home\eCora_PM\PM\woodstock\QtInterface.h

    virtual int information(const wstring& caption, const wstring& text,
        const wstring* pButton0Text = 0,
        const wstring* pButton1Text = 0,
        const wstring* pButton2Text = 0, int defaultButtonNumber = 0, 
        int escapeButtonNumber = -1) const;
    virtual int warning(const wstring& caption, const wstring& text,
        const wstring* pButton0Text = 0,
        const wstring* pButton1Text = 0,
        const wstring* pButton2Text = 0, int defaultButtonNumber = 0, 
        int escapeButtonNumber = -1) const;
    virtual int critical(const wstring& caption, const wstring& text,
        const wstring* pButton0Text = 0,
        const wstring* pButton1Text = 0,
        const wstring* pButton2Text = 0, int defaultButtonNumber = 0, 
        int escapeButtonNumber = -1) const;
=====================================================================
Found a 26 line (131 tokens) duplication in the following files: 
Starting at line 174 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\OfficePatch.cpp
Starting at line 175 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\Patch.cpp

    }

    wstring repoPath = repo->uncPath(langKey(), getPmSelectData()->getHostId(),
        pmPushBaseModel::IComputer::Conventional); // AltRepo FIX by StUV
    
    if (!repoPath.empty())
    {
        wstring dir = repoPath + L"\\";
        setFullRepoPath(dir + displayName());
        setDir(dir);
    }

    unsigned long size = 0;
    if (!useRepo || transferOnly)
    {
        actionSeq->push_back(RepoMoveAction::representation((*id)++, 
            langKey(), getPmSelectData()->getHostId(), patchFullPath, displayName()));
        size = repo->patchSize(langKey());
    }

    repo->Release();

    return size;
}

unsigned long 
=====================================================================
Found a 31 line (131 tokens) duplication in the following files: 
Starting at line 1293 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 1282 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

            L"no task, exiting");
        return;
    }
    map<wstring, com::IDbObject*> allSelectedSystems;
    loadTaskSelection(task, allSelectedSystems);

    //QDict<idb::WindowsDevice> selectedWinSystems;
    //QDict<idb::UnixDevice> selectedUnixSystems;

    map<wstring, com::IDbObject*>::const_iterator systemIt = allSelectedSystems.begin();
    for (; systemIt != allSelectedSystems.end(); ++systemIt)
    {
        com::IDbObject* system = systemIt->second;
        QString systemId(system->getKeyAsString());
        
        if (system->getObjectType() == "WindowsSystem")
        {
            //idb::WindowsDevice* winSystem = static_cast<idb::WindowsDevice*>(system);
            //selectedWinSystems.insert(systemId, winSystem);
            selectedWinSystems.push_back(qs2ws(systemId));
        }
        
        if (system->getObjectType() == "UnixSystem")
        {
            //idb::UnixDevice* unixSystem = static_cast<idb::UnixDevice*>(system);
            //selectedUnixSystems.insert(systemId, unixSystem);
            selectedUnixSystems.push_back(qs2ws(systemId));
        }
    }

    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::prepareSystems, exiting");
=====================================================================
Found a 18 line (131 tokens) duplication in the following files: 
Starting at line 470 of D:\home\eCora_PM\PM\patchRepository\RepositoryUnitTest.h
Starting at line 98 of D:\home\eCora_PM\PM\pmServices\Resources.cc

        xml::BaseNode* baseRes = m_resourceFile->query(L"resources", 0);
        xml::Node* res = dynamic_cast<xml::Node*>(baseRes);
    
        xml::Node::iterator it;
        for (it = res->begin(); it != res->end(); ++it)
        {
            xml::Node* resource = dynamic_cast<xml::Node*>(*it);
            if (resource != 0)
            {
                wstring tag = resource->name();
                xml::Data* data = dynamic_cast<xml::Data*>(*resource->begin());
                if (data)
                {
                    wstring value = data->value(true);
                    m_resources[tag] = value;
                }
            }
        }
=====================================================================
Found a 35 line (131 tokens) duplication in the following files: 
Starting at line 193 of D:\home\eCora_PM\PM\patchManager\GUIThread.cpp
Starting at line 206 of D:\home\eCora_PM\PM\pmAgentManagement\GUIThread.cpp

	    nLoops = (nMultiscans > 0 ? nMultiscans : 1);
	}

	// get the number of hosts that can be scan once
	int nOneTimeHosts = (maxThreads > nLoops * nSelectedComputers ? 
	    nLoops * nSelectedComputers : maxThreads);

	// create threads
	for (int i = 0; i < nOneTimeHosts; ++i)
	{
	    m_guiThreadList[i]->start();
	}

	int finishedThreads = 0;
	int newHosts = 0;
	int totalThreads = m_guiThreadList.size();

	do
        {
	    for (int j = 0; j < totalThreads; ++j)
	    {
                    
                if (!m_guiThreadList[j]->isFinished() && 
                    m_guiThreadList[j]->isRunning() && 
                    m_guiThreadList[j]->check())
                    
		{
                    // one thread finished
             	    ++finishedThreads;

		    if (m_bStop && finishedThreads == nOneTimeHosts + newHosts)
		        break;

		    // do we need new threads ?
		    if (((nOneTimeHosts + newHosts) < totalThreads) && (m_bStop == false))
=====================================================================
Found a 23 line (131 tokens) duplication in the following files: 
Starting at line 468 of D:\home\eCora_PM\PM\importExport\ScanResults.cpp
Starting at line 497 of D:\home\eCora_PM\PM\importExport\ScanResults.cpp

            log(L"ScanResults", Log::Error, L"Could not register idb::UnixDevice!");
            return false;
        }
        hr = pDbContainer->retrieveObject(hostFK, (IUnknown*)&device);
        if (FAILED(hr))
        {
            log(L"ScanResults", Log::Error, L"Could not retrieve device: " + qs2ws(hostFK) + L"!");
            return false;
        }
        hr = pDatabase->getDbRelation(&pRelation);
        if (FAILED(hr))
        {
            log(L"ScanResults", Log::Error, L"Could not retrieve a relation!");
            return false;
        }
        hr = pRelation->setRelation((IUnknown*)&group, (IUnknown*)&device);
        if (FAILED(hr))
        {
            log(L"ScanResults", Log::Error, L"Could not set relation!");
            return false;
        }
    }
    else
=====================================================================
Found a 9 line (131 tokens) duplication in the following files: 
Starting at line 270 of D:\home\eCora_PM\PM\fksec\main.cpp
Starting at line 279 of D:\home\eCora_PM\PM\fksec\main.cpp

	out << _T( "Different SIDs:" ) << std::endl;
	out << _T( "a0 == a1: " ) << (bool) ( a0 == a1 ) << std::endl;
	out << _T( "a1 == a0: " ) << (bool) ( a1 == a0 ) << std::endl;
	out << _T( "a0 != a1: " ) << (bool) ( a0 != a1 ) << std::endl;
	out << _T( "a1 != a0: " ) << (bool) ( a1 != a0 ) << std::endl;
	out << _T( "a0 <  a1: " ) << (bool) ( a0 <  a1 ) << std::endl;
	out << _T( "a1 <  a0: " ) << (bool) ( a1 <  a0 ) << std::endl << std::endl;

	a1 = a0;
=====================================================================
Found a 20 line (131 tokens) duplication in the following files: 
Starting at line 32 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\SelfTest.h
Starting at line 20 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\cancel_job.h

    ~cancel_job();

// AgentConnectionBase interface
    virtual bool requestJob(const JobData& job_data, tostream& stream);

    virtual bool putJobStatus(const JobData& job_data,
        const tstring& job_id, const tstring& job_status);

    virtual bool downloadJobData(const JobData& job_data, const tstring& job_id,
        const tstring& temp_name, const tstring& dest_path, const tstring& session_id);

    virtual bool uploadJobRequestData(const JobData& job_data, const tstring& job_id,
        const tstring& result_name, const tstring& job_path, const tstring& session_id);

    virtual bool registerAgent(const tstring& serial_num, int job_req_interval, tostream& agent_id);

    virtual bool unregisterAgent(const tstring& serial_num, const tstring& agent_id);

// InstallerBase interface
    virtual bool install(const tstring& package, const tstring& version);
=====================================================================
Found a 23 line (131 tokens) duplication in the following files: 
Starting at line 540 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\HandleIIS.cpp
Starting at line 709 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\HandleIIS.cpp

    ReportMessage(hInstall, _T("NORMAL"), _T("SetWindowsAuthentication started"));

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        ReportError(hInstall, __FILE__, __LINE__, _T("CoInitializeEx failed. Error %d"), hr);
        return uiRet;
    }

    bufLen = 1024;
    uiStat =  MsiGetProperty(hInstall, _T("CustomActionData"), caData, &bufLen);
    if (ERROR_SUCCESS != uiStat)
    {
        ReportError(hInstall, __FILE__, __LINE__, _T("Can't get CustomActionData property. Error %d"), uiStat);
        goto l_end;
    }
    ptr = _tcschr(caData, ';');
    if (NULL == ptr)
    {
        ReportError(hInstall, __FILE__, __LINE__, _T("Incorrect CustomActionData format: %s"), caData);
        goto l_end;
    }
    ptr[0] = 0;
=====================================================================
Found a 11 line (131 tokens) duplication in the following files: 
Starting at line 383 of D:\home\eCora_PM\PM\NetDiscover\IpDiscover.h
Starting at line 240 of D:\home\eCora_PM\PM\NetDiscover\NetDiscover.h

            device.setFieldValue(idb::WindowsDevice::OS, device.getOsName(si.sv101_version_major, si.sv101_version_minor));

            // default values
            device.setFieldValue(idb::WindowsDevice::DriveShare, QString("Admin$"));
            device.setFieldValue(idb::WindowsDevice::UseRepository, QString("false"));
            device.setFieldValue(idb::WindowsDevice::SkipTasks, QString("false"));
            device.setFieldValue(idb::WindowsDevice::FreeDisk, QString("250"));
            device.setFieldValue(idb::WindowsDevice::InstTimeout, QString("60"));
            device.setFieldValue(idb::WindowsDevice::QChain, QString("true"));
            device.setFieldValue(idb::WindowsDevice::AllowReboot, QString("true"));
            device.setFieldValue(idb::WindowsDevice::ForceClose, QString("false"));
=====================================================================
Found a 24 line (130 tokens) duplication in the following files: 
Starting at line 977 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\Idb.cc
Starting at line 1024 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\Idb.cc

	return false;

    list<Attribute*> attributes;
    attributes.clear();

    vector<wstring>::iterator valIt = attrValues.begin();
    for (vector<wstring>::iterator nameIt = attrNames.begin();
	        nameIt != attrNames.end(); ++nameIt)
    {
        Attribute* ptr = new Attribute(static_cast<wstring>(*nameIt), 
                                        static_cast<wstring>(*valIt), false);
        attributes.push_back(ptr);
        ++valIt;
    }

    list<Object*> objects;
    // clear it 
    objects.clear();
	
    IdbRecord* ptr = new IdbRecord(name, attributes, objects);
     
    parent->push_back(ptr);

    return true;
=====================================================================
Found a 22 line (130 tokens) duplication in the following files: 
Starting at line 43 of D:\home\eCora_PM\PM\network\Ftp.h
Starting at line 38 of D:\home\eCora_PM\PM\network\Http.h

    virtual ~Http();

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(
        const GUID& iid, void** ptr);
    virtual unsigned long STDMETHODCALLTYPE AddRef();
    virtual unsigned long STDMETHODCALLTYPE Release();

    /**
     * Implementation of the Client interface
     */
    virtual bool url2wstring(
        const wstring& url, wstring* content = 0, 
        bool runInThread = true, com::NetworkResult** result = 0);
    virtual bool url2file(
        const wstring& url, const wstring& file, 
        bool runInThread = true, com::NetworkResult** result = 0);
    
    virtual void useProxy(const wstring& addr, const wstring& login, 
        const wstring& pass, const bool useNTLM);
    
    virtual void setCredentials(
        const wstring& login, const wstring& password);
=====================================================================
Found a 23 line (130 tokens) duplication in the following files: 
Starting at line 49 of D:\home\eCora_PM\PM\hostManager\WinNonAgentRemediSettings.h
Starting at line 36 of D:\home\eCora_PM\PM\hostManager\WindowsRemediationSettings.h

    virtual bool validate();

    int freeSpace() const;
    int timeout() const;
    bool useQChain() const;
    bool forceAppsClosed() const;
    bool allowReboot() const;
    bool skipTasks() const;
    bool useRepo() const;
    QString repoPath() const;
    QString interventionMethod() const;
    int interventionDelay() const;

    void setFreeSpace(int);
    void setTimeout(int);
    void setUseQChain(bool);
    void setForceAppsClosed(bool);
    void setAllowReboot(bool);
    void setSkipTasks(bool);
    void setUseRepo(bool);
    void setRepoPath(const QString&);
    void setInterventionMethod(const QString&);
    void setInterventionDelay(int);
=====================================================================
Found a 7 line (130 tokens) duplication in the following files: 
Starting at line 270 of D:\home\eCora_PM\PM\fksec\main.cpp
Starting at line 299 of D:\home\eCora_PM\PM\fksec\main.cpp

	out << _T( "Different inheritance flags:" ) << std::endl;
	out << _T( "a0 == a1: " ) << (bool) ( a0 == a1 ) << std::endl;
	out << _T( "a1 == a0: " ) << (bool) ( a1 == a0 ) << std::endl;
	out << _T( "a0 != a1: " ) << (bool) ( a0 != a1 ) << std::endl;
	out << _T( "a1 != a0: " ) << (bool) ( a1 != a0 ) << std::endl;
	out << _T( "a0 <  a1: " ) << (bool) ( a0 <  a1 ) << std::endl;
	out << _T( "a1 <  a0: " ) << (bool) ( a1 <  a0 ) << std::endl << std::endl;
=====================================================================
Found a 28 line (130 tokens) duplication in the following files: 
Starting at line 1301 of D:\home\eCora_PM\PM\bzip2\bzip2.c
Starting at line 1458 of D:\home\eCora_PM\PM\bzip2\bzip2.c

            if ( inStr != NULL ) fclose ( inStr );
            setExit(1);
            return;
         };
         break;

      case SM_F2F:
         inStr = fopen ( inName, "rb" );
         outStr = fopen ( outName, "wb" );
         if ( outStr == NULL) {
            fprintf ( stderr, "%s: Can't create output file %s: %s.\n",
                      progName, outName, strerror(errno) );
            if ( inStr != NULL ) fclose ( inStr );
            setExit(1);
            return;
         }
         if ( inStr == NULL ) {
            fprintf ( stderr, "%s: Can't open input file %s: %s.\n",
                      progName, inName, strerror(errno) );
            if ( outStr != NULL ) fclose ( outStr );
            setExit(1);
            return;
         };
         setInterimPermissions ( outName );
         break;

      default:
         panic ( "uncompress: bad srcMode" );
=====================================================================
Found a 22 line (130 tokens) duplication in the following files: 
Starting at line 32 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\SelfTest.h
Starting at line 20 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\system_shutdown.h

    ~system_shutdown();



// AgentConnectionBase interface
    virtual bool requestJob(const JobData& job_data, tostream& stream);

    virtual bool putJobStatus(const JobData& job_data,
                const tstring& job_id, const tstring& job_status);

    virtual bool downloadJobData(const JobData& job_data, const tstring& job_id,
                const tstring& temp_name, const tstring& dest_path, const tstring& session_id);

    virtual bool uploadJobRequestData(const JobData& job_data, const tstring& job_id,
                const tstring& result_name, const tstring& job_path, const tstring& session_id);

    virtual bool registerAgent(const tstring& serial_num,
                int job_req_interval, tostream& agent_id);

    virtual bool unregisterAgent(const tstring& serial_num, const tstring& agent_id);

    virtual void cleanup(void) {};
=====================================================================
Found a 29 line (129 tokens) duplication in the following files: 
Starting at line 158 of D:\home\eCora_PM\PM\zlib\Zipper.cpp
Starting at line 242 of D:\home\eCora_PM\PM\zlib\Zipper.cpp

	zip_fileinfo zfi;

	zfi.internal_fa = 0;
	zfi.external_fa = ::GetFileAttributes(szFilePath);
	
	// save file time
	SYSTEMTIME st;

	GetLastModified(szFullFilePath, st, TRUE);

	zfi.dosDate = 0;
	zfi.tmz_date.tm_year = st.wYear;
	zfi.tmz_date.tm_mon = st.wMonth - 1;
	zfi.tmz_date.tm_mday = st.wDay;
	zfi.tmz_date.tm_hour = st.wHour;
	zfi.tmz_date.tm_min = st.wMinute;
	zfi.tmz_date.tm_sec = st.wSecond;

	// load input file
	HANDLE hInputFile = ::CreateFile(szFullFilePath, 
									GENERIC_READ,
									0,
									NULL,
									OPEN_EXISTING,
									FILE_ATTRIBUTE_READONLY,
									NULL);

	if (hInputFile == INVALID_HANDLE_VALUE)
		return FALSE;
=====================================================================
Found a 12 line (129 tokens) duplication in the following files: 
Starting at line 47 of D:\home\eCora_PM\PM\fs\LocalFileSystem.h
Starting at line 59 of D:\home\eCora_PM\PM\fs\RootedFileSystem.h

    virtual void create(const wstring& name);
    virtual int read(
        const wstring& file, void* buffer, int bufferSize, int seekpos = 0);
    virtual int write(
        const wstring& file, void* buffer, int bufferSize, int seekpos = 0);
    virtual void file2wstring(const wstring& file, wstring& content);
    virtual void wstring2file(const wstring& file, const wstring& content);
    virtual void file2utf8string(const wstring& file, utf8string& content);
    virtual void utf8string2file(
        const wstring& file, const utf8string& content);
    virtual int cp(const wstring& src, const wstring& dst);
    virtual wstring mkstemp(const wstring& file);
=====================================================================
Found a 29 line (129 tokens) duplication in the following files: 
Starting at line 1413 of D:\home\eCora_PM\PM\configWizard\ConfigWizard.cpp
Starting at line 1543 of D:\home\eCora_PM\PM\configWizard\ConfigWizard.cpp

        idb::WindowsDevice device = dynamic_cast<ConfigWizardDialog*>(m_wizard)->getDevice();

        CComQIPtr<com::IAppDatabase> pDatabase(dialog->getIServices());
        if (!pDatabase)
        {
            throw GenericException(__FILE__, __LINE__,
                L"RCenterPage::next()", L"",
                L"Unable to initialize database.");
        }

        CComPtr<com::IDbContainer> pDbWindowsContainer;
        HRESULT hr = pDatabase->getDbContainer(&pDbWindowsContainer);
        if (FAILED(hr))
        {
            throw GenericException(__FILE__, __LINE__,
                L"RCenterPage::next()", L"",
                L"Unable to retrieve DbContainer.");
        }

        hr = pDbWindowsContainer->registerObjectType((IUnknown*)&idb::WindowsDevice());
        if (FAILED(hr))
        {
            throw GenericException(__FILE__, __LINE__,
                L"RCenterPage::next()", L"",
                L"Unable to register idb::WindowsDevice.");
        }

        hr = E_FAIL;
        hr = pDbWindowsContainer->retrieveObject((IUnknown*)&device);
=====================================================================
Found a 29 line (129 tokens) duplication in the following files: 
Starting at line 154 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\EcoraRCSetup.cpp
Starting at line 266 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\PatchSetup\PatchSetup.cpp

	}
}

void ReportMessage(LPTSTR msg)
{

	LPCTSTR lpStrings[1];
	lpStrings[0] = msg;

	BOOL bres = ReportEvent(hLog, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, lpStrings, NULL);
}

void ReportError(LPTSTR msg, long line)
{

	LPCTSTR lpStrings[2];
	TCHAR	sLine[64];

	_stprintf(sLine, _T("\nError at line:%ld"), line);
	lpStrings[0] = msg;
	lpStrings[1] = sLine;

	BOOL bres = ReportEvent(hLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL, 2, 0, lpStrings, NULL);
}

void CloseLog()
{

	if (hLog) CloseEventLog(hLog);
=====================================================================
Found a 24 line (128 tokens) duplication in the following files: 
Starting at line 570 of D:\home\eCora_PM\PM\hostManager\ObjectView.cpp
Starting at line 642 of D:\home\eCora_PM\PM\hostManager\ObjectView.cpp

ObjectView<TDevice>::removeObjectsFromGroup(QString qsGroup)
{ 
    WAIT_CURSOR();

    HRESULT hr = m_pDbContainer->registerObjectType((IUnknown*)&idb::GroupObject());
    _IfFailHrRet(hr);

    idb::GroupObject group;
    hr = m_pDbContainer->retrieveObject(qsGroup, (IUnknown*)&group);
    _IfFailHrRet(hr);

    // reuse container
    hr = m_pDbContainer->registerObjectType((IUnknown*)&TDevice(m_pServices));
    _IfFailHrRet(hr);

    int iCounter = 0;
    QSqlCursor* deviceCursor = EsDataTableObject->sqlCursor();
    _IfNullPtrRet(deviceCursor);

    int iSelections = EsDataTableObject->numSelections();
    int iProgressSize = 0;

    // count progress bar size
    for (int idx = 0; idx < iSelections; ++idx)
=====================================================================
Found a 21 line (128 tokens) duplication in the following files: 
Starting at line 1104 of D:\home\eCora_PM\PM\customPatch\ExportWizard.cpp
Starting at line 903 of D:\home\eCora_PM\PM\customPatch\ImportWizard.cpp

bool ImportWizard::checkPath()
{
    wstring wsPath = qs2ws(m_lePath->text());
    if (!wsPath.empty() && (wsPath.length() > 2))
    {
        if ((wsPath.substr(0, 2) == L"\\\\") || // UNC path
            (wsPath.substr(1, 2) == L":\\") ||  // local path
            (wsPath.substr(1, 2) == L":/"))     // local path
        {
            if (wsPath.find(L"/") != wstring::npos)
            {
                QString qsPath = m_lePath->text();
                qsPath.replace('/', '\\');
                m_lePath->setText(qsPath);
            }
            return true;
        }
    }

    return false;
}
=====================================================================
Found a 31 line (128 tokens) duplication in the following files: 
Starting at line 56 of D:\home\eCora_PM\PM\agent\agent\Library\Common\CommandLine.cpp
Starting at line 61 of D:\home\eCora_PM\PM\agent\agent\Library\PsExecLib\CommandLine.cpp

    result += _T("\"");

    return result;
}


bool CommandLine::findParam(const tstring& flag) const
{
    ParamCont::const_iterator ci = m_cont.begin();
    ParamCont::const_iterator end = m_cont.end();

    for (; ci != end; ++ci)
    {
        if (ci->first == flag)
            return true;
    }

    return false;
}


tstring CommandLine::getParam(const tstring& flag) const
{
    ParamCont::const_iterator ci = m_cont.begin();
    ParamCont::const_iterator end = m_cont.end();

    for (; ci != end; ++ci)
    {
        if (ci->first == flag)
            return ci->second;
    }
=====================================================================
Found a 19 line (128 tokens) duplication in the following files: 
Starting at line 84 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\HandleIIS.cpp
Starting at line 842 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\HandleIIS.cpp

    wsprintf(adsPath, L"IIS://localhost/W3SVC/%s/ROOT", siteNum);
    hr = ADsGetObject(adsPath, IID_IADsContainer, (void**) &pAdsCont);
    if (FAILED(hr))
    {
        GetADSIErrorMessage(hr, errorMsg);
        ReportError(hInstall, __FILE__, __LINE__, _T("AdsGetObject(%s) failed. %s"), adsPath, errorMsg);
        goto l_end;
    }

    hr = pAdsCont->QueryInterface(IID_IADs, (void**)&pAds);
    if (FAILED(hr))
    {
        GetADSIErrorMessage(hr, errorMsg);
        ReportError(hInstall, __FILE__, __LINE__, _T("QueryInterface(IID_IADs) failed. %s"), adsPath, errorMsg);
        goto l_end;
    }

    VariantInit(&var);
    hr = pAds->Get(L"Path", &var);
=====================================================================
Found a 17 line (127 tokens) duplication in the following files: 
Starting at line 248 of D:\home\eCora_PM\PM\registry\registry.cpp
Starting at line 343 of D:\home\eCora_PM\PM\registry\registry.cpp

	        auto_ptr<TCHAR> subKey(new TCHAR[skeyLength + 1]);
	        _tcscpy(keypath, rootkey);
	        for (DWORD i = 0, j = _tcslen(keypath); i < skeyCount; ++i)
	        {
	            DWORD kLen = skeyLength + 1;
	            rc = RegEnumKeyEx(
		        rok.GetHKEY(), i, subKey.get(),
                        &kLen, NULL, NULL, NULL, NULL);
	            if (rc == ERROR_SUCCESS ||
		        rc == ERROR_INSUFFICIENT_BUFFER ||
		        rc == ERROR_MORE_DATA)
	            {
		      //if (wstring(subKey.get()) == L"NetRules"))
		      keypath[j] = '\0';
		      _tcscat(keypath, L"\\");
		      _tcscat(keypath, subKey.get());
		      GetRegTree(currentKeyInfo, keypath, filterList, depth + 1);
=====================================================================
Found a 33 line (127 tokens) duplication in the following files: 
Starting at line 18 of D:\home\eCora_PM\PM\network\NetworkExceptions.h
Starting at line 18 of D:\home\eCora_PM\PM\network\network\NetworkExceptions.h

using namespace std;


namespace network {


class ExecutionError : public GenericException
{
  public:
    ExecutionError(const char* file,
		   const int line,
                   const wstring& function = L"",
                   const wstring& parameters = L"",
		   const wstring& command = L"",
		   const wstring& response = L"",
		   const wstring& message = L"") :
                   m_command(command),
                   m_response(response),
                  
	GenericException(L"network::ExecutionError", file, line,
			 function, parameters, message) {}

    wstring command() { return m_command; }
    wstring response() { return m_response; }

    virtual ~ExecutionError() throw() {}
  private:
    wstring m_command;
    wstring m_response;
};


} // namespace network
=====================================================================
Found a 27 line (127 tokens) duplication in the following files: 
Starting at line 89 of D:\home\eCora_PM\PM\alerts\monitor\moduleContainer.cpp
Starting at line 85 of D:\home\eCora_PM\PM\pmServices\ModuleContainer.cpp

        Module* module = dynamic_cast<Module*>(*it);

        if (name == module->name())
            return dynamic_cast<com::IModule*>(module);
    }

    return 0;
}

vector<com::IModule*>
ModuleContainer::modulesToIModules(vector<Module*> modules) const
{
    vector<com::IModule*> retval;
    vector<Module*>::iterator it;

    for (it = modules.begin(); it != modules.end(); ++it)
    {
        retval.push_back(dynamic_cast<com::IModule*>(*it));
    }

    return retval;
}

vector<com::IModule*>
ModuleContainer::modules() const
{
    return modulesToIModules(m_app->modules());
=====================================================================
Found a 23 line (127 tokens) duplication in the following files: 
Starting at line 34 of D:\home\eCora_PM\PM\agent\agent\apps\Tests\ConnectorTest\ConnectorTest.cpp
Starting at line 33 of D:\home\eCora_PM\PM\agent\agent\apps\Tests\InstallerTest\InstallerTest.cpp

    const char* filename = "InstallerTester.log";
    ofstream* plog_ostream = new ofstream(filename, ios::out | ios::trunc);
    // Check for errors.
    if (!(*plog_ostream))
    {
        cerr << "Log failed to initialize. Exiting." << std::endl;
        delete plog_ostream;
        return 1;
    }
    // Set the ostream. And lets ACE_LOG_MSG removes it on destruction
    ACE_LOG_MSG->msg_ostream(plog_ostream, 1);

    u_long priority_mask = ACE_LOG_MSG->priority_mask(ACE_Log_Msg::PROCESS);
    ACE_SET_BITS(priority_mask, LM_DEBUG | LM_INFO);
    ACE_LOG_MSG->priority_mask(priority_mask, ACE_Log_Msg::PROCESS);

    // reads config files and initializes services
    ACE_Service_Config daemon;

    if (daemon.open(argc, argv) != 0)
        ACE_ERROR_RETURN ((LM_ERROR, "%p\n", "open"), 1);

    ACE_Sig_Action sa(reinterpret_cast<ACE_SignalHandler>(handler), SIGINT);
=====================================================================
Found a 15 line (127 tokens) duplication in the following files: 
Starting at line 626 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\JobReq.cpp
Starting at line 670 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\JobReq.cpp

                list.clear();
                dir_path = fn.c_str();
                std::replace(dir_path.begin(), dir_path.end(), ACE_TEXT('\\'), ACE_TEXT('/'));
                while (dir_path.size() > 2 && dir_path[0] == ECORA_TCHAR('/'))
                {
                    dir_path = dir_path.substr(1, dir_path.size());
                }
                pos = dir_path.find_last_of(ACE_TEXT('/'));
                if (tstring::npos != pos)
                {
                    dir_path = dir_path.substr(0, pos);
                    split_path(dir_path, list);
                    make_dir_list(workdir().c_str(), list);
                }
                ++irf;
=====================================================================
Found a 23 line (127 tokens) duplication in the following files: 
Starting at line 34 of D:\home\eCora_PM\PM\agent\agent\apps\Agent\Agent.cpp
Starting at line 34 of D:\home\eCora_PM\PM\agent\agent\apps\Tests\ConnectorTest\ConnectorTest.cpp

    const char* filename = "ConnectorTest.log";
    ofstream* plog_ostream = new ofstream(filename, ios::out | ios::trunc);
    // Check for errors.
    if (!(*plog_ostream))
    {
        cerr << "Log failed to initialize. Exiting." << std::endl;
        delete plog_ostream;
        return 1;
    }
    // Set the ostream. And lets ACE_LOG_MSG removes it on destruction
    ACE_LOG_MSG->msg_ostream(plog_ostream, 1);

    u_long priority_mask = ACE_LOG_MSG->priority_mask(ACE_Log_Msg::PROCESS);
    ACE_SET_BITS(priority_mask, LM_DEBUG | LM_INFO);
    ACE_LOG_MSG->priority_mask(priority_mask, ACE_Log_Msg::PROCESS);

    // reads config files and initializes services
    ACE_Service_Config daemon;

    if (daemon.open(argc, argv) != 0)
        ACE_ERROR_RETURN ((LM_ERROR, "%p\n", "open"), 1);

    ACE_Sig_Action sa(reinterpret_cast<ACE_SignalHandler>(handler), SIGINT);
=====================================================================
Found a 20 line (126 tokens) duplication in the following files: 
Starting at line 40 of D:\home\eCora_PM\PM\ui\license\TestWindow.cc
Starting at line 36 of D:\home\eCora_PM\PM\ui\network\TestWindow.cc

class MyEcoraLogin : public ui::network::EcoraLogin
{
  public:

      MyEcoraLogin() : ui::network::EcoraLogin(
	new QPixmap(), 
	L"http://www.ecora.com/cgi-bin/ecora/2.0/go?go=login&amp;"
	L"Login=${Login}&amp;Password=${Password}") {}

    virtual wstring savedLogin() { return L""; }
    virtual wstring savedPassword() { return L""; }
    virtual void save(const wstring&, const wstring&) {}
    virtual void browseAlternate(const wstring&) {}
    virtual ui::network::ProxySettings* proxySettings() { return &m_proxy; }
    virtual void saveProxySettings(ui::network::ProxySettings* s) { m_proxy = *s; }
    ui::network::ProxySettings m_proxy;
};

TestWindow::TestWindow()
{
=====================================================================
Found a 27 line (126 tokens) duplication in the following files: 
Starting at line 80 of D:\home\eCora_PM\PM\smsPackage\SmsWizardBuilder.cpp
Starting at line 302 of D:\home\eCora_PM\PM\smsPackage\SmsWizardBuilder.cpp

    IfFalseBoolThrow(bValid, L"SmsWizardBuilder::updateSmsPackage", L"", L"Cannot get the package object");

    SmsPackageData packageData;
    packageData.m_description = "Ecora Package";
    packageData.m_manufacturer = "Ecora";
    packageData.m_mifFileName = "ecoramif.mif";
    packageData.m_mIFName = "Ecora Mif";
    packageData.m_mifPublisher = "Ecora";
    packageData.m_mifVersion = getPackageVersion();
    packageData.m_packageName = getPackageName();
    packageData.m_pkgFlags = 268435456;  //USE_SPECIAL_MIF(29)
    packageData.m_pkgSourceFlag = 2; //STORAGE_DIRECT
    packageData.m_sourcePath = m_pMediator->repositoryPath();
    packageData.m_packageVersion = getPackageVersion();
    packageData.setData(pSmsPackage->object());

    pSmsPackage->setInstance();
    m_packageID = pSmsPackage->id();

    m_pPack->addInstance(pSmsPackage);

    mgsWrapper.setType(MessageSet::MSG_SUCCESS);
}

/*
*/
void SmsWizardBuilder::updateSmsProgram()
=====================================================================
Found a 25 line (126 tokens) duplication in the following files: 
Starting at line 1209 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\SolarisPatchAnalyzer.cpp
Starting at line 1265 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\SolarisPatchAnalyzer.cpp

            wstring patchId = it->first;
            // Get all the os's and architectures.
            wstring restrictions = L"SELECT type, value FROM restriction WHERE restriction.patchFK='";
            restrictions += patchId;
            restrictions += L"'"; //single quote

            vector<wstring> pkgArchs;
            pkgArchs.clear();

            vector<wstring> prodNames;
            prodNames.clear();

            QSqlQuery restrQuery = m_dbManager->exec(restrictions);
            
            if (restrQuery.isActive())
            {
                int numRecords = restrQuery.numRowsAffected();
                bool b = restrQuery.isSelect();
                b = restrQuery.first();
                while (b)
                {
                    wstring type = qs2ws(restrQuery.value(0).toString());
                    wstring value = qs2ws(restrQuery.value(1).toString());

                    if (type == L"os")
=====================================================================
Found a 22 line (126 tokens) duplication in the following files: 
Starting at line 42 of D:\home\eCora_PM\PM\pmPushUnixBaseImpl\Domain.h
Starting at line 37 of D:\home\eCora_PM\PM\pmPushWinBaseImpl\Domain.h

namespace pmPushWinBaseImpl {


class Domain : public pmPushBaseModel::IDomain
{
  
  public:

    Domain() : m_appIface(0) {}
    Domain(const wstring& name, IUnknown* app) : m_name(name), m_appIface(app) {}
    Domain::Domain(xml::Node* ss, pmPushBaseModel::IFactory& f, IUnknown* app);

    virtual ~Domain();


    wstring name() const { return m_name; }

    void setName(const wstring& name) { m_name = name; }

    int numComputers() { return m_computers.size(); }
    void addComputer(const pmPushBaseModel::PatchInfo& info, pmPushBaseModel::IFactory& factory);
    void accept(pmPushBaseModel::Visitor& v);
=====================================================================
Found a 18 line (126 tokens) duplication in the following files: 
Starting at line 164 of D:\home\eCora_PM\PM\network\PtyConnection.cpp
Starting at line 458 of D:\home\eCora_PM\PM\unix-collector\UnixConnection.cc

    possible.push_back(pair<bstring, int>(">", PROMPT));

    // Potential Questions...
    possible.push_back(pair<bstring, int>("(yes/no)?", QUESTION));
    possible.push_back(pair<bstring, int>("(y/n)?", QUESTION));
    possible.push_back(pair<bstring, int>("? (y/n)", QUESTION));
    possible.push_back(pair<bstring, int>("? (yes/no)", QUESTION));
    possible.push_back(pair<bstring, int>("Store key in cache? (y/n)",
					  QUESTION));
    possible.push_back(pair<bstring, int>("ontinue connecting",
                       QUESTION));

    possible.push_back(pair<bstring, int>("FATAL ERROR", FAILURE));
	    
    //  Every 10 seconds check to see if someone has hit the stop button
    //  and return if they have.  Allow up to a total of 100 seconds to 
    //  get the proper response back from the remote system.  
    m_host->setTimeout(QUICK_TIMEOUT);
=====================================================================
Found a 52 line (126 tokens) duplication in the following files: 
Starting at line 40 of D:\home\eCora_PM\PM\network\FileTransferConnection.h
Starting at line 40 of D:\home\eCora_PM\PM\network\network\FileTransferConnection.h

using namespace smuggle;

namespace network {
  
class smuggle::Smuggler;
class smuggle::UnixDriver;

/*
 * Base class used as a file transfer connection to a remote machine.
 */
class FileTransferConnection : public PtyConnection
{    
  public:
    FileTransferConnection();
    virtual ~FileTransferConnection();

    /*
     * Each type needs to implement a connection method.  In some cases,
     * such as scp, no connection is actually made.  In these cases
     * simply return.
     */
    virtual void connect(const LoginParameters*const) = 0;

    /*
     * Move the localFile to the remote machine.
     * @param path to the local file.
     * @param path to the remote file...
     */
    virtual void put(const wstring& localFilename,
		     const wstring& remotePath) = 0;
    
    /*
     * Get the file from the remote machine and store locally.
     * @param path to the file on the remote machine.
     * @param path to where you want to store the file on the local
     * machine.
     */
    virtual void get(const wstring& remoteFilename,
		     const wstring& localPath) = 0;


    wstring returnFilename(const wstring& pathAndFile);
  protected:
    bstring waitForTransfer(
        const vector<bstring>const successMessages,
	const vector<bstring>const errorMessages);
    
};

FileTransferConnection* makeFileTransferConnection(const LoginParameters*const device);

} //  End namespace connections
=====================================================================
Found a 14 line (126 tokens) duplication in the following files: 
Starting at line 69 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp
Starting at line 76 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp

        CustomFileDef* cf = patch->m_files[i];
        int num = m_tableFile->numRows();
        m_tableFile->setNumRows(num + 1);
        m_tableFile->setItem(num, 0,
            new ESTableItem(m_tableFile, QTableItem::Never, cf->m_path));
        m_tableFile->setItem(num, 1,
            new ESTableItem(m_tableFile, QTableItem::Never, cf->m_version));
        m_tableFile->setItem(num, 2,
            new ESTableItem(m_tableFile, QTableItem::Never, cf->m_checksum));

        CustomFileDef* cf1 = new CustomFileDef();
        cf1->m_path = cf->m_path;
        cf1->m_version = cf->m_version;
        cf1->m_checksum = cf->m_checksum;
=====================================================================
Found a 20 line (125 tokens) duplication in the following files: 
Starting at line 857 of D:\home\eCora_PM\PM\software-license\SoftwareLicenseV1.cc
Starting at line 884 of D:\home\eCora_PM\PM\software-license\SoftwareLicenseV1.cc

SoftwareLicense::startDate(
    const wstring& category,
    const wstring& feature)
{
    // Identical for time- and transaction-based subscriptions
    time_t curTime = time(NULL);
    vector<Subscription*>::const_iterator it1;
    for (it1 = m_subscriptions.begin(); it1 != m_subscriptions.end(); it1++)
    {
        Subscription* sub = *it1;
        vector<CategorySubscription*>::iterator it2;
        for (it2 = sub->m_categorySubscriptions.begin();
             it2 != sub->m_categorySubscriptions.end(); it2++)
        {
            CategorySubscription* csub = *it2;
            if (csub->validAtDate(curTime) &&
                csub->m_feature == feature &&
                csub->m_category == category)
            {
                return csub->m_startDate;
=====================================================================
Found a 51 line (125 tokens) duplication in the following files: 
Starting at line 21 of D:\home\eCora_PM\PM\print\Bold.cc
Starting at line 19 of D:\home\eCora_PM\PM\print\Column.cc
Starting at line 19 of D:\home\eCora_PM\PM\print\Fixed.cc
Starting at line 19 of D:\home\eCora_PM\PM\print\Italic.cc
Starting at line 19 of D:\home\eCora_PM\PM\print\Item.cc
Starting at line 19 of D:\home\eCora_PM\PM\print\Underline.cc
Starting at line 19 of D:\home\eCora_PM\PM\print\Verbatim.cc

namespace print {


#define MANIPULATOR(type)\
const Verbatim \
verbatim(type x)\
{\
    wchar_t buf[64];\
    return Verbatim(g_converter.convert(buf, x));\
}

MANIPULATOR(const wstring&);
MANIPULATOR(wchar_t);
MANIPULATOR(char);
MANIPULATOR(signed char);
MANIPULATOR(unsigned char);
MANIPULATOR(const wchar_t*);
MANIPULATOR(const void*);
MANIPULATOR(int);
MANIPULATOR(unsigned int);
MANIPULATOR(long);
MANIPULATOR(unsigned long);
MANIPULATOR(longlong);
MANIPULATOR(ulonglong);
MANIPULATOR(short);
MANIPULATOR(bool);
MANIPULATOR(float);
MANIPULATOR(double);
MANIPULATOR(long double);

#undef MANIPULATOR


#define MANIPULATOR(type)\
const Verbatim \
verbatim(const type x)\
{\
    wchar_t* buf = new wchar_t[strlen(reinterpret_cast<const char*>(x)) + 1];\
    Verbatim v(g_converter.convert(buf, x));\
    delete[] buf;\
    return v;\
}

MANIPULATOR(char*);
MANIPULATOR(signed char*);
MANIPULATOR(unsigned char*);

#undef MANIPULATOR


} // namespace print
=====================================================================
Found a 23 line (125 tokens) duplication in the following files: 
Starting at line 865 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp
Starting at line 898 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::loadGroupSystems");
    // internal database
    CComQIPtr<com::IAppDatabase> pAppDatabase(g_App->services());
    _IfNullPtrRet(pAppDatabase);

    // systems container
    CComPtr<com::IDbContainer> pDbContainer;
    HRESULT hr = pAppDatabase->getDbContainer(&pDbContainer);
    _IfFailHrRet(hr);

    // load systems
    if (!groupsNode.isNull())
    {
        // register container for groups
        hr = pDbContainer->registerObjectType((IUnknown*)&idb::GroupObject());
        _IfFailHrRet(hr);

        QDomElement element = groupsNode.firstChild().toElement();
        while (!element.isNull())
        {
            QString qsKey = element.attributeNode(GroupID).value();
            if (qsKey.length())
            {
=====================================================================
Found a 29 line (125 tokens) duplication in the following files: 
Starting at line 1544 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 1487 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::getIncompleteUnloadedScanIds");

    vector<wstring> wsIncompleteUnloadedScanIds;
    
    if (wsPurgerSysScanIds.empty())
    {
        wsIncompleteUnloadedScanIds = wsArchiverSysScanIds;
    }
    else
    {
        vector<wstring>::iterator itArScanIds = wsArchiverSysScanIds.begin();
        for (; itArScanIds != wsArchiverSysScanIds.end(); itArScanIds++)
        {
            vector<wstring>::iterator itPurScanIds = wsPurgerSysScanIds.begin();
            for (; itPurScanIds != wsPurgerSysScanIds.end(); itPurScanIds++)
            {
                if (*itArScanIds == *itPurScanIds)
                {
                    break;
                }
            }
            if (itPurScanIds == wsPurgerSysScanIds.end())
            {
                wsIncompleteUnloadedScanIds.push_back(*itArScanIds);
            }
        }
    }

    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::getIncompleteUnloadedScanIds, exiting");
=====================================================================
Found a 23 line (125 tokens) duplication in the following files: 
Starting at line 977 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 1010 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp

    log(L"patchManager", Log::Debug, L"ArchivingDlg::loadGroupSystems");
    // internal database
    CComQIPtr<com::IAppDatabase> pAppDatabase(g_App->services());
    _IfNullPtrRet(pAppDatabase);

    // systems container
    CComPtr<com::IDbContainer> pDbContainer;
    HRESULT hr = pAppDatabase->getDbContainer(&pDbContainer);
    _IfFailHrRet(hr);

    // load systems
    if (!groupsNode.isNull())
    {
        // register container for groups
        hr = pDbContainer->registerObjectType((IUnknown*)&idb::GroupObject());
        _IfFailHrRet(hr);

        QDomElement element = groupsNode.firstChild().toElement();
        while (!element.isNull())
        {
            QString qsKey = element.attributeNode(GroupID).value();
            if (qsKey.length())
            {
=====================================================================
Found a 31 line (125 tokens) duplication in the following files: 
Starting at line 1421 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 1983 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp

            return;
        }

        // qt322 returns all slashes as '/'
        // WNetGetUnversalName doesn't like this so convert them to '\\'
        path = convertSlashes(path);
        log(L"patchRepository", Log::Debug, L"user selected path " << path);

        // this will convert mapped drives to UNC format
        DWORD len = 2048;
        WCHAR buff[2048];
        UNIVERSAL_NAME_INFO* info = (UNIVERSAL_NAME_INFO*)&buff;
        DWORD result;
        if ((result = WNetGetUniversalName((LPWSTR)path.c_str(), UNIVERSAL_NAME_INFO_LEVEL, &info, &len)) == NO_ERROR)
        {
            path = buff;
            log(L"patchRepository", Log::Debug, L"Path was mapped drive " << path);
        }

        // if we still have a local path, try to see if any sub-directories are shared
        // and convert to UNC format
        if (isLocalPath(path))
        {
            path = determineUNCPath(path);
            log(L"patchRepository", Log::Debug, L"Path was local " << path);
        }

        // if we still have a local path, show error message
        // FIXME in future should allow repository to be local, but then must make sure
        // that push cannot use the "execute directly from repository" option
        if (isLocalPath(path))
=====================================================================
Found a 34 line (124 tokens) duplication in the following files: 
Starting at line 1220 of D:\home\eCora_PM\PM\sql\dsn.cpp
Starting at line 1363 of D:\home\eCora_PM\PM\sql\dsn.cpp

	qtSettings.winAuth = 1;

	valid = isDsnValid(currentDsn);
	if (valid)
	{
	    qtSettings.source = currentDsn;
	    qtSettings.userName = login();
	    qtSettings.password = password();

	    // this gets the rest of the settings out of the DSN like server,
	    // database...
	    try {
		createOrVerify(currentDsn, qtSettings, true, true);
		created = true;
	    }
	    catch (GenericException&) {}
	}
	else if (currentDsn != m_defaultDSN)
	{
	    if (isDsnValid(m_defaultDSN))
	    {
		qtSettings.source = m_defaultDSN;
		qtSettings.userName = login();
		qtSettings.password = password();

		// this gets the rest of the settings out of the DSN like server,
		// database...
		try {
		    createOrVerify(m_defaultDSN, qtSettings, true);
		    created = true;
		}
		catch (GenericException&) {}
	    }
	}
=====================================================================
Found a 22 line (124 tokens) duplication in the following files: 
Starting at line 104 of D:\home\eCora_PM\PM\pmServices\Threads.h
Starting at line 171 of D:\home\eCora_PM\PM\pmServices\Threads.h

            ::LeaveCriticalSection(&mtx_);
        }
    };

    typedef volatile Host VolatileType;

    typedef LONG IntType; 

    static IntType AtomicIncrement(volatile IntType& lval)
    { return InterlockedIncrement(&const_cast<IntType&>(lval)); }
    
    static IntType AtomicDivide(volatile IntType& lval)
    { return InterlockedDecrement(&const_cast<IntType&>(lval)); }
    
    static void AtomicAssign(volatile IntType& lval, IntType val)
    { InterlockedExchange(&const_cast<IntType&>(lval), val); }
    
    static void AtomicAssign(IntType& lval, volatile IntType& val)
    { InterlockedExchange(&lval, val); }
};
    
template <class Host>
=====================================================================
Found a 28 line (124 tokens) duplication in the following files: 
Starting at line 25 of D:\home\eCora_PM\PM\pmPushUnixBaseImpl\Domain.cpp
Starting at line 28 of D:\home\eCora_PM\PM\pmPushWinBaseImpl\Domain.cpp

using namespace pmPushWinBaseImpl;
const wstring Domain::TagName = L"Domain";
const wstring Domain::SubTagName = L"Computers";


/////////////////////////////////////////////////////////////////////


Domain::Domain(xml::Node* ss, pmPushBaseModel::IFactory& f, IUnknown* app) :
    m_appIface(app)
{   
    wstring tagName = ss->name();

    m_name = ss->attribute(L"m_name");
   //     xml::Node::iterator it;
    xml::Node::iterator it;
    xml::Node* child;

    for (it = ss->begin(); it != ss->end(); ++it)
    {
        child = dynamic_cast<xml::Node*>(*it);
        
        if (!child)
        {
            //FIXME error
            break;
        }
        m_computers.push_back(new WinComputer(child, f, app));
=====================================================================
Found a 31 line (124 tokens) duplication in the following files: 
Starting at line 351 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h
Starting at line 816 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h
Starting at line 1038 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h
Starting at line 1083 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h

    void testSetFileModifiedTime()
    {
        /**
        scenario:
        1. add file to storage
        2. check if it exists
        3. get modification time
        4. change modification time (i.e. increase it)
        5. get modification time and check it
        6. remove file
        */
        TS_ASSERT_THROWS_NOTHING(load());
        WindowsStorage storage(m_resources[WindowsStoragePath], g_App->services());

        // make sure environment set up for test
        try
        {
            storage.connect();
            if (!storage.exists())
                storage.create();
            //fs->file2utf8string(fileName, data);
        }
        catch (GenericException&)
        {
            TS_FAIL("Couldn't set up environment for test.");
        }
        fs::FileSystem* fs = g_App->appServices()->disk()->systemHome();
        wstring fileName = L"testsettings.xml";
        wstring fullName = fs->fullPath (fileName);
        TS_ASSERT_THROWS_NOTHING(storage.addFile (fullName, fileName, 0, 0));
        TS_ASSERT_EQUALS(storage.fileExists (fileName), true);
=====================================================================
Found a 18 line (124 tokens) duplication in the following files: 
Starting at line 426 of D:\home\eCora_PM\PM\customPatch\CustomPatchMainDlg.cpp
Starting at line 725 of D:\home\eCora_PM\PM\customPatch\CustomPatchMainDlg.cpp

            return;
        }

        if (!addPatchFilesToRepo(app, &dlg))
        {
            CustomPatch* patch = dlg.m_newPatch;
            for (int i = 0; i < patch->m_commands.size(); i++)
            {
                if (!patch->m_commands[i]->m_isExecutable &&
                    patch->m_commands[i]->m_unc != tr("(repository)") &&
                    patch->m_commands[i]->m_unc != "")
                {
                    delete patch->m_commands[i];
                    patch->m_commands.erase(patch->m_commands.begin() + i);
                    i--;
                }
            }
            if (db.EditPatch(patch) == -1)
=====================================================================
Found a 23 line (123 tokens) duplication in the following files: 
Starting at line 1038 of D:\home\eCora_PM\PM\scanScheduling\TaskManager.cpp
Starting at line 1089 of D:\home\eCora_PM\PM\scanScheduling\TaskManager.cpp

    log(L"TaskManager", Log::Debug, L">> loadGroups");
    // internal database
    CComQIPtr<com::IAppDatabase> pAppDatabase(appServices());
    _IfNullPtrRet(pAppDatabase);

    // systems container
    CComPtr<com::IDbContainer> pDbContainer;
    HRESULT hr = pAppDatabase->getDbContainer(&pDbContainer);
    _IfFailHrRet(hr);

    // load systems
    if (!groupsNode.isNull())
    {
        // register container for groups
        hr = pDbContainer->registerObjectType((IUnknown*)&idb::GroupObject());
        _IfFailHrRet(hr);

        QDomElement element = groupsNode.firstChild().toElement();
        while (!element.isNull())
        {
            QString qsKey = element.attributeNode(GroupID).value();
            if (qsKey.length())
            {
=====================================================================
Found a 28 line (123 tokens) duplication in the following files: 
Starting at line 615 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\Solaris2Xml.cc
Starting at line 746 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\Solaris2Xml.cc

        v = m_packages[wstmp];
    }

    bool bMatchFound = false;

    vector<PatchId*>::iterator it;
    // Now add the entry if it doesn't exist...
    for (it = v->begin(); it != v->end(); ++it)
    {
        PatchId* pid = static_cast<PatchId*>(*it);
        if ((pid) && (pid->s_id == patchID) && (pid->s_ver == ver))
        {
            bMatchFound = true;
            break;
        }
    }

    if (!bMatchFound)
    {
        PatchId* pid = new PatchId;
        pid->s_id = patchID;
        pid->s_ver = ver;
        v->push_back(pid);
    }
}

void
CSolaris2Xml::createPackageRecords()
=====================================================================
Found a 18 line (123 tokens) duplication in the following files: 
Starting at line 582 of D:\home\eCora_PM\PM\pmDaoDbImpl\DaoDbImplUnitTest.h
Starting at line 748 of D:\home\eCora_PM\PM\pmDaoDbImpl\DaoDbImplUnitTest.h

            iSystem->loadRelatedEntities();

            pmDaoInterfaces::IWindowsSystemExtension* iWindowsSystemExtension = iSystem->getWindowsSystemExtension();

            TS_ASSERT(iWindowsSystemExtension->first());

            TS_ASSERT(iWindowsSystemExtension->getDomain() == L"BSP");
            TS_ASSERT(iWindowsSystemExtension->getWinDir() == L"C:\\WINNT40");
            TS_ASSERT(iWindowsSystemExtension->getSqlDir() == L"C:\\Program Files\\Microsoft SQL Server\\MSSQL");
            TS_ASSERT(iWindowsSystemExtension->getSqlSharedCodeDir() ==
                L"C:\\Program Files\\Microsoft SQL Server\\80\\COM\\");
            TS_ASSERT(iWindowsSystemExtension->getExchangeDir() == L"C:\\Program Files\\Exchange 2000\\");
            TS_ASSERT(iWindowsSystemExtension->getProgramFilesDir() == L"C:\\Program Files");
            TS_ASSERT(iWindowsSystemExtension->getCommonFilesDir() == L"C:\\Program Files\\Common Files");

            TS_ASSERT(!iWindowsSystemExtension->next());

            pmDaoInterfaces::IActivity* iActivity = iSystem->getActivities();
=====================================================================
Found a 25 line (123 tokens) duplication in the following files: 
Starting at line 237 of D:\home\eCora_PM\PM\patchRepository\RepositoryManagerFilterSol.cpp
Starting at line 452 of D:\home\eCora_PM\PM\patchRepository\RepositoryManagerFilterWin.cpp

        RepositoryManagerGui::RepositoryManagerFilterOSWinRegName));
    QString qsCurr = "";
    m_lvOS->clearSelection();
    int pos = 0;
    int len = qsRegStr.length();
    while (0 < qsRegStr.length())
    {
        if (-1 != (pos = qsRegStr.find('|')))
        {
            qsCurr = qsRegStr.left(pos);
            qsRegStr = qsRegStr.right(qsRegStr.length() - (pos + 1));
        }
        else
        {
            qsCurr = qsRegStr;
            qsRegStr = "";
        }
        m_lvOS->setSelected(m_lvOS->findItem(qsCurr, 0, Qt::ExactMatch), true);
    }

    // reset controls:
    onOffFilter();
}

void RepositoryManagerFilterWin::saveSettings()
=====================================================================
Found a 18 line (123 tokens) duplication in the following files: 
Starting at line 3098 of D:\home\eCora_PM\PM\patchManager\App.cpp
Starting at line 883 of D:\home\eCora_PM\PM\patchManager\PatchMeisterLicense.cc

    idb::UnixDevice udev(g_App->services());
    hr = pDbContainer->retrieveObject(ws2qs(pk), (IUnknown*)&udev);
    if (SUCCEEDED(hr))
    {

        QString qsValue = "";
        hr = ((com::IDbObject*)&udev)->getFieldValue(idb::UnixDevice::Domain, qsValue);
        domain = qs2ws(qsValue);
        if (domain.size())
            domain += L"\\";
        qsValue = "";
        hr = ((com::IDbObject*)&udev)->getFieldValue(idb::UnixDevice::DeviceName, qsValue);
        system = qs2ws(qsValue);
        return true;
    }

    return false;
}
=====================================================================
Found a 18 line (123 tokens) duplication in the following files: 
Starting at line 45 of D:\home\eCora_PM\PM\hostManager\WinAgentRemediSettings.cpp
Starting at line 47 of D:\home\eCora_PM\PM\hostManager\WinNonAgentRemediSettings.cpp

    m_tips.setHelp(m_skipTasksFalseRadio, L"retry tasks");
    m_tips.setHelp(m_freeSpaceSpin, L"disk space");
    m_tips.setHelp(m_timeoutSpin, L"timeout");
    m_tips.setHelp(m_leAltRepoSelected, L"alt path");
    m_tips.setHelp(m_useQChainCheck, L"QChain");
    m_tips.setHelp(m_allowRebootCheck, L"reboot");
    m_tips.setHelp(m_forceAppsClosedCheck, L"forceclose");
    m_tips.setHelp(m_noDelayOrCancelRadio, L"neither");
    m_tips.setHelp(m_delayOnlyRadio, L"delay");
    m_tips.setHelp(m_delayAndCancelRadio, L"delayandcancel");
    m_tips.setHelp(m_interventionSpin, L"delay intervention");
    //end of Yakovenko

    // StUV Alt BEGIN:
    m_tips.setHelp(m_cbAltRepoUse, L"Use Alt Repo");
    m_tips.setHelp(m_leAltRepoSelected, L"Selected Alt Repo");
    m_tips.setHelp(m_lvAltRepositories, L"Defined Alt Repo");
    m_tips.setHelp(m_interventionSpin, L"UI Delay");
=====================================================================
Found a 11 line (123 tokens) duplication in the following files: 
Starting at line 590 of D:\home\eCora_PM\PM\ecoraStyle\EcoraStyle.cpp
Starting at line 1029 of D:\home\eCora_PM\PM\ecoraStyle\EcoraStyle.cpp

            p->setPen(bottom);
            p->drawLine(outerR.bottomLeft(), outerR.bottomRight());
            p->drawLine(outerR.bottomRight(), outerR.topRight());

            p->setPen(top);
            p->drawLine(outerR.topLeft(), outerR.topRight());
            p->drawLine(outerR.topLeft(), outerR.bottomLeft());

            p->setPen(inner);
            p->drawLine(innerR.topLeft(), innerR.topRight());
            p->drawLine(innerR.topLeft(), innerR.bottomLeft());
=====================================================================
Found a 20 line (123 tokens) duplication in the following files: 
Starting at line 123 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\RepositoryChanger.cpp
Starting at line 265 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\RepositoryChanger.cpp

    ACE_DEBUG ((LM_DEBUG, ECORA_TEXT("RepositoryChanger::registerSharedFiles().\n")));

    typedef InsTable::ColumnCont ColumnCont;
    typedef ColumnCont::size_type size_type;
    typedef InsTable::RowCont RowCont;
    typedef RowCont::const_iterator rcit;

    const boost::shared_ptr<AgentInstallerContext> pctx =
        boost::static_pointer_cast<AgentInstallerContext>(m_context);

    // Allow local copy for pdb will valid.
    const InstallDB& db = *(pctx->m_db);
    InstallDB& rep = *(pctx->m_prep);
    const InsTable& ftbl = db.getTable(EI::FILES_TABLE);
    InsTable& rep_ftbl = rep[EI::REP_SHARED_FILES_TABLE];

    InsFilter filter(ftbl.getColumns());
    filter[EI::SHARED_FILE_ATTR] = InsEValueFilter(ECORA_TEXT("1"));

    CRowComp comparer(ftbl.getColumns(), rep_ftbl.getColumns());
=====================================================================
Found a 27 line (123 tokens) duplication in the following files: 
Starting at line 901 of D:\home\eCora_PM\PM\agent\afCommon\WbemHelper.cpp
Starting at line 967 of D:\home\eCora_PM\PM\agent\afCommon\WbemHelper.cpp
Starting at line 1059 of D:\home\eCora_PM\PM\agent\afCommon\WbemHelper.cpp

    TRACE(_T("GetServiceState"));

	HRESULT hr = S_OK;

    if (!connectionEstablished())
    {
        TRACE(_T("Failed: connectionEstablished()"));
        return E_FAIL;
    }
    
    TCHAR szObject[_MAX_PATH + 1]  = { 0 };
    _sntprintf(szObject, _MAX_PATH, _T("Win32_Service.Name=\"%s\""), lpszServiceName);

    CComPtr<IWbemClassObject> pClassObj = NULL;
    CComBSTR bstrObjectPath(szObject);

    hr = m_pIWbemServices->GetObject(bstrObjectPath, WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClassObj, NULL);
    if (WBEM_S_NO_ERROR != hr)
    {
        TRACE(_T("Failed: pIWbemServices->GetObject, hr: %d"), hr);
        return hr;
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        CComVariant varVal;
        hr = pClassObj->Get(L"State", 0, &varVal, 0, 0);
=====================================================================
Found a 20 line (122 tokens) duplication in the following files: 
Starting at line 393 of D:\home\eCora_PM\PM\print\Format.h
Starting at line 149 of D:\home\eCora_PM\PM\print\HTML.h

    virtual ecwofstream& image(const Image& image);
    virtual ecwofstream& table(const Table& table);
    virtual ecwofstream& row();
    virtual ecwofstream& column();
    virtual ecwofstream& end_column();
    virtual ecwofstream& end_row();
    virtual ecwofstream& end_table();
    virtual ecwofstream& blist();
    virtual ecwofstream& item();
    virtual ecwofstream& end_item();
    virtual ecwofstream& end_blist();
    // End Bug #2383

    virtual void chapter(const Chapter& chapter);
    virtual void section(const Section& section);
    virtual void subsection(const SubSection& subsection);
    virtual void subsubsection(const SubSubSection& subsubsection);

    virtual void unnumbered_chapter(
	const UnnumberedChapter& unnumberedChapter);
=====================================================================
Found a 17 line (122 tokens) duplication in the following files: 
Starting at line 1084 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 1145 of D:\home\eCora_PM\PM\scanScheduling\TaskManager.cpp

    QDomElement systemsNode = root.ownerDocument().createElement(SelectedSystems);
    root.appendChild(systemsNode);

    QDictIterator<com::IDbObject> itrSystem(systems);
    while (itrSystem.current())
    {
        QString qsKey = itrSystem.currentKey();
        QString qsClass = itrSystem.current()->getObjectType();
        if (qsKey.length() && qsClass.length())
        {
            QDomElement element = root.ownerDocument().createElement(SystemTagName);
            element.setAttribute(SystemID, qsKey);
            element.setAttribute(SystemClass, qsClass);
            systemsNode.appendChild(element);
        }
        ++itrSystem;
    }
=====================================================================
Found a 31 line (122 tokens) duplication in the following files: 
Starting at line 1694 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 195 of D:\home\eCora_PM\PM\patchRepository\RepositorySettingsQT.cpp

void RepositorySettingsQT::init()
{
    bool originalWindowsSettings = (m_originalWindowsSettings != 0);
    bool originalUnixSettings = (m_originalUnixSettings != 0);

    if (m_originalWindowsSettings)
    {
        delete m_originalWindowsSettings;
        m_originalWindowsSettings = 0;
    }
    if (m_originalUnixSettings)
    {
        delete m_originalUnixSettings;
        m_originalUnixSettings = 0;
    }

    vector<RepositorySettings*> repositories;
    try
    {
        RepositoryQuery rq(m_services);
        repositories = rq.select();
    }
    catch (GenericException& e)
    {
        log (L"patchRepository", Log::Error, L"Warning: No data source specified: "
            << e.userMessage());
    }

    // FIXME only allow two repositories for now (one for windows, one for unix)
    WindowsRepositorySettings* windowsSettings = 0;
    for (int i = 0; i < repositories.size(); ++i)
=====================================================================
Found a 27 line (122 tokens) duplication in the following files: 
Starting at line 395 of D:\home\eCora_PM\PM\importExport\ScanResults.cpp
Starting at line 1847 of D:\home\eCora_PM\PM\importExport\ScanResults.cpp

                (IUnknown*)&idb::UnixDevice(m_scanResults->m_services));
            if (FAILED(hr))
            {
                log(L"ScanResults", Log::Error, L"Could not get register object");
                return;
            }

            hr = pDbContainer->addObject((IUnknown*)&(unixDevice));
            if (FAILED(hr))
            {
                log(L"ScanResults", Log::Error, L"Could not add object");
                return;
            }

            hr = pRelation->setRelation(&defaultGroup, (IUnknown*)&(unixDevice));
            if (FAILED(hr))
            {
                log(L"ScanResults", Log::Error, L"Could not get set relation");
                return;
            }
        }
        else
        {
            log(L"ScanResults", Log::Error, L"No services!");
        }
    }
}
=====================================================================
Found a 13 line (122 tokens) duplication in the following files: 
Starting at line 627 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\JobReq.cpp
Starting at line 648 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\JobReq.cpp

                dir_path = item.path().c_str();
                std::replace(dir_path.begin(), dir_path.end(), ACE_TEXT('\\'), ACE_TEXT('/'));
                while (dir_path.size() > 2 && dir_path[0] == ECORA_TCHAR('/'))
                {
                    dir_path = dir_path.substr(1, dir_path.size());
                }
                pos = dir_path.find_last_of(ACE_TEXT('/'));
                if (tstring::npos != pos)
                {
                    dir_path = dir_path.substr(0, pos);
                    split_path(dir_path, list);
                    make_dir_list(workdir().c_str(), list);
                }
=====================================================================
Found a 26 line (122 tokens) duplication in the following files: 
Starting at line 590 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketClient.cpp
Starting at line 585 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketServer.cpp

CSocketServer::WorkerThread::Read(Socket *pSocket, CIOBuffer *pBuffer) const
{
    DWORD dwFlags = 0;
    DWORD dwNumBytes = 0;

    pBuffer->SetUserData(IO_Read_Completed);
    pBuffer->SetupRead();

    if (SOCKET_ERROR == ::WSARecv(pSocket->m_socket, pBuffer->GetWSABUF(), 1, &dwNumBytes, &dwFlags, pBuffer, NULL))
    {
        DWORD lastError = ::WSAGetLastError();
        if (ERROR_IO_PENDING != lastError)
        {
            //Output(_T("CSocketServer::Read() - WSARecv: ") + GetLastErrorMessage(lastError));
            if (lastError == WSAECONNABORTED || lastError == WSAECONNRESET || lastError == WSAEDISCON)
            {
                pSocket->Close();
            }

            pSocket->Release();
            pBuffer->Release();
        }
    }
}

void 
=====================================================================
Found a 16 line (121 tokens) duplication in the following files: 
Starting at line 826 of D:\home\eCora_PM\PM\zlib\deflate.c
Starting at line 898 of D:\home\eCora_PM\PM\zlib\deflate.c

    scan += 2, match += 2;
    Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
    } while (*++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     scan < strend);

    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (int)(strend - scan);
=====================================================================
Found a 18 line (121 tokens) duplication in the following files: 
Starting at line 979 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\Idb.cc
Starting at line 1064 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\Idb.cc

    list<Attribute*> attributes;
    attributes.clear();

    vector<wstring>::iterator valIt = attrValues.begin();
    for (vector<wstring>::iterator nameIt = attrNames.begin();
		nameIt != attrNames.end(); ++nameIt)
    {
        Attribute* ptr = new Attribute(static_cast<wstring>(*nameIt), 
                                static_cast<wstring>(*valIt), false);
        attributes.push_back(ptr);
        ++valIt;
	}

	list<Object*> objects;
    // clear it 
	objects.clear();
	
	IdbRecord* ptr = new IdbRecord(name, attributes, objects);
=====================================================================
Found a 29 line (121 tokens) duplication in the following files: 
Starting at line 357 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\UnixComputer.cpp
Starting at line 410 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\UnixComputer.cpp

    actSeq->push_back(DisconnectAction::representation(id++, primaryKey()));


    try
    {

#ifdef _DEBUG
        wstring dumpFileName =  L"pushactions.xml";

        wofstream dumpFile;
        dumpFile.open(ws2utf8s(dumpFileName).c_str(), (ios::in | ios::out | ios::trunc));

        if (dumpFile.is_open())
            actionSeqDoc.write(dumpFile);
#endif
        actionsInterpreter()->loadActionSequence(actionSeqDoc);
    }
    catch (GenericException& e)
    {
        wstring message = L"Failed to create push actions: " + e.message();
        setStatus(pmPushBaseModel::IComputer::PushFailure, message);
        return 0;
    }

    return id; // the number of push actions
}

unsigned long
UnixComputer::prepareForPushDefault()
=====================================================================
Found a 32 line (121 tokens) duplication in the following files: 
Starting at line 221 of D:\home\eCora_PM\PM\pmAgentManagement\OptionalAgentDeployWizard.cpp
Starting at line 112 of D:\home\eCora_PM\PM\pmAgentManagement\OptionalAgentUninstallWizard.cpp

OptionalAgentUninstallWizard::~OptionalAgentUninstallWizard()
{
    //m_db->Release();
    m_app->Release();
    vector<ListViewItemData*>::iterator it = m_lvData.begin();
    for (; it != m_lvData.begin(); ++it)
    {
        ListViewItemData* tmp = *it;
        delete tmp;
    }

    map<wstring, ScanSettings*>::iterator ii = m_scanSettings.begin();
    for (; ii != m_scanSettings.end(); ++ii)
    {
        ScanSettings* ss = reinterpret_cast<ScanSettings*>(ii->second);
        delete ss;
    }

    if (m_adClient)
    {
        delete m_adClient;
    }

    if (m_agentManager)
    {
        delete m_agentManager;
    }

}

// BUG FIX #16891 by Yuri Kovalenko ->
void
=====================================================================
Found a 21 line (121 tokens) duplication in the following files: 
Starting at line 200 of D:\home\eCora_PM\PM\patchRepository\RepositoryManagerFilterSol.cpp
Starting at line 339 of D:\home\eCora_PM\PM\patchRepository\RepositoryManagerFilterWin.cpp

    }

    // Load languages selection:
    typedef map<QString, unsigned short int>::const_iterator MapCI;
    for (MapCI mci = m_langSettings.begin(); mci != m_langSettings.end(); ++mci)
    {
        if (m_bsFilterSettingsMap["lang"].test(mci->second))
        {
            m_lvLang->setSelected(
                m_lvLang->findItem(QObject::tr(mci->first), 0, Qt::ExactMatch), true);
        }
        else
        {
            m_lvLang->setSelected(
                m_lvLang->findItem(QObject::tr(mci->first), 0, Qt::ExactMatch), false);
        }
    }

    // Load OS's & Applications:
    if (!m_lvOS->childCount())
    {
=====================================================================
Found a 23 line (121 tokens) duplication in the following files: 
Starting at line 693 of D:\home\eCora_PM\PM\patchManager\ScanInfoManager.cpp
Starting at line 745 of D:\home\eCora_PM\PM\patchManager\ScanInfoManager.cpp

            tabScan->m_patchMap.insert(std::make_pair(patchId, pk));        
            // BUG FIX #26575 by Yug ->
            if (systemType == pmUI::SystemInfo::WinSystemClass)
            {
                if (spName.empty()) // winpatch
                {
                    WinPatchInfo* winPatch = new WinPatchInfo;
                    winPatch->setScanId(uint2ws(l_ScanId));
                    winPatch->setSqNumber(pk.patchSqNumber);
                    winPatch->setPatchId(oldPatchId);
                    winPatch->setIsCustom(bIsCustom);
                    patchContainer.addItem(winPatch);
                }
                else // service pack
                {
                    ServicePackInfo* sp = new ServicePackInfo;
                    sp->setScanId(scanId);
                    sp->setSpId(oldPatchId);
                    sp->setServicePackName(pk.patchName);
                    sp->setIsCustom(bIsCustom);
                    spContainer.addItem(sp);
                }
            }
=====================================================================
Found a 29 line (121 tokens) duplication in the following files: 
Starting at line 59 of D:\home\eCora_PM\PM\patchManager\PolicyTabControl.cpp
Starting at line 158 of D:\home\eCora_PM\PM\patchManager\PolicyTabControl.cpp

PolicyTabControl::slotmouseButtonPressed(int button, QListViewItem * item, const QPoint & pos, int c)
{
    try {
	// get the item
        MessageBaseListItem* ibase = static_cast<MessageBaseListItem*>(item);
	if (ibase == 0) return;

	// check the input
	int patchSelection = slotClickInputValid(ibase, c);

	if (patchSelection == pmUI::DisplayPatchStatus::INVALID_STATUS)
	    return;

	if (patchSelection & pmUI::DisplayPatchStatus::PUSH_STATUS_ICON_ON)
	{
	    // verify the constraints
	    // we could have for the same system 
	    // remediation for PUSH and ROLLBACK
	    // in this case we provide a error message
	    // we cannot propagate the selection
	    int result = ibase->verifyPropagation(patchSelection);

	    if (result != pmUI::PolicyPropagationConstraints::VALID_PROPAGATION)
	    {
		QMessageBox::critical(
		    g_App, 
		    QObject::tr("Error"), 
		    ws2qs(pmUI::PolicyPropagationConstraints::displayErrorMessage(
			  pmUI::PolicyPropagationConstraints::LEVEL_POLICY, result)), 
=====================================================================
Found a 11 line (121 tokens) duplication in the following files: 
Starting at line 477 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp
Starting at line 836 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp

        m_newPatch->m_regs.push_back(cr);
        m_tableReg->setItem(num, 0,
            new ESTableItem(m_tableReg, QTableItem::Never, cr->m_registryKey));
        m_tableReg->setItem(num, 1,
            new ESTableItem(m_tableReg, QTableItem::Never, m_info->m_regTypes[cr->m_regType]));
        m_tableReg->setItem(num, 2,
            new ESTableItem(m_tableReg, QTableItem::Never, cr->m_value));
        QString data = cr->m_data;
        data = data.replace('\n', ' ');
        m_tableReg->setItem(num, 3,
            new ESTableItem(m_tableReg, QTableItem::Never, data));
=====================================================================
Found a 28 line (121 tokens) duplication in the following files: 
Starting at line 616 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketClient.cpp
Starting at line 611 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketServer.cpp

CSocketServer::WorkerThread::Write(Socket *pSocket, CIOBuffer *pBuffer) const
{
    DWORD dwFlags = 0;
    DWORD dwSendNumBytes = 0;
            
    pBuffer->SetUserData(IO_Write_Completed);
    pBuffer->SetupWrite();

    if (SOCKET_ERROR == ::WSASend(pSocket->m_socket, pBuffer->GetWSABUF(), 1, &dwSendNumBytes, dwFlags, pBuffer, NULL))
    {
        DWORD lastError = ::WSAGetLastError();
        if (ERROR_IO_PENDING != lastError)
        {
            //Output(_T("CSocketServer::Write() - WSASend: ") + GetLastErrorMessage(lastError));

            if (lastError == WSAECONNABORTED || lastError == WSAECONNRESET || lastError == WSAEDISCON)
            {
                pSocket->Close();
            }

            pSocket->Release();
            pBuffer->Release();
        }
    }
}


void 
=====================================================================
Found a 38 line (120 tokens) duplication in the following files: 
Starting at line 189 of D:\home\eCora_PM\PM\zlib\Zipper.cpp
Starting at line 282 of D:\home\eCora_PM\PM\zlib\Zipper.cpp

					szFileName + (szFileName[0] == '\\' ? 1 : 0),
					&zfi, 
					NULL, 
					0,
					NULL,
					0, 
					NULL,
					Z_DEFLATED,
					Z_DEFAULT_COMPRESSION);

	if (nRet == ZIP_OK)
	{
		m_info.nFileCount++;

		// read the file and output to zip
		char pBuffer[BUFFERSIZE];
		DWORD dwBytesRead = 0, dwFileSize = 0;

		while (nRet == ZIP_OK && ::ReadFile(hInputFile, pBuffer, BUFFERSIZE, &dwBytesRead, NULL))
		{
			dwFileSize += dwBytesRead;

			if (dwBytesRead)
				nRet = zipWriteInFileInZip(m_uzFile, pBuffer, dwBytesRead);
			else
				break;
		}

		m_info.dwUncompressedSize += dwFileSize;
	}

	zipCloseFileInZip(m_uzFile);
	::CloseHandle(hInputFile);

	return (nRet == ZIP_OK);
}

bool CZipper::AddFolderToZip(const char* szFolderPath, bool bIgnoreFilePath)
=====================================================================
Found a 23 line (120 tokens) duplication in the following files: 
Starting at line 1145 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 1033 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

            L"cancelled, exiting");
        return false;
    }

    while (!selectionElem.firstChild().isNull())
    {
        selectionElem.removeChild(selectionElem.firstChild());
    }

    QDict<com::IDbObject> systems;
    systems.setAutoDelete(true);
    systemsSelected = selectionWnd.systems(systems);
    QDict<idb::GroupObject> groups;
    groups.setAutoDelete(true);
    groupsSelected = selectionWnd.groups(groups);

    if (systemsSelected)
        appendSystems(selectionElem, systems);

    if (groupsSelected)
        appendGroups(selectionElem, (QDict<com::IDbObject>&)groups);

    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::selectGroupsSystems, exiting");
=====================================================================
Found a 24 line (120 tokens) duplication in the following files: 
Starting at line 488 of D:\home\eCora_PM\PM\patchRepository\RepositoryUnitTest.h
Starting at line 119 of D:\home\eCora_PM\PM\pmServices\Resources.cc

        m_resources[Resources::UpdateProductName] = L"patchpro4";

    }
    catch (xml::Error& e)
    {
        QString message = "Error in resource file: line %1: %2";
        message = message.arg(e.stopLine());
        message = message.arg(ws2qs(e.userMessage()));
    
        wstring errorMessage = qs2ws(message);
        throw GenericException(__FILE__, __LINE__, L"Resources::load", 
                               L"", errorMessage);
    }
    catch (GenericException& e)
    {
        QString message = "Error in resource file: %1";
        message = message.arg(ws2qs(e.userMessage()));

        wstring errorMessage = qs2ws(message);
        throw GenericException(__FILE__, __LINE__, L"Resources::load", 
                               L"", errorMessage);
    }

}
=====================================================================
Found a 41 line (120 tokens) duplication in the following files: 
Starting at line 32 of D:\home\eCora_PM\PM\idbXml\DbContainer.cpp
Starting at line 115 of D:\home\eCora_PM\PM\idb\DbContainer.cpp

}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
HRESULT DbContainer::QueryInterface(const GUID& iid, void** ppObj)
{
    if (IID_IUnknown == iid || IID_IDbContainer == iid)
    {
        *ppObj = (com::IDbContainer*)this;
        AddRef();
        return NO_ERROR;
    }
    else
    {
        *ppObj = 0;
        return E_NOINTERFACE;
    }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
unsigned long DbContainer::AddRef()
{
    return m_baseObject.addRef();
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
unsigned long DbContainer::Release()
{
    return m_baseObject.release(this);
}


/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
HRESULT DbContainer::addObject(IUnknown* pUnkObject)
{
    // check input
    CComQIPtr<com::IDbObject> pObject(pUnkObject);
    IfNullPtrRetVal(pObject, E_FAIL);
=====================================================================
Found a 10 line (120 tokens) duplication in the following files: 
Starting at line 1111 of D:\home\eCora_PM\PM\hostManager\Manage.cpp
Starting at line 2135 of D:\home\eCora_PM\PM\hostManager\Manage.cpp

    pmUI::ScanInfoManager& scanInfoManager = g_App->getListView()->getScanInfoManager();
    pmServices::Container<pmUI::TabScanInfo>& scanList = scanInfoManager.getScanList();
    for (pmServices::Container<pmUI::TabScanInfo>::iterator it = scanList.begin(); it != scanList.end(); ++it)
    {
        pmUI::ScanInfoManager::SYSTEMGRUPMAP systemList;
        scanInfoManager.getAllObjectIdsList(*it, systemList);
        for (int i = 0; i < selectedSystems.size(); i++)
        {
            if (systemList.find(selectedSystems[i]) != systemList.end())
            {                
=====================================================================
Found a 24 line (120 tokens) duplication in the following files: 
Starting at line 356 of D:\home\eCora_PM\PM\alerts\alertslib\GlobalAlert.cc
Starting at line 398 of D:\home\eCora_PM\PM\alerts\alertslib\GlobalAlert.cc

GlobalAlert::GlobalAlert(TriggerType* selector, 
			 const wstring& preAlertPath,
			 const wstring& customAlertPath,
			 ConditionDefinition* eventDef) : 
    XmlWriter(customAlertPath + L"/" + GENERAL_ALERT_FILE),
    m_selector(selector),
    m_enableMonitoring(false),
    m_monitorInterval(10),
    m_enableSNMP(false),
    m_snmpPort(DEFAULT_SNMP_PORT),
    m_enableSMTP(false),
    m_smtpPort(DEFAULT_SMTP_PORT),
    m_smtpMaxAttachSize(DEFAULT_MAX_ATTACH),
    m_compress(false),
    m_purgeInterval(DEFAULT_PURGE_INTERVAL), 
    m_purgeOlderThan(DEFAULT_PURGE_OLDER),
    m_enableTemplateTriggers(false),
    m_preAlertPath(preAlertPath),
    m_customAlertPath(customAlertPath),
    m_customAlertFile(0),
    m_templateAlertFile(0),
    m_customTriggerFile(0),
    m_eventDefinition(eventDef),
    m_services(0),
=====================================================================
Found a 16 line (120 tokens) duplication in the following files: 
Starting at line 61 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\FilesInstaller.cpp
Starting at line 115 of D:\home\eCora_PM\PM\agent\agent\apps\Installer\Installer\FilesInstaller.cpp

    static const tstring funk_name = ECORA_TEXT("FilesInstaller::uninstall()");
    ACE_DEBUG ((LM_DEBUG, ECORA_TEXT("%s\n"), funk_name.c_str()));
    // Allow local copy for pdb will valid.
    const boost::shared_ptr<InstallDB> pdb = m_context->m_db;
    const InstallDB& db = *pdb;

    const InsTable& ft = db.getTable(EI::FILES_TABLE);
    const InstallerConfig& config = InstallerConfig::instance();
    const tstring module_name = db.getModule().m_name;

    const tstring program_prefix = 
        config.getProgramFilesFolder() + ECORA_TEXT("/") + module_name;
    std::vector<tstring> pathes =
        InstallerUtils::relPathesFromFTable(ft, program_prefix, config.getProgramFilesFolder());

    const tstring temp_prefix = 
=====================================================================
Found a 27 line (120 tokens) duplication in the following files: 
Starting at line 170 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketClient.h
Starting at line 170 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketServer.h

class CSocketServer::WorkerThread : public CThread
{
  public:

    virtual ~WorkerThread() {}

    void InitiateShutdown();
    void WaitForShutdownToComplete();

  protected:

    explicit WorkerThread(CIOCompletionPort &iocp);
    virtual int Run();

  private:

    virtual void OnBeginProcessing() {}
    virtual void OnEndProcessing() {}

    virtual void OnError(const _tstring &message);

    void Read(Socket *pSocket, CIOBuffer *pBuffer) const;
    virtual void ReadCompleted(Socket *pSocket, CIOBuffer *pBuffer) = 0;


    void Write(Socket *pSocket, CIOBuffer *pBuffer) const;
    virtual void WriteCompleted(Socket *pSocket, CIOBuffer *pBuffer) = 0;
=====================================================================
Found a 18 line (119 tokens) duplication in the following files: 
Starting at line 118 of D:\home\eCora_PM\PM\software-license\SoftwareLicenseV1.h
Starting at line 102 of D:\home\eCora_PM\PM\ui\license\License.h

    virtual ~License();

    // Methods inherited from license::License
    virtual void categories(
        const wstring& feature, vector<wstring>& result) const;
    virtual void features(
        const wstring& category, vector<wstring>& result) const;
    virtual size_t devicesAllowed(
        const wstring& category, const wstring& feature) const;
    virtual size_t devicesLeft(
        const wstring& category, const wstring& feature) const;
    virtual void documentedDevices(
        const wstring& category, const wstring& feature,
        const bool distinct, vector<wstring>& result) const;
    virtual void invalidateDeviceSubmission(
        const wstring& category, const wstring& feature,
        const wstring& name);
    virtual bool preEnforce(
=====================================================================
Found a 25 line (119 tokens) duplication in the following files: 
Starting at line 1177 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\Idb.cc
Starting at line 1224 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\Idb.cc

            IdbRecord* rec = static_cast<IdbRecord*>(*(records.begin()));
            if (rec)
            {
                vector<wstring>::iterator valIt = attrVals.begin();
                for (vector<wstring>::iterator it = attrNames.begin();
                                        it != attrNames.end(); ++it, ++valIt)
                 
                {
                    wstring name = static_cast<wstring>(*it);
                    wstring val = static_cast<wstring>(*valIt);

                    Attribute* a = rec->findAttribute(name);
                    if (a)
                    {
                        a->setValue(val, false);
                    }
                    else
                    {
                        rec->addAttribute(name, val);
                    } 
                } 

                return true;
            }
        }
=====================================================================
Found a 29 line (119 tokens) duplication in the following files: 
Starting at line 277 of D:\home\eCora_PM\PM\pmAnalysisWinProvider\Constants.cpp
Starting at line 650 of D:\home\eCora_PM\PM\pmCollectorWinProvider\OsUtils.cpp

        wstring wsVersion = L"Windows XP ";//air add XP x64

        if (m_mask & PROD_WINXP_PR_x64)
            wsVersion += L"x64 ";
        
        if (m_mask & PROD_SP0)
            wsVersion += L"Gold";
        else if (m_mask & PROD_SP1)
            wsVersion += L"Service Pack 1";
        else if (m_mask & PROD_SP2)
            wsVersion += L"Service Pack 2";
        else if (m_mask & PROD_SP3)
            wsVersion += L"Service Pack 3";
        else if (m_mask & PROD_SP4)
            wsVersion += L"Service Pack 4";
        
        return wsVersion;
    }

    if ((m_mask & PROD_VISTA) || (m_mask & PROD_VISTA_x64))
    {
        wstring wsVersion = L"Windows Vista ";//air add Vista x64 + SP
        if (m_mask & PROD_VISTA_x64)
            wsVersion += L"x64 ";
        
        if (m_mask & PROD_SP0)
            wsVersion += L"Gold";
        if (m_mask & PROD_SP1)
            wsVersion += L"Service Pack 1";
=====================================================================
Found a 15 line (119 tokens) duplication in the following files: 
Starting at line 259 of D:\home\eCora_PM\PM\patchRepository\PatchFile.cpp
Starting at line 759 of D:\home\eCora_PM\PM\patchRepository\WindowsStorage.cpp

    for (size_t b = path.find(L'\\', f), e = path.find(L'\\', b + 1);
    wstring::npos != b;
        b = e, e = path.find(L'\\', b + 1))
    {
        wstring currentDir = path.substr(b + 1, e - b - 1);
        wstring absPath = path.substr(0, e);
        if (L".." == currentDir)
        {
            dir.cdUp();
            continue;
        }
        if (!dir.exists(ws2qs(absPath)))
            if (!dir.mkdir(ws2qs(absPath)))
            {
		wstring message = L"Unable to create directory " + absPath;
=====================================================================
Found a 16 line (119 tokens) duplication in the following files: 
Starting at line 121 of D:\home\eCora_PM\PM\patchManager\ServicePackTabControl.cpp
Starting at line 158 of D:\home\eCora_PM\PM\patchManager\ServicePackTabControl.cpp

                int rule = policy->getServicePackRule((*itSp)->spId());
                
                MsgHeaderServicePackInfo* msg = new MsgHeaderServicePackInfo(
                    (*itProduct)->shortName(),
                    (*itSp)->encryption(),
                    (*itSp)->spId(),
                    (*itSp)->languageId(),
                    (*itSp),
                    static_cast<pmUI::WinSystemInfo*>(*itSystem),
                    (*itProduct)->productInstance());
                m_allMessageHeader.addItem(msg);
                
                MsgServicePackPolicyInfoListItem* mi = new MsgServicePackPolicyInfoListItem(this, m_listview, msg, rule);
                m_allMessageItem.addItem(mi);
            }
        }
=====================================================================
Found a 16 line (119 tokens) duplication in the following files: 
Starting at line 462 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp
Starting at line 502 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp

        cf->m_checksum = dlg.m_checksum;
        m_tableFile->setItem(num, 0,
            new ESTableItem(m_tableFile, QTableItem::Never, dlg.m_path));
        m_tableFile->setItem(num, 1,
            new ESTableItem(m_tableFile, QTableItem::Never, dlg.m_version));
        m_tableFile->setItem(num, 2,
            new ESTableItem(m_tableFile, QTableItem::Never, dlg.m_checksum));
        m_changed = true;
        int col = m_tableFile->horizontalHeader()->sortIndicatorSection();
        if (col >= 0)
        {
            m_tableFile->sortColumn(col,
                m_tableFile->horizontalHeader()->sortIndicatorOrder() == Qt::Ascending,
                true);
        }
    }
=====================================================================
Found a 16 line (119 tokens) duplication in the following files: 
Starting at line 321 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp
Starting at line 361 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp

        cf->m_checksum = dlg.m_checksum;
        m_tableFile->setItem(num, 0,
            new ESTableItem(m_tableFile, QTableItem::Never, dlg.m_path));
        m_tableFile->setItem(num, 1,
            new ESTableItem(m_tableFile, QTableItem::Never, dlg.m_version));
        m_tableFile->setItem(num, 2,
            new ESTableItem(m_tableFile, QTableItem::Never, dlg.m_checksum));
        m_fileChanged = true;
        int col = m_tableFile->horizontalHeader()->sortIndicatorSection();
        if (col >= 0)
        {
            m_tableFile->sortColumn(col,
                m_tableFile->horizontalHeader()->sortIndicatorOrder() == Qt::Ascending,
                true);
        }
    }
=====================================================================
Found a 12 line (119 tokens) duplication in the following files: 
Starting at line 624 of D:\home\eCora_PM\PM\agent\agent\apps\AgentDeployment\AgentInstaller.cpp
Starting at line 673 of D:\home\eCora_PM\PM\agent\agent\apps\AgentDeployment\AgentInstaller.cpp

    DWORD dwKeyLen = ::SysStringLen(lpszKeyStr);
    if (dwKeyLen > ENC_BLOCK_LEN)
        lpszKeyStr = CComBSTR(ENC_BLOCK_LEN, lpszKeyStr).Detach();
    
    CHeapPtr<BYTE, CComAllocator> pKey;
    pKey.Allocate(ENC_BLOCK_LEN + 1);
    ::ZeroMemory(pKey.m_pData, ENC_BLOCK_LEN + 1);
    dwKeyLen = WideCharToMultiByte(CP_ACP, 0, lpszKeyStr, -1, (LPSTR)pKey.m_pData, ENC_BLOCK_LEN + 1, NULL, NULL);
    if (dwKeyLen < ENC_BLOCK_LEN + 1)
        memset(pKey.m_pData + dwKeyLen - 1, '*', ENC_BLOCK_LEN - dwKeyLen + 1);
    
    CHeapPtr<BYTE, CComAllocator> pDecData;
=====================================================================
Found a 25 line (119 tokens) duplication in the following files: 
Starting at line 53 of D:\home\eCora_PM\PM\agent\RemoteExec\FileVersion\ModuleVersion.cpp
Starting at line 110 of D:\home\eCora_PM\PM\agent\RemoteExec\FileVersion\ModuleVersion.cpp

    if (dwLength <= 0)
        return false;

    if (m_pVersionInfo)
    {
        delete [] m_pVersionInfo;
        m_pVersionInfo = NULL;
    }

    m_pVersionInfo = new BYTE[dwLength]; // allocate version info
    if (!::GetFileVersionInfo(szFileName, 0, dwLength, m_pVersionInfo))
        return false;

    LPVOID lpBuffer;
    UINT nLength;
    if (!::VerQueryValue(m_pVersionInfo, _T("\\"), &lpBuffer, &nLength))
        return false;

    // Copy fixed info to myself, which am derived from VS_FIXEDFILEINFO
    *(VS_FIXEDFILEINFO*)this = *(VS_FIXEDFILEINFO*)lpBuffer;

    // Get translation info
    if (VerQueryValue(m_pVersionInfo, _T("\\VarFileInfo\\Translation"),
        &lpBuffer, &nLength) && nLength >= 4)
        m_Translate = *(LANGANDCODEPAGE*)lpBuffer;
=====================================================================
Found a 19 line (118 tokens) duplication in the following files: 
Starting at line 92 of D:\home\eCora_PM\PM\unixPushActions\ChkExistingTaskAction.cpp
Starting at line 82 of D:\home\eCora_PM\PM\unixPushActions\RecordPendingTaskAction.cpp

    actionNode->addAttribute(Name, RECORDPENDINGJOB);
    actionNode->addAttribute(Id, int2wstring(id));

    xml::Node* parametersNode = new xml::Node(Parameters);
    actionNode->push_back(parametersNode);

    parametersNode->push_back(createParamNode(DevicePK, devicePK));

    // Get the formatted time
   // Format the time.
    wchar_t buf[24];
    wsprintf(buf, L"%d-%02d-%02dT%02d:%02d:%02d",
        dt.year(), dt.month(), dt.day(), dt.hours(), dt.minutes(), dt.seconds());
    wstring timestr = buf;
    parametersNode->push_back(createParamNode(Time, timestr));
    return actionNode;
}

bool
=====================================================================
Found a 27 line (118 tokens) duplication in the following files: 
Starting at line 878 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h
Starting at line 915 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h

    void testInvalidMd5()
    {
        /** scenario
        1. calculate md5 checksum for testsettings.xml file (for example)
        2. invalidate calculated checksum
        3. check calculated checksum
        */

        TS_ASSERT_THROWS_NOTHING(load());
        WindowsStorage storage(m_resources[WindowsStoragePath], g_App->services());

        // make sure environment set up for test
        try
        {
            storage.connect();
            if (!storage.exists())
                storage.create();
            fs::FileSystem* fs = g_App->appServices()->disk()->systemHome();
            wstring fileName = L"testsettings.xml";
            wstring fullName = fs->fullPath (fileName);
            storage.addFile (fullName, fileName, 0, 0);

            wstring szCalculatedCheckSum; // for calculating checksum
            wstring szCheckSum; // for checked checksum

            // calculating checksum
            TS_ASSERT_EQUALS(storage.validateMd5 (fileName, szCheckSum, szCalculatedCheckSum), false);
=====================================================================
Found a 19 line (118 tokens) duplication in the following files: 
Starting at line 206 of D:\home\eCora_PM\PM\patchRepository\DownloadDialog.cpp
Starting at line 143 of D:\home\eCora_PM\PM\ui\network\DownloadDialog.cc

		*this, &DownloadDialogPrivate::setGui, L"", amount, total));
	return;
    }

    int hours = secondsLeft / 3600;
    secondsLeft %= 3600;
    int minutes = secondsLeft / 60;
    secondsLeft %= 60;

    // BEGIN FIX BUG #18496

    wstring estimate;
    if (hours != 0)
        estimate = int2wstring(hours) + L" " + plural(hours, qs2ws(QObject::tr("hour"))) + L", ";
    if (minutes != 0)
	estimate += int2wstring(minutes) + L" " +
	    plural(minutes, qs2ws(QObject::tr("minute"))) + L", ";
    estimate += int2wstring(secondsLeft) + L" " +
	plural(secondsLeft, qs2ws(QObject::tr("second")));
=====================================================================
Found a 27 line (118 tokens) duplication in the following files: 
Starting at line 84 of D:\home\eCora_PM\PM\network\ScpConnection.cpp
Starting at line 135 of D:\home\eCora_PM\PM\network\ScpConnection.cpp

    arguments.push_back(localFilename);    
    
    try {
        m_host = new Smuggler(m_driver, m_client, arguments);
    }
    catch (...)
    {
        deleteHost();
        throw;
    }

    vector<bstring> errorPrompts;
    errorPrompts.push_back("Fatal:");
    errorPrompts.push_back("Command failed:");
    errorPrompts.push_back("Access denied");

    vector<bstring> successPrompts;
    successPrompts.push_back("Success:");

    bstring response = waitForTransfer(successPrompts, errorPrompts);
    deleteHost();
    if (response.find("Command failed:") != bstring::npos)
    {
        wstring errorMessage = L"File transfer timeout: " + logMessage +
            L" Host response: " + bstring2wstring(response);

        throw GenericException(__FILE__, __LINE__, L"ScpConnection::get", 
=====================================================================
Found a 15 line (118 tokens) duplication in the following files: 
Starting at line 619 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp
Starting at line 663 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp

        m_tableLocation->setItem(num, 0,
            new ESTableItem(m_tableLocation, QTableItem::Never, cl->m_filename));
        m_tableLocation->setItem(num, 1,
            new ESTableItem(m_tableLocation, QTableItem::Never, cl->m_unc));
        m_tableLocation->setItem(num, 2,
            new ESTableItem(m_tableLocation, QTableItem::Never, cl->m_url));
        m_changed = true;
        int col = m_tableLocation->horizontalHeader()->sortIndicatorSection();
        if (col >= 0)
        {
            m_tableLocation->sortColumn(col,
                m_tableLocation->horizontalHeader()->sortIndicatorOrder() == Qt::Ascending,
                true);
        }
    }
=====================================================================
Found a 13 line (118 tokens) duplication in the following files: 
Starting at line 88 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp
Starting at line 95 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp

        CustomRegistry* cr = patch->m_regs[i];
        int num = m_tableReg->numRows();
        m_tableReg->setNumRows(num + 1);
        m_tableReg->setItem(num, 0,
            new ESTableItem(m_tableFile, QTableItem::Never, cr->m_registryKey));
        m_tableReg->setText(num, 1, m_info->m_regTypes[(int)cr->m_regType]);
        m_tableReg->setItem(num, 2, 
            new ESTableItem(m_tableReg, QTableItem::Never, cr->m_value));

        QString data = cr->m_data;
        data = data.replace('\n', ' ');
        m_tableReg->setItem(num, 3,
            new QTableItem(m_tableReg, QTableItem::Never, data));
=====================================================================
Found a 14 line (117 tokens) duplication in the following files: 
Starting at line 648 of D:\home\eCora_PM\PM\pmpushWinShared\Scheduler.cpp
Starting at line 578 of D:\home\eCora_PM\PM\scanScheduling\WinSchedulerWrapper.cpp

    TASK_TRIGGER trigger;
    ZeroMemory(&trigger, sizeof(TASK_TRIGGER));

    trigger.cbTriggerSize = sizeof(TASK_TRIGGER);
    trigger.wBeginDay = dt.date().day();
    trigger.wBeginMonth = dt.date().month();
    trigger.wBeginYear = dt.date().year();
    trigger.wStartHour = dt.time().hour();
    trigger.wStartMinute = dt.time().minute();
    trigger.TriggerType = TASK_TIME_TRIGGER_ONCE; // Trigger is set to run the task a single time

    hr = piTaskTrigger->SetTrigger(&trigger);
    if (FAILED(hr))
    {
=====================================================================
Found a 26 line (117 tokens) duplication in the following files: 
Starting at line 98 of D:\home\eCora_PM\PM\pmWindowsService\App.cpp
Starting at line 182 of D:\home\eCora_PM\PM\serviceFramework\ServiceWidget.cpp

int ServiceWidget::launchProgramEx(const wstring& commandLine)
{
    auto_ptr<wchar_t> comline(new wchar_t[commandLine.size() + 1]);
    wcscpy(comline.get(), commandLine.c_str());
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    memset(&si, 0, sizeof(si));
    si.cb = sizeof(STARTUPINFO);
    si.lpDesktop = NULL;

    BOOL res = CreateProcess(
	NULL,
	comline.get(),     // lpCommandLine
	NULL,              // lpProcessAttributes
	NULL,              // lpThreadAttributes
	FALSE,             // bInheritHandles
	DETACHED_PROCESS | IDLE_PRIORITY_CLASS,  // dwCreationFlags
	NULL,              // lpEnvironment
	NULL,              // lpCurrentDirectory
	&si,               // lpStartupInfo
	&pi                // lpProcessInformation
	);

    if (!res) 
    {
=====================================================================
Found a 24 line (117 tokens) duplication in the following files: 
Starting at line 508 of D:\home\eCora_PM\PM\pmDaoDbImpl\DaoDbImplUnitTest.h
Starting at line 668 of D:\home\eCora_PM\PM\pmDaoXmlImpl\DaoXmlImplUnitTest.h

        iProduct->setLanguage(L"ENU");
        iProduct->setStatus(0);

        pmDaoInterfaces::IPatch* iPatch = iProduct->addPatch();

        iPatch->setPatchId(L"cwXSCgWFiLRsvkl+hlOnbA==");
        iPatch->setStatus(L"NOTFOUND");
        iPatch->setComment(L"The following registry key has not been found: "
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix\\Q295534");
        iPatch->setUninstallData(L"Test uninstall string");

        iPatch = iProduct->addPatch();

        iPatch->setPatchId(L"PHvZgbSo85QoOs5tVgLfFA==");
        iPatch->setStatus(L"FOUND");
        iPatch->setComment(L"Test comment");
        iPatch->setUninstallData(L"c:\\winnt\\$NtUninstallQ252463$\\hotfix.exe /u");

        iProduct = iSystem->addProduct();

        iProduct->setVersionId(L"Windows NT Server 4.0 - Windows NT4 Service Pack 6a");
        iProduct->setInstance(L"Test Instance");
        iProduct->setLocation(L"Test Location");
        iProduct->setLanguage(L"ENU");
=====================================================================
Found a 19 line (117 tokens) duplication in the following files: 
Starting at line 177 of D:\home\eCora_PM\PM\pmArchivePurge\ArchiveIndexWnd.cpp
Starting at line 265 of D:\home\eCora_PM\PM\pmArchivePurge\ArchiveIndexWnd.cpp

            restorer.DeleteData();
            BREAK_WAIT_CURSOR();
        }
        
        vector<QListViewItem*> toTake;
        for (QListViewItem* listIt = m_availableScanResultsView->firstChild(); listIt; listIt = listIt->nextSibling())
        {
            if (listIt->isSelected())
                toTake.push_back(listIt);
        }
        for (vector<QListViewItem*>::iterator itr = toTake.begin(); itr != toTake.end(); itr = toTake.erase(itr))
        {
            m_availableScanResultsView->takeItem(*itr);
            delete *itr;
        }
    }
    catch (GenericException& ex)
    {        
        log(L"patchManager", Log::Error, L"ArchiveIndexWnd::deleteScanResults: " + ex.message());
=====================================================================
Found a 24 line (117 tokens) duplication in the following files: 
Starting at line 1523 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 181 of D:\home\eCora_PM\PM\patchRepository\WinSolRepoSettings.cpp

    m_dsnChanged(false)
{
    if (0 == winWidget)
        m_winWidget = new WinRepoSettings(parent, services);
    else
        m_winWidget = (WinRepoSettings*)winWidget;
    if (0 == solWidget)
        m_solWidget = new SolRepoSettings(parent, services);
    else
        m_solWidget = (SolRepoSettings*)solWidget;
    qtInit();
}

WinSolRepoSettings::WinSolRepoSettings(RepositorySettingsDlgQT* parent, IUnknown* services,
                                       QWidget* winWidget, QWidget* solWidget) :
//    RepositorySettingsUI(parent, "RepositorySettings"),
    m_services(services),
    m_parent(parent),
    m_advancedUnix(0),
    m_dialog(true),
    m_pDialog(parent),
    m_originalWindowsSettings(0),
    m_originalUnixSettings(0),
    m_dsnChanged(false)
=====================================================================
Found a 26 line (117 tokens) duplication in the following files: 
Starting at line 1632 of D:\home\eCora_PM\PM\patchManager\App.cpp
Starting at line 182 of D:\home\eCora_PM\PM\serviceFramework\ServiceWidget.cpp

int ServiceWidget::launchProgramEx(const wstring& commandLine)
{
    auto_ptr<wchar_t> comline(new wchar_t[commandLine.size() + 1]);
    wcscpy(comline.get(), commandLine.c_str());
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    memset(&si, 0, sizeof(si));
    si.cb = sizeof(STARTUPINFO);
    si.lpDesktop = NULL;

    BOOL res = CreateProcess(
	NULL,
	comline.get(),     // lpCommandLine
	NULL,              // lpProcessAttributes
	NULL,              // lpThreadAttributes
	FALSE,             // bInheritHandles
	DETACHED_PROCESS | IDLE_PRIORITY_CLASS,  // dwCreationFlags
	NULL,              // lpEnvironment
	NULL,              // lpCurrentDirectory
	&si,               // lpStartupInfo
	&pi                // lpProcessInformation
	);

    if (!res) 
    {
=====================================================================
Found a 29 line (117 tokens) duplication in the following files: 
Starting at line 52 of D:\home\eCora_PM\PM\idbXml\DbFields.cpp
Starting at line 46 of D:\home\eCora_PM\PM\idb\DbFields.cpp

    m_encodedFieldValues[qsName] = isEncoded(qsName) ? encode(qsValue) : qsValue;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
QString DbFields::getFieldValue(const QString& qsName) const
{
    if (m_fieldValues.end() != m_fieldValues.find(qsName))
        return m_fieldValues[qsName];
    else
        return "";
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
QString DbFields::getEncodedFieldValue(const QString& qsName) const
{
    if (m_encodedFieldValues.end() != m_encodedFieldValues.find(qsName))
        return m_encodedFieldValues[qsName];
    else
        return "";
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void DbFields::setEncodedFieldValue(const QString& qsName, QString& qsValue)
{
    m_encodedFieldValues[qsName] = qsValue;
    m_fieldValues[qsName] = isEncoded(qsName) ? decode(qsValue) : qsValue;
=====================================================================
Found a 26 line (117 tokens) duplication in the following files: 
Starting at line 189 of D:\home\eCora_PM\PM\agent\AgentManager\AMSetup\serviceCredentialsCheck\serviceCredentialsCheck.cpp
Starting at line 257 of D:\home\eCora_PM\PM\agent\agent\apps\Setup\Win32\Msi\CustomActions\CustomActionsDLL\CustomActions.cpp

    CString szServiceName;
    CString szCmd;

    LONG res = ::RegCreateKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",
        0, 0, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 0, &systemFolderkey, 0);
    if (ERROR_SUCCESS != res)
    {
        return ReportInstallError(hInstall, 
            L"Could not open registry key(SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion)!");
    }
    DWORD type = REG_DWORD;
    BYTE buf[1024];
    DWORD cBuf = 1024;

    res = ::RegQueryValueEx(systemFolderkey,
        L"SystemRoot",
        0, &type, buf, &cBuf);
    if (ERROR_SUCCESS != res)
    {
        return ReportInstallError(hInstall, 
            L"Could not read registry key(SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion) value!");
    }
    CString strPath = (wchar_t*)buf;
    strPath += L"\\system32";
    szCmd = strPath + L"\\cmd.exe ";
=====================================================================
Found a 14 line (116 tokens) duplication in the following files: 
Starting at line 143 of D:\home\eCora_PM\PM\snoopy\listbox.cpp
Starting at line 281 of D:\home\eCora_PM\PM\snoopy\listbox.cpp

			int curSel = aItems[i] - i;
			TCHAR* sit = _tcsstr(
			    m_labels[m_selected[curSel]].c_str(), _T("ou="));
			PCTSTR s = sit ? sit + 3 :
			    m_labels[m_selected[curSel]].c_str();
			WAddExtentEntry(aWnd, s);
			int addedStringIndex =
			    SendMessage(aWnd, LB_ADDSTRING,
					(WPARAM)(0), (LPARAM)s);
			for (int j = m_lastAvailable;
			     j > addedStringIndex; j--)
			    m_available[j] = m_available[j - 1];
			m_available[addedStringIndex] = m_selected[curSel];
                        DecreaseSelectionNumber(s);
=====================================================================
Found a 13 line (116 tokens) duplication in the following files: 
Starting at line 103 of D:\home\eCora_PM\PM\snoopy\listbox.cpp
Starting at line 206 of D:\home\eCora_PM\PM\snoopy\listbox.cpp

			int curSel = aItems[i] - i;
			TCHAR* sit = _tcsstr(
			    m_labels[m_available[curSel]].c_str(), _T("ou="));
			PCTSTR s = sit ? sit + 3 :
			    m_labels[m_available[curSel]].c_str();
			WAddExtentEntry(sWnd, s);
			int addedStringIndex =
			    SendMessage(sWnd, LB_ADDSTRING,
					(WPARAM)(0), (LPARAM)s);
			for (int j = m_lastSelected; j > addedStringIndex; j--)
			    m_selected[j] = m_selected[j - 1];
			m_selected[addedStringIndex] = m_available[curSel];
                        IncreaseSelectionNumber(s);
=====================================================================
Found a 21 line (116 tokens) duplication in the following files: 
Starting at line 430 of D:\home\eCora_PM\PM\patchRepository\PatchRepository.cpp
Starting at line 703 of D:\home\eCora_PM\PM\patchRepository\RepositoryManager.cpp

    vector<Patch*> patches;
    loadPatches(patchIDs, patches);

    if (results != 0)
    {
	*results = new PatchResults();
    }

    bool allDownloaded = patchStatus(patches);

    for (int i = 0; i < patches.size(); ++i)
    {
	if (results != 0)
	{
	    (*results)->push_back(patches[i]->patchResult());	
	    patches[i]->setDeleteResult(false);
	}
    }

    for (i = 0; i < patches.size(); ++i)
        delete patches[i];
=====================================================================
Found a 23 line (116 tokens) duplication in the following files: 
Starting at line 588 of D:\home\eCora_PM\PM\alerts\alertslib\GlobalAlert.cc
Starting at line 174 of D:\home\eCora_PM\PM\alerts\upgrade\GlobalAlert.cpp

GlobalAlert10::save()
{
    try {
	read(L"monitoring-data", true);
        // monitoring attributes
	setAttribute(m_topXmlNode, ENABLE_MONITORING_ATTR, m_enableMonitoring);
	if (m_monitorInterval < MINIMUM_INTERVAL)
	    m_monitorInterval = MINIMUM_INTERVAL;
	setAttribute(m_topXmlNode, MONITOR_INTERVAL_ATTR, m_monitorInterval);

	// SNMP global attributes
	setAttribute(m_topXmlNode, ENABLE_SNMP_ATTR, m_enableSNMP);
	setAttribute(m_topXmlNode, SNMP_MANAGER_ATTR, m_snmpManager);
	setAttribute(m_topXmlNode, SNMP_PORT_ATTR, m_snmpPort);

	// SMTP global attributes
	setAttribute(m_topXmlNode, ENABLE_SMTP_ATTR, m_enableSMTP);
	setAttribute(m_topXmlNode, SMTP_MANAGER_ATTR, m_smtpServer);
	setAttribute(m_topXmlNode, SMTP_PORT_ATTR, m_smtpPort);
	setAttribute(m_topXmlNode, SMTP_MAX_ATTACH_ATTR, m_smtpMaxAttachSize);
	setAttribute(m_topXmlNode, L"smtp-attach-compress", m_compress);

	setAttribute(m_topXmlNode, L"purge-interval", m_purgeInterval);
=====================================================================
Found a 25 line (116 tokens) duplication in the following files: 
Starting at line 40 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\dummy.cpp
Starting at line 41 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\tests\resume_updownload.cpp

           << ECORA_TEXT("<package>system 1.0.0.1</package>\n")
           << ECORA_TEXT("<command><![CDATA[ping -n 1 127.0.0.1]]></command>\n")
           << ECORA_TEXT("<envVars>\n")
           << ECORA_TEXT("<envVar name=\"var1\"><![CDATA[val1]]></envVar>\n")
           << ECORA_TEXT("<envVar name=\"var2\"><![CDATA[val2]]></envVar>\n")
           << ECORA_TEXT("<envVar name=\"var3\"><![CDATA[val3]]></envVar>\n")
           << ECORA_TEXT("</envVars>\n")
           << ECORA_TEXT("<tempFiles>\n")
           << ECORA_TEXT("<tempFile name=\"tf1.dat\"><![CDATA[t1]]></tempFile>\n")
           << ECORA_TEXT("<tempFile name=\"tf2.dat\"><![CDATA[t2]]></tempFile>\n")
           << ECORA_TEXT("<tempFile name=\"tf3.dat\"><![CDATA[t3]]></tempFile>\n")
           << ECORA_TEXT("</tempFiles>\n")
           << ECORA_TEXT("<dataFiles>\n")
           << ECORA_TEXT("<dataFile name=\"test1.dat\">R0lGODlhcgGSALMAAAQCAEMmCZtuMFQxDS8b</dataFile>\n")
           << ECORA_TEXT("<dataFile name=\"test2.dat\">R0lGODlhcgGSALMAAAQCAEMmCZtuMFQxDS8b</dataFile>\n")
           << ECORA_TEXT("<dataFile name=\"test3.dat\">R0lGODlhcgGSALMAAAQCAEMmCZtuMFQxDS8b</dataFile>\n")
           << ECORA_TEXT("</dataFiles>\n")
           << ECORA_TEXT("<resFiles>\n")
           << ECORA_TEXT("<resFile name=\"res1.dat\"/>\n")
           << ECORA_TEXT("<resFile name=\"res2.dat\">res2</resFile>\n")
           << ECORA_TEXT("<resFile name=\"res3.dat\"><![CDATA[res3]]></resFile>\n")
           << ECORA_TEXT("</resFiles>\n")
           << ECORA_TEXT("</job>\n");

    TEST_OUT(ACE_TEXT("resume_updownload::requestJob() job_id=") << m_job_id);
=====================================================================
Found a 30 line (116 tokens) duplication in the following files: 
Starting at line 38 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\CheckRequirements.cpp
Starting at line 191 of D:\home\eCora_PM\PM\adsi\ErrorMsg.cpp

typedef struct tagADSERRMSG
{
    HRESULT    hr;
    LPCTSTR    pszError;
} ADSERRMSG;
 
#define ADDADSERROR(x)   x, _T(#x)
 
ADSERRMSG adsErr[] = 
{
    ADDADSERROR(E_ADS_BAD_PATHNAME),
    ADDADSERROR(E_ADS_INVALID_DOMAIN_OBJECT),
    ADDADSERROR(E_ADS_INVALID_USER_OBJECT),
    ADDADSERROR(E_ADS_INVALID_COMPUTER_OBJECT),
    ADDADSERROR(E_ADS_UNKNOWN_OBJECT),
    ADDADSERROR(E_ADS_PROPERTY_NOT_SET),
    ADDADSERROR(E_ADS_PROPERTY_NOT_SUPPORTED),
    ADDADSERROR(E_ADS_PROPERTY_INVALID),
    ADDADSERROR(E_ADS_BAD_PARAMETER),
    ADDADSERROR(E_ADS_OBJECT_UNBOUND),
    ADDADSERROR(E_ADS_PROPERTY_NOT_MODIFIED),
    ADDADSERROR(E_ADS_PROPERTY_MODIFIED),
    ADDADSERROR(E_ADS_CANT_CONVERT_DATATYPE),
    ADDADSERROR(E_ADS_PROPERTY_NOT_FOUND),
    ADDADSERROR(E_ADS_OBJECT_EXISTS),
    ADDADSERROR(E_ADS_SCHEMA_VIOLATION),
    ADDADSERROR(E_ADS_COLUMN_NOT_SET),
    ADDADSERROR(E_ADS_INVALID_FILTER),
    ADDADSERROR(0),
};
=====================================================================
Found a 23 line (116 tokens) duplication in the following files: 
Starting at line 846 of D:\home\eCora_PM\PM\NetDiscover\HostDialog.h
Starting at line 1084 of D:\home\eCora_PM\PM\NetDiscover\HostDialog.h

    if (m_netDecission.get() && m_netDecission->discoveryStopped())
    {
        m_netDecission.release();
        m_netDecission = auto_ptr< CNetDecision<TParameters, TDevice> >(0);
    }

    // very important, related to thread context
    if (!m_netDecission.get())
    {
        m_netDecission = auto_ptr< CNetDecision<TParameters, TDevice> >
                            (new CNetDecision<TParameters, TDevice>(m_rParameters));
        // for status messages
        m_netDecission->setProgressDlg(m_pDialogWait);
    }
    m_netDecission->setDiscoveryStopped(false);

    // in case we die, we do not want to crash
    CNetDecision<TParameters, TDevice>* pNetObject = m_netDecission.get();

    //we can arrive here from radio buttons 3, 4, 5
    switch (ButtonGroupSelect->id(ButtonGroupSelect->selected()))
    {
        case METHOD_NB:
=====================================================================
Found a 17 line (115 tokens) duplication in the following files: 
Starting at line 114 of D:\home\eCora_PM\PM\winPushActions\ChkExistingTaskAction.cpp
Starting at line 912 of D:\home\eCora_PM\PM\winPushActions\DelayTaskAction.cpp
Starting at line 79 of D:\home\eCora_PM\PM\winPushActions\DeleteTaskAction.cpp

    xml::Node* actionNode = actionHeader(DELETETASK, id);

    xml::Node* parametersNode = new xml::Node(Parameters);
    actionNode->push_back(parametersNode);
    
    xml::Node* parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, Domain);
    parameterNode->addAttribute(Value, domain);
    parametersNode->push_back(parameterNode);

    parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, NetName);
    parameterNode->addAttribute(Value, computer);
    parametersNode->push_back(parameterNode);

    parameterNode = new xml::Node(Parameter);
    parameterNode->addAttribute(Name, TaskName);
=====================================================================
Found a 18 line (115 tokens) duplication in the following files: 
Starting at line 359 of D:\home\eCora_PM\PM\print\Format.h
Starting at line 114 of D:\home\eCora_PM\PM\print\HTML.h

    virtual ecwofstream& bold();
    virtual ecwofstream& end_bold();
    virtual ecwofstream& italic();
    virtual ecwofstream& end_italic();
    virtual ecwofstream& underline();
    virtual ecwofstream& end_underline();
    virtual ecwofstream& verbatim();
    virtual ecwofstream& end_verbatim();
    virtual ecwofstream& fixed();
    virtual ecwofstream& end_fixed();
    virtual ecwofstream& center();
    virtual ecwofstream& end_center();
    virtual ecwofstream& quote();
    virtual ecwofstream& end_quote();
    virtual ecwofstream& paragraph();
    virtual ecwofstream& end_paragraph();

    virtual ecwofstream& note(bool indent = false);
=====================================================================
Found a 33 line (115 tokens) duplication in the following files: 
Starting at line 100 of D:\home\eCora_PM\PM\pmPushUnixBaseImpl\Domain.cpp
Starting at line 160 of D:\home\eCora_PM\PM\pmPushUnixBaseImpl\Task.cpp

    pmPushBaseModel::IJob::iterator it;
    if (v.depthFirst())
    {
        for (it = begin(); end() != it; ++it)
        {
            if (*it)
            {
                (*it)->accept(v);
            }
            else
            {
                return;
            }
        }
        v.visit(this); 
    }
    else
    {
        v.visit(this); 
        for (it = begin(); end() != it; ++it)
        {
            if (*it)
            {
                (*it)->accept(v);
            }
            else
            {
                return;
            }
        }
    }
}
void
=====================================================================
Found a 24 line (115 tokens) duplication in the following files: 
Starting at line 2549 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 1139 of D:\home\eCora_PM\PM\patchRepository\WinSolRepoSettings.cpp

        QMessageBox::warning(0,
            tr("Unable to access repository..."),
        translator.translate(ws2qs(m_errorMessage)), QObject::tr("&OK"));
        return testSuccess;
    }

    if (!checkValidityAfterTest())
    return false;

    m_pISettings->setSetting(L"repositoryDatabaseCleanup",
        (m_winWidget->m_removeUnusedStatus->isChecked() ? L"true" : L"false"));

    // update repo in another thread
    log(L"patchRepository", Log::Debug, L"Save repository settings");
    bool success = inDialog<bool>(
        m_parent,
        qs2ws(tr("Saving repository settings...")),
        intercept::memberFunction<bool>(*this, &WinSolRepoSettings::update));

    if (!success)
    {
        // BEGIN FIX BUF #18532

        QMessageBox::warning(0,
=====================================================================
Found a 16 line (115 tokens) duplication in the following files: 
Starting at line 77 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\JRParser.h
Starting at line 170 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\JRParser.h

    ServerJobTempFile(const tstring& name, const tstring& data)
        : m_name(name), m_data(data)
    {
    }

    template <class Context>
        inline void XMLpersist(Context *ctx, const tstring& name, DOMElement* parent)
    {
        DOMElement* el = parent;

        ecora::xmlutils::XMLpersist(ctx, m_name, ECORA_TEXT("name"), el);
        DOMAttr* pattr = el->getAttributeNode(tstring2xmlstring(ECORA_TEXT("path")).c_str());
        if (pattr)
        {
            ecora::xmlutils::XMLpersist(ctx, m_path, ECORA_TEXT("path"), el);
        }
=====================================================================
Found a 15 line (114 tokens) duplication in the following files: 
Starting at line 1367 of D:\home\eCora_PM\PM\pmPush\LocalFactory.cpp
Starting at line 1492 of D:\home\eCora_PM\PM\pmPush\LocalFactory.cpp

        L"systemScan.scanFK= '" + info.scanKey() + L"' AND "
        L"systemScan.hostFK= '" + info.computerKey() + L"'";

        QSqlQuery query = m_dbManager->exec(queryStr);
        //query = m_dbManager->exec(queryStr);
        if (query.isActive() && query.first())
        {
            *versId = qs2ws(query.value(0).toString());
            *prodId = qs2ws(query.value(1).toString());
        }
        else
        {
            QSqlError err = query.lastError();
            wstring errStr = qs2ws(err.driverText() + " " + err.databaseText());
            int x = err.type();
=====================================================================
Found a 12 line (114 tokens) duplication in the following files: 
Starting at line 172 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\Task.cpp
Starting at line 252 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\Task.cpp

        settings->setting(L"binDir") + Common::InstallerName, taskDir));
    
    //Yakovenko: BUGFIX 25075
    actionSeq->push_back(CopyFileAction::representation((*id)++, 
        settings->setting(L"binDir") + Common::DTDName, taskDir));
    f.setName(ws2qs(settings->setting(L"binDir") + Common::DTDName));
    m_totalTaskDiskBytes += f.size();
    
    actionSeq->push_back(CopyFileAction::representation((*id)++, 
        settings->setting(L"binDir") + Common::DTDSvcName, taskDir));
    f.setName(ws2qs(settings->setting(L"binDir") + Common::DTDSvcName));
    m_totalTaskDiskBytes += f.size();
=====================================================================
Found a 11 line (114 tokens) duplication in the following files: 
Starting at line 477 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp
Starting at line 886 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp

        m_newPatch->m_regs[i] = cr;
        m_tableReg->setItem(num, 0,
            new ESTableItem(m_tableReg, QTableItem::Never, cr->m_registryKey));
        m_tableReg->setItem(num, 1,
            new ESTableItem(m_tableReg, QTableItem::Never, m_info->m_regTypes[cr->m_regType]));
        m_tableReg->setItem(num, 2,
            new ESTableItem(m_tableReg, QTableItem::Never, cr->m_value));
        QString data = cr->m_data;
        data = data.replace('\n', ' ');
        m_tableReg->setItem(num, 3,
            new ESTableItem(m_tableReg, QTableItem::Never, data));
=====================================================================
Found a 20 line (114 tokens) duplication in the following files: 
Starting at line 117 of D:\home\eCora_PM\PM\alerts\alertslib\util.cc
Starting at line 661 of D:\home\eCora_PM\PM\i18n\Conversions.cc

ws2utf8s(const wstring& s)
{
    if (s.empty())
	return utf8string("");

    size_t length = utf8string::maxCharLength() * s.size();

#ifndef _WIN32
    mbstate_t ps;
    memset(&ps, '\0', sizeof(mbstate_t));
    char* dest = new char[length + 1];
    const wchar_t* src = s.c_str();

    length = wcsrtombs(dest, &src, length + 1, &ps);

    if (length == static_cast<size_t>(-1))
    {
        delete[] dest;
        throw invalid_argument("wstring");
    }
=====================================================================
Found a 25 line (114 tokens) duplication in the following files: 
Starting at line 45 of D:\home\eCora_PM\PM\agent\agent\apps\Connector\ManagedStream.h
Starting at line 69 of D:\home\eCora_PM\PM\agent\agent\apps\Connector\ManagedStream.h

        class UnManagedStream : public ProxyStream<SOCKET_STREAM>
        {
          public:
            // @throw SocketException if underlying socket returns error
            size_t send(SOCKET_STREAM& stream, const ByteBuffer& buff);
            // @throw SocketException if underlying socket returns error
            size_t recv(SOCKET_STREAM& stream, ByteBuffer& buff, size_t size);

            size_t sendAtLeast(SOCKET_STREAM& stream, const ByteBuffer& buff);

            // @throw SocketException if underlying socket returns error
            // @throw NetOperationTimedOut if timedout expires
            size_t send(SOCKET_STREAM& stream,
                const ByteBuffer& buff, const ACE_Time_Value& tv);
            // @throw SocketException if underlying socket returns error
            // @throw NetOperationTimedOut if timedout expires
            size_t recv(SOCKET_STREAM& stream,
                ByteBuffer& buff, size_t size, const ACE_Time_Value& tv);

            size_t sendAtLeast(SOCKET_STREAM& stream,
                const ByteBuffer& buff, const ACE_Time_Value& tv);
        };

        template <class SOCKET_STREAM>
            class StreamProxyFactory
=====================================================================
Found a 80 line (114 tokens) duplication in the following files: 
Starting at line 907 of D:\home\eCora_PM\PM\agent\agent\Library\unzlib\zlib.h
Starting at line 625 of D:\home\eCora_PM\PM\zlib\zlib.h

                                  int level));
/*
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
   Huffman only compression as in "wb1h". (See the description
   of deflateInit2 for more information about the strategy parameter.)

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.

     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).  */

ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy. See the description
   of deflateInit2 for the meaning of these parameters.
     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
=====================================================================
Found a 23 line (114 tokens) duplication in the following files: 
Starting at line 106 of D:\home\eCora_PM\PM\agent\agent\Library\Common\StringUtils.cpp
Starting at line 15 of D:\home\eCora_PM\PM\agent\agent\Library\PsExecLib\StringUtils.cpp

tstring StringUtils::trimRight(const tstring& source, const tstring& t)
{
    tstring str = source;
    str.erase(str.find_last_not_of(t) + 1);
    return str;
}


tstring StringUtils::trimLeft(const tstring& source, const tstring& t)
{
    tstring str = source;
    str.erase(0, str.find_first_not_of(t));
    return str;
}


tstring StringUtils::trim(const tstring& source, const tstring& t)
{
    return trimLeft(trimRight(source, t), t);
}


tstring StringUtils::bytes2str(const std::vector<BYTE>& from)
=====================================================================
Found a 17 line (113 tokens) duplication in the following files: 
Starting at line 161 of D:\home\eCora_PM\PM\patchManager\PatchUpdateTest.cpp
Starting at line 201 of D:\home\eCora_PM\PM\patchManager\PatchUpdateTest.cpp

    patchUpdate = new PatchUpdate(g_App->services(), L"99.0.0.0", 0); // high product revision, don't want an update for that
    TS_ASSERT(patchUpdate);

    TS_ASSERT(saveDbVersions(patchUpdate));
    TS_ASSERT(setLowDbVersions());

    updates = patchUpdate->availableUpdates();
    updateFiles = patchUpdate->downloadUpdates(patchUpdate->availableUpdates(), downloadDir);

    TS_ASSERT_EQUALS(updates.size(), updateFiles.size());

    for (vector<pair<wstring, wstring> >::iterator it = updateFiles.begin(); it != updateFiles.end(); ++it)
    {
        TS_ASSERT(QFile::exists(ws2qs(it->second)));
    }

    TS_ASSERT(patchUpdate->installUpdates(updateFiles));
=====================================================================
Found a 29 line (113 tokens) duplication in the following files: 
Starting at line 77 of D:\home\eCora_PM\PM\network\SshConnection.cpp
Starting at line 75 of D:\home\eCora_PM\PM\network\TelnetConnection.cpp

    bstring2wstring(connectionMethod) + L" -telnet " + device->hostname();

    bstring arguments = ws2ansi(device->arguments());
   
    while (true)
    {
	char* thisToken =
	    strtok(const_cast<char *>(arguments.c_str()), " \t,;");
	
	if (thisToken == NULL)
	    break;

        bstring token = thisToken;

	m_connectionString += L" ";
	m_connectionString += bstring2wstring(token);

	baseArguments.push_back(token); 
    }

    //  FIXME:  We need a default for when the user does not want
    //    to enter a port.
    if (device->port() != 0)
    {
        baseArguments.push_back("-P");
        baseArguments.push_back(int2bstring(device->port()));
    }
	
    log(L"TelnetConnection::connectTo", Log::Debug, m_connectionString);
=====================================================================
Found a 21 line (113 tokens) duplication in the following files: 
Starting at line 1610 of D:\home\eCora_PM\PM\hostManager\Select.cpp
Starting at line 704 of D:\home\eCora_PM\PM\patchManager\GuiWinThread.cpp

GuiWinThread::getUniqueKey(CRegConnectRegistry* pHklmKey, wstring wsPath, wstring& wsID)
{
    try
    {
        if (wcsstr(wsPath.c_str(), L"\\DiskPeripheral\\0"))
        {
            KeyValues keyVal(pHklmKey->GetHKEY(), wsPath.c_str());
            keyVal.Read();

            map<wstring, KeyData>::iterator mapiter;
            if ((mapiter = keyVal.find(L"Identifier")) != keyVal.end())
            {
                // it has to succeed
	        KeyData kd = (*mapiter).second;
	        wsID = kd.GetString();
                return;
            }
            else
            {
                _ASSERTE(false);
                log(L"patchManager", Log::Error, L"Unable to retrieve the unique key");
=====================================================================
Found a 15 line (113 tokens) duplication in the following files: 
Starting at line 794 of D:\home\eCora_PM\PM\customPatch\CustomPatchMainDlg.cpp
Starting at line 823 of D:\home\eCora_PM\PM\customPatch\CustomPatchMainDlg.cpp

                m_table->setNumRows(num + 1);
                /*ESTableItem* item = new ESTableItem(m_table, QTableItem::Never, it->second->m_name);
                m_table->setItem(num, 0, item);*/
                ESTableItem* item = new ESTableItem(m_table, QTableItem::Never,
                    m_info->m_languages[(int)it->second->m_language]);
                m_table->setItem(num, 0, item);
                item = new ESTableItem(m_table, QTableItem::Never,
                    it->second->m_version);
                m_table->setItem(num, 1, item);
                QString desc = it->second->m_descr;
                desc = desc.replace('\n', ' ');
                m_table->setText(num, 2, desc);
                num++;
            }
        }
=====================================================================
Found a 47 line (113 tokens) duplication in the following files: 
Starting at line 89 of D:\home\eCora_PM\PM\alerts\monitor\module.cpp
Starting at line 212 of D:\home\eCora_PM\PM\pmServices\Module.cc

    return L"";
}

wstring
Module::name() const
{
    if (m_installed)
        return m_constants->shortProductName();
    else
        return m_name;
}

bool
Module::installed() const
{
    return m_installed;
}

wstring
Module::platform() const
{
    if (m_installed)
        return m_constants->platform();
    else
        return L"";
}

wstring
Module::fullName() const
{
    if (m_installed)
        return m_constants->longProductName();
    else
        return m_fullName;
}

wstring
Module::production() const
{
    if (m_installed)
        return m_constants->productionClass();
    else
        return L"";
}

wstring
Module::partner() const
=====================================================================
Found a 20 line (112 tokens) duplication in the following files: 
Starting at line 989 of D:\home\eCora_PM\PM\wmi\WmiCollector.cpp
Starting at line 1013 of D:\home\eCora_PM\PM\wmi\WmiCollector.cpp

            else if (dwType == (CIM_SINT64 | VT_ARRAY))
            {
                SAFEARRAY *pVec = pValue->parray;
                long iLBound, iUBound;
                BOOL bFirst = TRUE;

                SafeArrayGetLBound(pVec, 1, &iLBound);
                SafeArrayGetUBound(pVec, 1, &iUBound);
                int count = iUBound - iLBound + 1;
                if (count == 0) {
                    break;
                }

                dw->startArray(key.c_str(), count);
                for (long i = iLBound; i <= iUBound; i++)
                {
                    BSTR v = NULL;

                    SafeArrayGetElement(pVec, &i, &v);
                    sResult.Format(_T("%I64d"), _wtoi64(v));
=====================================================================
Found a 24 line (112 tokens) duplication in the following files: 
Starting at line 152 of D:\home\eCora_PM\PM\solarisActions\utils.cpp
Starting at line 153 of D:\home\eCora_PM\PM\utils\InputOutput.cc

mkpath(const wstring& p, int mode)
{
    wstring path = p;

    // strip off everything from the last '/'
    wstring::size_type idx = path.find_last_of(L"/\\");
    if (idx == wstring::npos)
    {
        throw GenericException(
            __FILE__, __LINE__, L"mkpath", p, L"Invalid argument");
    }

    // Also strip off any repeating '//' characters at the end
    while (idx >= 0 && (path[idx] == L'\\' || path[idx] == L'/'))
    {
        idx--;
    }

    path = path.substr(0, idx + 1);
    
    if (!isdir(path))
    {
        idx = path.find_last_of(L"/\\");
        if (idx == wstring::npos)
=====================================================================
Found a 15 line (112 tokens) duplication in the following files: 
Starting at line 233 of D:\home\eCora_PM\PM\registry\registry.cpp
Starting at line 324 of D:\home\eCora_PM\PM\registry\registry.cpp

            CRegOpenKeyEx rok(m_basekey->GetHKEY(), rootkey,
                0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);

	    if ((rc = RegQueryInfoKey(
	        rok.GetHKEY(), className, &maxClassSize, NULL,
	        &skeyCount, &skeyLength, NULL, &valCount,
	        &valLength, &dataLength, NULL, NULL)) != ERROR_SUCCESS)
	        throw WinErrorException(__FILE__, __LINE__, 
                L"RegQueryInfoKey", rc, rootkey);

	    if (dataLength > 4000)
	        dataLength = 4000;
	    EnumValue(currentKeyInfo, rok.GetHKEY(), valCount,
                valLength, dataLength, rootkey);
	    TCHAR keypath[MAX_REG_PATH];
=====================================================================
Found a 15 line (112 tokens) duplication in the following files: 
Starting at line 41 of D:\home\eCora_PM\PM\qt-utils\Conversions.cc
Starting at line 57 of D:\home\eCora_PM\PM\qt-utils\QtConversions.cc

            L"", L"Invalid QDateTime");
    }

    struct tm temp;

    temp.tm_year = t.date().year() - 1900;
    temp.tm_mon = t.date().month() - 1;
    temp.tm_mday = t.date().day();
    temp.tm_hour = t.time().hour();
    temp.tm_min = t.time().minute();
    temp.tm_sec = t.time().second();
    temp.tm_isdst = -1;

    return mktime(&temp);
}
=====================================================================
Found a 27 line (112 tokens) duplication in the following files: 
Starting at line 162 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\Solaris2Xml.cc
Starting at line 227 of D:\home\eCora_PM\PM\pmUnixPatchAnalyzer\Solaris2Xml.cc

        readInPatchData();

        m_productParent = m_idb->addRecord(L"products", NULL, attrNames, attrVals);
        createProductRecords();

        m_packageParent = m_idb->addRecord(L"packages", NULL, attrNames, attrVals);
        createPackageRecords();

        attrNames.push_back(L"version");
        attrNames.push_back(L"date");
        attrVals.push_back(m_xrefVersion);
        attrVals.push_back(m_xrefDate);

        m_idb->modifyRecord(L"/top", attrNames, attrVals);

        m_idb->closeDatabase();
        delete m_idb;
    }
    catch (DatabaseOp& e)
    {
        e.message();
    }
    catch (...)
    {
        throw;
    }
}
=====================================================================
Found a 20 line (112 tokens) duplication in the following files: 
Starting at line 1339 of D:\home\eCora_PM\PM\pmPush\LocalFactory.cpp
Starting at line 616 of D:\home\eCora_PM\PM\remoteModel\RemoteFactory.cpp

            L"systemscan.hostFK= '" + info.computerKey() + L"'";

        QSqlQuery query = m_dbManager->exec(queryStr);
        if (query.isActive() && query.first())
        {
            *sscanId = qs2ws(query.value(0).toString());
        }
        else
        {
            QSqlError err = query.lastError();
            wstring errStr = qs2ws(err.driverText() + " " + err.databaseText());
            int x = err.type();
            throw GenericException(__FILE__, __LINE__, L"LocalFactory::newWindowsPatch", L"",
                        L"Failed to obtain Windows systemscan ID: " + errStr);
        }
    }

    {
        wstring queryStr = L"SELECT "
            L"version.id, product.id "
=====================================================================
Found a 15 line (112 tokens) duplication in the following files: 
Starting at line 568 of D:\home\eCora_PM\PM\pmDaoDbImpl\DaoDbImplUnitTest.h
Starting at line 732 of D:\home\eCora_PM\PM\pmDaoDbImpl\DaoDbImplUnitTest.h

    void recursivelyLoadSystemObjectGraph(pmDaoInterfaces::ISystem* iSystem)
    {
        bool moreSystems = iSystem->first();
        while (moreSystems)
        {
            wstring scanId = iSystem->getScanId();
            wstring systemScanId = iSystem->getSystemScanId();
            wstring systemId = iSystem->getSystemId();
            wstring computerName = iSystem->getName();
            wstring ipAddress = iSystem->getIpAddress();
            wstring os = iSystem->getOs();
            wstring osVersionId = iSystem->getOsVersionId();
            wstring osLanguage = iSystem->getOsLanguage();
            wstring status = iSystem->getStatus();
            int isServer = iSystem->getServer();
=====================================================================
Found a 21 line (112 tokens) duplication in the following files: 
Starting at line 979 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 1040 of D:\home\eCora_PM\PM\scanScheduling\TaskManager.cpp

    CComQIPtr<com::IAppDatabase> pAppDatabase(appServices());
    _IfNullPtrRet(pAppDatabase);

    // systems container
    CComPtr<com::IDbContainer> pDbContainer;
    HRESULT hr = pAppDatabase->getDbContainer(&pDbContainer);
    _IfFailHrRet(hr);

    // load systems
    if (!groupsNode.isNull())
    {
        // register container for groups
        hr = pDbContainer->registerObjectType((IUnknown*)&idb::GroupObject());
        _IfFailHrRet(hr);

        QDomElement element = groupsNode.firstChild().toElement();
        while (!element.isNull())
        {
            QString qsKey = element.attributeNode(GroupID).value();
            if (qsKey.length())
            {
=====================================================================
Found a 39 line (112 tokens) duplication in the following files: 
Starting at line 602 of D:\home\eCora_PM\PM\pmAnalysisWinProvider\Constants.cpp
Starting at line 119 of D:\home\eCora_PM\PM\pmCollectorWinProvider\Constants.cpp

	return L"JPN";
    case 1053:
	return L"SVE";
    case 1044:
	return L"NOR";
    case 2068:
	return L"NON";
    case 1035:
	return L"FIN";
    case 2060:
	return L"FRB";
    case 3084:
	return L"FRC";
    case 1036:
	return L"FRA";
    case 5132:
	return L"FRL";
    case 6156:
	return L"FRM";
    case 4108:
	return L"FRS";
    case 2067:
	return L"NLB";
    case 1043:
	return L"NLD";
    case 1030:
	return L"DAN";
    case 1040:
	return L"ITA";
    case 2064:
	return L"ITS";
    case 1046:
	return L"PTB";
    case 2070:
	return L"PTG";
    case 1048:
	return L"ROM";
    default:
	return UNKNOWN_LANGUAGE() + L" - " + int2wstring(value);
=====================================================================
Found a 15 line (112 tokens) duplication in the following files: 
Starting at line 2429 of D:\home\eCora_PM\PM\pmAnalysisWinProvider\AnalyzeOffice.cpp
Starting at line 2674 of D:\home\eCora_PM\PM\pmAnalysisWinProvider\AnalyzeOffice.cpp

    wstring regLocation = L"SOFTWARE\\Microsoft\\Office\\14.0\\Common\\FilesPaths";

    int flag = 0;
    if (m_pWinScanHost->systemEx()->getOS().find(L"x64") != string::npos)
        flag = KEY_WOW64_32KEY;
    else
        flag = KEY_WOW64_64KEY;
	    
    wstring location = readRegKey(regLocation, L"mso.dll", (flag == KEY_WOW64_32KEY));
	int pos = location.find(Constants::DIRDELIMITER_LOCAL_ACCESS());
    assert(pos != wstring::npos);
    location.replace(pos, 1, Constants::DIRDELIMITER_REMOTE_ACCESS());

	wstring wsInstallRootPath = m_pWinScanHost->keySearchEx() + location;
    CheckRegFile().GetFileVersion(wsInstallRootPath, spVersion);
=====================================================================
Found a 28 line (112 tokens) duplication in the following files: 
Starting at line 351 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h
Starting at line 574 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h

    void testRmDirFails()
    {
        // scenario:
        // 1. add file to repository
        // 2. remove it as directory
        // 3. catch an exception
        // 4. remove this file from repository
        TS_ASSERT_THROWS_NOTHING(load());

        WindowsStorage storage(m_resources[WindowsStoragePath], g_App->services());

        // make sure environment set up for test
        try
        {
            storage.connect();
            if (!storage.exists())
                storage.create();
        }
        catch (GenericException&)
        {
            TS_FAIL("Couldn't set up environment for test.");
        }


        fs::FileSystem* fs = g_App->appServices()->disk()->systemHome();
        wstring fileName = L"testsettings.xml";
        wstring fullName = fs->fullPath (fileName);
        TS_ASSERT_THROWS_NOTHING(storage.addFile (fullName, fileName, 0, 0));
=====================================================================
Found a 13 line (112 tokens) duplication in the following files: 
Starting at line 130 of D:\home\eCora_PM\PM\patchManager\PatchTabBuilder.cpp
Starting at line 168 of D:\home\eCora_PM\PM\patchManager\PatchTabBuilder.cpp

    m_listview->addColumn(QObject::tr("Compliance"), 150);
    m_listview->addColumn(QObject::tr("Status"), 100);
    m_listview->addColumn(QObject::tr("Packages"), 100);
    m_listview->addColumn(QObject::tr("System Name"), 100);
    m_listview->addColumn(QObject::tr("OS Version"), 100);
    m_listview->addColumn(QObject::tr("App Architecture"), 100);
    m_listview->addColumn(QObject::tr("Kernel Architecture"), 100);

    m_listview->setColumnAlignment(5, Qt::AlignCenter);

    m_listview->setAllColumnsShowFocus(TRUE);
    m_listview->setShowSortIndicator(TRUE);
}
=====================================================================
Found a 18 line (112 tokens) duplication in the following files: 
Starting at line 120 of D:\home\eCora_PM\PM\patchManager\PatchMeisterLicense.cc
Starting at line 156 of D:\home\eCora_PM\PM\patchManager\PatchMeisterLicense.cc

        bool ret = FetchDialog::update(
            g_App->appServices()->mw(),
            g_App->services(),
            g_App->appServices()->currentModule()->license());

        if (wasEmpty && !g_App->appServices()->currentModule()->license()->empty() &&
            g_App->appServices()->settings()->setting(Setting::ImplicitUpdateCheck) == L"true")
        {
            g_App->appServices()->network()->checkForUpdates(true);
        }
    }
    catch (...)
    {

        // BEGIN FIX BUG #18456

        wstring logmsg = qs2ws(QObject::tr("Unrecoverable error"));
        log(L"patchManagerLicense::updateLicense", Log::User, L"Unrecoverable error");
=====================================================================
Found a 19 line (112 tokens) duplication in the following files: 
Starting at line 146 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\persistent_mr.h
Starting at line 169 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\persistent_mr.h
Starting at line 225 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\persistent_mr.h

    virtual ~exec_request_MR();
    virtual int call(void);

    template <class Context>
    inline void XMLpersist(Context* ctx, const tstring& name, DOMElement* parent)
    {
        DOMElement* el = ctx->getElement(parent, name);
        ecora::xmlutils::XMLpersist<Context>(ctx,
            dynamic_cast<afw::Persistent_Method_Request&>(*this),
            ACE_TEXT("Base"), el);
        ecora::xmlutils::XMLpersist(ctx, m_jr, ACE_TEXT("JobRequest"), el);
    }

  private:
    CJobReq m_jr;
    ACE_Future<afw::CResult> m_res;
};

class handle_exit_MR : public afw::Persistent_Method_Request
=====================================================================
Found a 18 line (111 tokens) duplication in the following files: 
Starting at line 59 of D:\home\eCora_PM\PM\pmPush\Db2Device.cpp
Starting at line 165 of D:\home\eCora_PM\PM\pmPush\Db2Device.cpp

    com::IAppDatabase* pDb = 0;
    HRESULT hr = iapp->QueryInterface(IID_IAppDatabase, (void**)&pDb);
    if (!SUCCEEDED(hr))
    {
        throw GenericException(__FILE__, __LINE__, L"Action::populateDevice", L"",
                L"Could not get database interface.");
    }

    com::IDbContainer* pDbContainer = 0;
    hr = pDb->getMtDbContainer(&pDbContainer);
    if (!SUCCEEDED(hr))
    {
        throw GenericException(__FILE__, __LINE__, L"Action::populateDevice", L"",
                L"Could not get database container interface.");
    }
    pDb->Release();

    hr = pDbContainer->registerObjectType((IUnknown*)&idb::UnixDevice());
=====================================================================
Found a 17 line (111 tokens) duplication in the following files: 
Starting at line 154 of D:\home\eCora_PM\PM\network\TerminalConnection.cpp
Starting at line 544 of D:\home\eCora_PM\PM\unix-collector\UnixConnection.cc

   if (m_osText == "Linux")
       m_host->send("/bin/su -\n");
   else
       m_host->send("/usr/bin/su -\n");
 
    // Various ways of prompting for a password:
    vector<pair<bstring, int> > possible;
    possible.push_back(pair<bstring, int>("word:", PASSWORD));
    possible.push_back(pair<bstring, int>("WORD:", PASSWORD));
    possible.push_back(pair<bstring, int>("phrase:", PASSWORD));
    possible.push_back(pair<bstring, int>("PHRASE:", PASSWORD));
    
    try
    { 
        if (m_host->match(possible) == PASSWORD)
        { 
            m_host->send(ws2utf8s(m_device->rootPassword()) + '\n');
=====================================================================
Found a 32 line (111 tokens) duplication in the following files: 
Starting at line 97 of D:\home\eCora_PM\PM\gist\gist_file.cc
Starting at line 145 of D:\home\eCora_PM\PM\gist\gist_file.cc

    fileHandle = ::_wopen(filename, O_BINARY | O_RDWR | O_CREAT | O_TRUNC,
        S_IREAD | S_IWRITE);
#else
    fileHandle = ::open(filename, O_RDWR | O_CREAT | O_TRUNC,
        S_IREAD | S_IWRITE);
#endif

    if (fileHandle < 0)
        return (fileHandle);  // error: couldn't create

    isOpen = true;

    // page 0 contains header info: magic string,
    // extension ID and name
    header.magicStr = strdup(magic);
    header.extId = ext->myId;
    header.freeList = 0;
    header.extName = strdup(ext->myName);
    W_DO(_write_header());
    fileSize = 1;

    // re-initialize the page descriptors to get rid off remnants from 
    // prior index file
    _resetDescrs();
    htab.reset();

    return RCOK;
}
// End Bug #2383

rc_t
gist_file::open(const char *filename, gist_ext_t*& ext)
=====================================================================
Found a 27 line (111 tokens) duplication in the following files: 
Starting at line 419 of D:\home\eCora_PM\PM\NetDiscover\WindowsComputerInfo.cpp
Starting at line 235 of D:\home\eCora_PM\PM\patchRepository\WindowsStorage.cpp

    DWORD dwResult = WNetAddConnection2(&nr, wsPassword.c_str(), wsUserName.c_str(), false);
    if (NO_ERROR != dwResult)
    {
        PTSTR MessageBuffer;
        DWORD dwBufferLength;

        if (dwBufferLength = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_IGNORE_INSERTS |
            FORMAT_MESSAGE_FROM_SYSTEM,
            0,
            dwResult,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            reinterpret_cast<PTSTR>(&MessageBuffer),
            0,
            0))
        {
	    wsError = MessageBuffer;
	    int size = wsError.size();
	    if (size >= 2 &&
	        wsError[size - 2] == L'\r' &&
	        wsError[size - 1] == L'\n')
	        wsError.resize(size - 2);

            // Free the buffer allocated by the system.
            LocalFree(MessageBuffer);
        }
=====================================================================
Found a 22 line (110 tokens) duplication in the following files: 
Starting at line 207 of D:\home\eCora_PM\PM\pmAgentManagement\ScheduleAgentScan.cpp
Starting at line 68 of D:\home\eCora_PM\PM\pmAgentManagement\ScheduleAgentScanEx.cpp

ScheduleAgentScanEx::help()
{
    com::IGui* iGui = 0;
    m_app->QueryInterface(IID_IGui, (void**)&iGui);

    if (!iGui)
    {
        QMessageBox::critical(this, tr("Help Error"), tr("Could not display help!"), QObject::tr("&OK"), QObject::tr("&No"));
        return;
    }

    ui::help::InlineHelp tips;
    if (check_pmAgentManagement_InlineHelpVar())
    {
        tips.loadDataF(g_pmAgentManagement_inlineHelp);
    }

    iGui->showHelp(tips.helpTopic(m_helpTopic));
    iGui->Release();
}

void
=====================================================================
Found a 24 line (110 tokens) duplication in the following files: 
Starting at line 91 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h
Starting at line 188 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h

    void testDisconnectWithCredentials()
    {
        TS_ASSERT_THROWS_NOTHING(load());
        WindowsRepositorySettings* repoSettings;
        // make sure environment set up for test
        try
        {
            repoSettings = new WindowsRepositorySettings(g_App->services(),
                m_resources[WindowsCredPath], m_resources[WindowsCredPath],
                L"windows", L"windows");

            repoSettings->setUsername(m_resources[WindowsCredUser]);
            repoSettings->setPassword(m_resources[WindowsCredPassword]);
            repoSettings->setCredentialsAvailable(true);
        }
        catch (GenericException&)
        {
            TS_FAIL("Couldn't set up environment for test.");
        }

        WindowsStorage storage(repoSettings, m_resources[WindowsCredPath],
            g_App->services(), true);

        TS_ASSERT_THROWS_NOTHING(storage.connect());
=====================================================================
Found a 24 line (110 tokens) duplication in the following files: 
Starting at line 158 of D:\home\eCora_PM\PM\patchManager\CommandLine.cpp
Starting at line 158 of D:\home\eCora_PM\PM\pmOAService\CommandLine.cpp

            case 'u': //updates
            {
                m_mode = MODE_UPDATE;
                if (!options.optarg())
                {
                    log(L"checkOptions", Log::Error, L"Invalid argument for patch database update");
                    throw GenericException(__FILE__, __LINE__, L"CommandLine::CommandLine", L"",
                        L"Invalid argument for patch database update");
                }

                m_topic = options.optarg();

                if (0 != m_topic.compare(L"check") &&
                    0 != m_topic.compare(L"download") &&
                    0 != m_topic.compare(L"install"))
                {
                    log(L"checkOptions", Log::Error, L"Invalid argument for patch database update");
                    throw GenericException(__FILE__, __LINE__, L"CommandLine::CommandLine", L"",
                        L"Invalid argument for patch database update");
                }
                break;
            }

            case 'b': // batch
=====================================================================
Found a 51 line (110 tokens) duplication in the following files: 
Starting at line 38 of D:\home\eCora_PM\PM\network\SftpConnection.h
Starting at line 38 of D:\home\eCora_PM\PM\network\network\SftpConnection.h

using namespace smuggle;

namespace network {

class SftpConnection : public FileTransferConnection
{    
  public:
    SftpConnection();
    ~SftpConnection();

    /*
     * Public method for making a connection, logging in, and passing
     * arguments (such as port number "-P portNumber" or -2 to force SSH
     * version 2 etc.).
     */
    void connect(const LoginParameters*const device);
    
    void put(const wstring& localFilename, const wstring& remoteFilename);
    void get(const wstring& remoteFilename, const wstring& localFilename);

    /*
     * Method will quit the current connection.
     */
    void quit();
    
  private:
    bstring m_prompt;

    /*
     * Execute the command passed and check for valid status.  An
     *  exception is thrown if the command did not execute
     *  properly.
     * @param command to be executed
     * @param time to wait while looking for a prompt.
     * @return the response from the remote ftp server.
     */
    wstring executeCommand(wstring command, int timeout);

    //  Check for a valid connection.  If not throw NoConnectionError..
    void checkConnection(wstring calledBy);

    // Read the buffer until you see a prompt.  Return the content
    // of the buffer.  Log if you get a timeout (Should we throw
    // an exception here?  J.M.
    bstring getData(int timeout);

};

SftpConnection* establishSftpConnection(const LoginParameters*const device);

} //  namespace network 
=====================================================================
Found a 15 line (110 tokens) duplication in the following files: 
Starting at line 333 of D:\home\eCora_PM\PM\daoXmlImpl\XmlDaoBase.cpp
Starting at line 355 of D:\home\eCora_PM\PM\daoXmlImpl\XmlDaoBase.cpp

XmlDaoBase::processSelectNotEqualCondition(const daoBase::XmlMetaElement& metaElem,
     const daoBase::CriteriaBase* criteria, const QDomElement& entity, EntityList* resEntities)
{
    assert(!metaElem.getAttribute().empty());
    assert(resEntities);

    EntityList entitiesWithName;
    entitiesByName(metaElem.getName(), entity, &entitiesWithName);

    EntityList::iterator entityWithNameIt = entitiesWithName.begin();
    for (; entityWithNameIt != entitiesWithName.end(); ++entityWithNameIt)
    {
        QDomElement attrElem = entityWithNameIt->namedItem(ws2qs(metaElem.getAttribute())).toElement();

        if (attrElem.isNull() || qs2ws(attrElem.text()) != metaElem.getValue())
=====================================================================
Found a 13 line (110 tokens) duplication in the following files: 
Starting at line 716 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\JobMan.cpp
Starting at line 766 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\JobMan.cpp

        cache_path += ACE_TEXT('/');

        tstring work_dir = jr.workdir().c_str();
        std::replace(work_dir.begin(), work_dir.end(), ACE_TEXT('\\'), ACE_TEXT('/'));
        
        size_t sz = work_dir.size();
        tstring::size_type pos = work_dir.find_last_of(ACE_TEXT('/'));
        if (tstring::npos != pos)
        {
            work_dir = work_dir.substr(pos, sz);
            work_dir = StringUtils::trimLeft(work_dir, ECORA_TEXT("\\/\""));
        }
        cache_path +=  work_dir;
=====================================================================
Found a 15 line (109 tokens) duplication in the following files: 
Starting at line 302 of D:\home\eCora_PM\PM\utils\InputOutput.cc
Starting at line 329 of D:\home\eCora_PM\PM\utils\InputOutput.cc

    else
    {
        auto_ptr<char> data(new char[buf.st_size + 1]);
        memset(data.get(), 0, buf.st_size + 1);
        FILE* fd = _wfopen(file.c_str(), L"rb");
        if (data.get() == 0)
            throw GenericException(__FILE__, __LINE__, L"file2wstring", L"",
                                   L"Out of memory");
        if (fd == 0)
            return;
        else
        {
            fread(data.get(), 1, buf.st_size, fd);
            fclose(fd);
            content = utf8string(data.get());
=====================================================================
Found a 26 line (109 tokens) duplication in the following files: 
Starting at line 485 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h
Starting at line 543 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h

    void testRmDir()
    {
        TS_ASSERT_THROWS_NOTHING(load());

        WindowsStorage storage(m_resources[WindowsStoragePath],
            g_App->services());

        // make sure environment set up for test
        try
        {
            storage.connect();
            if (!storage.exists())
                storage.create();
        }
        catch (GenericException&)
        {
            TS_FAIL("Couldn't set up environment for test.");
        }

        TS_ASSERT_THROWS_NOTHING(storage.mkDir(L"mkDirWorks"));

        WindowsStorage test(m_resources[WindowsStoragePath] +
            L"\\mkDirWorks", g_App->services());
        TS_ASSERT_EQUALS(test.exists(), true);

        TS_ASSERT_THROWS_NOTHING(storage.rmDirExc(L"mkDirWorks"));
=====================================================================
Found a 25 line (109 tokens) duplication in the following files: 
Starting at line 139 of D:\home\eCora_PM\PM\patchRepository\RepositoryUnitTest.h
Starting at line 76 of D:\home\eCora_PM\PM\patchRepository\RepositoryValidationManagerUnitTest.h

            setPassword(m_resources[WindowsRepositoryPassword]));
        TS_ASSERT_THROWS_NOTHING(repoSettings->
            setCredentialsAvailable(true));
        return repoSettings;
    }

    RepositoryManager* createWindowsRepository()
    {
        RepositoryManager* repoManager = new RepositoryManager(g_App->services());
        WindowsRepositorySettings* repoSettings = createWindowsRepositorySettings();
        vector<RepositorySettings*> repos;
        bool createRepositoryResult(true);
        wstring errorMsg(L"");

        TS_ASSERT(repoSettings);
        repos.push_back(repoSettings);

        TS_ASSERT_THROWS_NOTHING(
            createRepositoryResult = repoManager->
            createRepositories(repos, errorMsg, true));
        TS_ASSERT(createRepositoryResult);
        TS_ASSERT_EQUALS(errorMsg, L"");

        return repoManager;
    }
=====================================================================
Found a 29 line (109 tokens) duplication in the following files: 
Starting at line 71 of D:\home\eCora_PM\PM\daoDbImpl\DbDaoBase.h
Starting at line 62 of D:\home\eCora_PM\PM\daoXmlImpl\XmlDaoBase.h

    virtual void init();

    unsigned int count() const;

    bool next();
    bool prev();
    bool first();
    bool last();

    wstring getId() const;

    bool seek(const wstring& id);
    bool seek(daoBase::CriteriaBase* criteria);
    bool seek(int recordIdx);

    bool hasAttribute(const wstring& attrName);

    void setPersistent(bool persist);

    bool isPersistent() const;

    bool isEmpty() const;

    bool remove();

    void save();

    // performace improvement (memory allocation) - 2 - 
    void saveAdditionalInfo(vector<wstring>& sqlQueryList) { /* do nothing */ }
=====================================================================
Found a 11 line (109 tokens) duplication in the following files: 
Starting at line 527 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp
Starting at line 886 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp

        m_newPatch->m_regs[i] = cr;
        m_tableReg->setItem(num, 0,
            new ESTableItem(m_tableReg, QTableItem::Never, cr->m_registryKey));
        m_tableReg->setItem(num, 1,
            new ESTableItem(m_tableReg, QTableItem::Never, m_info->m_regTypes[cr->m_regType]));
        m_tableReg->setItem(num, 2,
            new ESTableItem(m_tableReg, QTableItem::Never, cr->m_value));
        QString data = cr->m_data;
        data = data.replace('\n', ' ');
        m_tableReg->setItem(num, 3,
            new ESTableItem(m_tableReg, QTableItem::Never, data));
=====================================================================
Found a 32 line (109 tokens) duplication in the following files: 
Starting at line 14 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Agentproto\agentproto.cpp
Starting at line 9 of D:\home\eCora_PM\PM\agent\agent\apps\Client\agentd\worker.cpp

class Signal_Handler: public ACE_Event_Handler
{
    ACE_Sig_Set m_sig_set;
  public:
    int open()
    {
        int rc = 0;
        //register the Signal Handler with the Reactor to handle
        //re-configuration signals
        //ACE_Reactor::instance()->register_handler(SIGWINCH, this);
        m_sig_set.sig_add(SIGINT);
        m_sig_set.sig_add(SIGQUIT);
        m_sig_set.sig_add(SIGTERM);

        // Register ourselves to receive signals so we can shut down
        // gracefully.
        rc = ACE_Reactor::instance()->register_handler(m_sig_set, this);
        ACE_ASSERT(rc == 0);
        return rc;
    }

    int handle_signal(int signum, siginfo_t*, ucontext_t*)
    {
        int rc = 0;
        switch (signum)
        {
            case SIGINT:
                //rc = ACE_Service_Config::reconfigure();
                ACE_ASSERT(rc == 0);
                break;
            case SIGQUIT:
            case SIGTERM:
=====================================================================
Found a 22 line (109 tokens) duplication in the following files: 
Starting at line 1766 of D:\home\eCora_PM\PM\agent\afCommon\WbemHelper.cpp
Starting at line 1393 of D:\home\eCora_PM\PM\wmi\WmiCollector.cpp

    if (pFrom == NULL || pdwAuthLevel == NULL || pdwImpLevel == NULL)
        return WBEM_E_INVALID_PARAMETER;

    IClientSecurity * pFromSec = NULL;
    SCODE sc = pFrom->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if (sc == S_OK)
    {
        DWORD dwAuthnSvc, dwAuthzSvc, dwCapabilities;
        sc = pFromSec->QueryBlanket(pFrom, &dwAuthnSvc, &dwAuthzSvc,
                                            NULL,
                                            pdwAuthLevel, pdwImpLevel,
                                            NULL, &dwCapabilities);

        // Special case of going to a win9x share level box

        if (sc == 0x800706d2)
        {
            *pdwAuthLevel = RPC_C_AUTHN_LEVEL_NONE;
            *pdwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
            sc = S_OK;
        }
        pFromSec->Release();
=====================================================================
Found a 25 line (109 tokens) duplication in the following files: 
Starting at line 81 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketClient.cpp
Starting at line 77 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketServer.cpp

CSocketServer::ReleaseSockets()
{
    CCriticalSection::Owner lock(m_listManipulationSection);
    Socket* pSocket = m_activeList.Head();

    while (pSocket)
    {
        Socket *pNext = SocketList::Next(pSocket);
        pSocket->Close();
        pSocket = pNext;
    }
        
    while (m_activeList.Head())
    {
        ReleaseSocket(m_activeList.Head());
    }

    while (m_freeList.Head())
    {
        DestroySocket(m_freeList.PopNode());
    }

    if (m_freeList.Count() + m_freeList.Count() != 0)
    {
        OnError(_T("CSocketServer::ReleaseSockets() - Leaked sockets"));
=====================================================================
Found a 18 line (108 tokens) duplication in the following files: 
Starting at line 775 of D:\home\eCora_PM\PM\wmi\WmiCollector.cpp
Starting at line 804 of D:\home\eCora_PM\PM\wmi\WmiCollector.cpp

    case VT_UI1 | VT_ARRAY:
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            int count = iUBound - iLBound + 1;
            if (count == 0) {
                break;
            }

            BYTE *pbstr;
            SafeArrayAccessData(pVec, (void HUGEP* FAR*)&pbstr);
            dw->startArray(key.c_str(), count);
            for (long i = iLBound; i <= iUBound; i++)
            {
=====================================================================
Found a 15 line (108 tokens) duplication in the following files: 
Starting at line 248 of D:\home\eCora_PM\PM\registry\registry.cpp
Starting at line 403 of D:\home\eCora_PM\PM\registry\registry.cpp

        memset(subKey.get(), 0, skeyLength + 1);
	_tcscpy(keypath, rootkey);

	for (DWORD i = 0, j = _tcslen(keypath); i < skeyCount; ++i)
	{
	    DWORD kLen = skeyLength + 1;
	    rc = RegEnumKeyEx(rok.GetHKEY(), i, subKey.get(), &kLen,
			      NULL, NULL, NULL, NULL);
	    if (rc == ERROR_SUCCESS ||
		rc == ERROR_INSUFFICIENT_BUFFER ||
		rc == ERROR_MORE_DATA)
	    {
		keypath[j] = '\0';
		_tcscat(keypath, L"\\");
		_tcscat(keypath, subKey.get());
=====================================================================
Found a 37 line (108 tokens) duplication in the following files: 
Starting at line 708 of D:\home\eCora_PM\PM\patchManager\SettingsDlg.cpp
Starting at line 739 of D:\home\eCora_PM\PM\patchManager\SettingsDlg.cpp

        }
    }
    catch (GenericException& e)
    {
        log(L"patchManager", Log::User, L"Error - SettingsDlg::accept: " + e.message());
        QMessageBox::warning(this, QObject::tr("Warning"), ws2qs(e.message()), QObject::tr("&OK"));
        return;
    }
    catch (...)
    {
        log(L"patchManager", Log::User, L"Error - SettingsDlg::accept - top level");
        QMessageBox::warning(this, QObject::tr("Warning"), tr("An error occured while saving the settings"),
                             QObject::tr("&OK"));
        return;
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Contraints
//
///////////////////////////////////////////////////////////////////////////

#define LogAndShowError()\
QString qsDisplayError = ws2qs(errorMessage);\
if (agentManagerDBChanged <= 3)\
{\
    QString qsError = QObject::tr("Changing database settings for Agent Manager failed. \n"\
                         "To use the optional agent feature, you must reinstall the Agent Manager.");\
    qsDisplayError.append(qsError);\
    errorMessage += qs2ws(qsError);\
}\
log(L"patchManager", Log::User, errorMessage);\
QMessageBox::warning(this, tr("Warning"), qsDisplayError, QObject::tr("&OK"));

void 
SettingsDlg::validateAMContraints(wstring* errorMessage, size_t* agentManagerDBChanged) throw()
=====================================================================
Found a 17 line (108 tokens) duplication in the following files: 
Starting at line 1381 of D:\home\eCora_PM\PM\patchManager\App.cpp
Starting at line 3755 of D:\home\eCora_PM\PM\patchManager\App.cpp

    if (!repoManager->windowsRepositoryExists())
    {
        wstring message = L"Please configure a repository.";
        QMessageBox::warning(this, QObject::tr("Warning"), 
            QObject::tr((ws2qs(message))), QObject::tr("&OK"));
        
        RepositorySettingsDlgQT rSettings(g_App, services());
        rSettings.exec();
        
        if (!repoManager->windowsRepositoryExists())
        {
            message = L"No Windows repository have been defined !";
            QMessageBox::information(this, QObject::tr("Info"),
                QObject::tr(ws2qs(message)), QObject::tr("&OK"), 0);
            return;
        }
    }
=====================================================================
Found a 23 line (108 tokens) duplication in the following files: 
Starting at line 649 of D:\home\eCora_PM\PM\idb\DbRelation.cpp
Starting at line 747 of D:\home\eCora_PM\PM\idb\DbRelation.cpp

            QString qsLeftClass = m_pCursor->value(AS_LEFTCLASS).toString();

            DbContainer* pObjContainer = m_objContainer.find(qsLeftClass);
            if (0 == pObjContainer)
            {
                pObjContainer = new DbContainer(m_pDataBase);
                pObjContainer->registerObjectType(qsLeftClass);
                m_objContainer.insert(qsLeftClass, pObjContainer);
            }

            com::IDbObject* pObject = m_pDataBase->getRegisteredObject(qsLeftClass)->clone(false);
            if (S_OK == pObjContainer->retrieveObject(qsLeftObject, pObject))
            {
                result.insert(iPos++, pObject);
            }
            else
            {
                delete pObject;
            }
        }
    }
    return S_OK;
}
=====================================================================
Found a 19 line (108 tokens) duplication in the following files: 
Starting at line 505 of D:\home\eCora_PM\PM\fs\main.cc
Starting at line 558 of D:\home\eCora_PM\PM\fs\main.cc

	ret = L"cp: needs at least two arguments\n";
	return ret;
    }
    
    dest = g_fs->simplify(commands.back(), g_cwd);
    commands.pop_back();

    dest_is_dir = g_fs->type(dest) == fs::FileSystem::Directory;

    list<wstring>::iterator it;
    for (it = commands.begin(); it != commands.end(); ++it)
    {
	wstring arg = g_fs->simplify(*it, g_cwd);
	args.push_back(arg);
    }

    if (args.size() > 1 && !dest_is_dir)
    {
	ret += L"cp: last argument must be a directory.";
=====================================================================
Found a 18 line (108 tokens) duplication in the following files: 
Starting at line 1069 of D:\home\eCora_PM\PM\customPatch\ExportWizard.cpp
Starting at line 868 of D:\home\eCora_PM\PM\customPatch\ImportWizard.cpp

bool ImportWizard::eventFilter(QObject *target, QEvent *e)
{
    if (m_table->numCols() == 1)
    {
        if (target->inherits("QCheckBox") && (e->type() == QEvent::KeyRelease)
            && (((QKeyEvent *)e)->key() == Qt::Key_Tab))
        {
            helpButton()->setFocus();
        }
    }
    else
    {
        if (target->inherits("QCheckBox") && (e->type() == QEvent::FocusOut))
        {
            helpButton()->setFocus();
        }
    }
    return ImportWizardDlgUI::eventFilter(target, e);
=====================================================================
Found a 23 line (108 tokens) duplication in the following files: 
Starting at line 1254 of D:\home\eCora_PM\PM\bzip2\bzip2.c
Starting at line 1419 of D:\home\eCora_PM\PM\bzip2\bzip2.c

                progName, inName, outName );
      /* just a warning, no return */
   }   
   if ( srcMode == SM_F2F && !forceOverwrite && fileExists ( outName ) ) {
      fprintf ( stderr, "%s: Output file %s already exists.\n",
                progName, outName );
      setExit(1);
      return;
   }
   if ( srcMode == SM_F2F && !forceOverwrite &&
        (n=countHardLinks ( inName ) ) > 0) {
      fprintf ( stderr, "%s: Input file %s has %d other link%s.\n",
                progName, inName, n, n > 1 ? "s" : "" );
      setExit(1);
      return;
   }

   switch ( srcMode ) {

      case SM_I2O:
         inStr = stdin;
         outStr = stdout;
         if ( isatty ( fileno ( stdin ) ) ) {
=====================================================================
Found a 9 line (108 tokens) duplication in the following files: 
Starting at line 204 of D:\home\eCora_PM\PM\alerts\monitor\pmPatchDbs.cpp
Starting at line 221 of D:\home\eCora_PM\PM\alerts\monitor\pmPatchDbs.cpp

    sqlQuery.exec(ws2qs(selectStmt));
    while (sqlQuery.next())
    {
        systems.push_back(qs2ws(sqlQuery.value(0).toString()));
        reasons.push_back(qs2ws(sqlQuery.value(1).toString()));
        ips.push_back(qs2ws(sqlQuery.value(2).toString()));
        domains.push_back(qs2ws(sqlQuery.value(3).toString()));
        ids.push_back(qs2ws(sqlQuery.value(4).toString()));
    }
=====================================================================
Found a 15 line (108 tokens) duplication in the following files: 
Starting at line 23 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\persistent_mr.h
Starting at line 47 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\persistent_mr.h

    virtual int call(void);

    template <class Context>
    inline void XMLpersist(Context* ctx, const tstring& name, DOMElement* parent)
    {
        DOMElement* el = ctx->getElement(parent, name);
        ecora::xmlutils::XMLpersist<Context>(ctx,
            dynamic_cast<afw::Persistent_Method_Request&>(*this),
            ACE_TEXT("Base"), el);
        ecora::xmlutils::XMLpersist(ctx, m_files, ACE_TEXT("Files"), el);
        ecora::xmlutils::XMLpersist(ctx, m_jr, ACE_TEXT("JobRequest"), el);
    }

  private:
    CJobReq m_jr;
=====================================================================
Found a 23 line (108 tokens) duplication in the following files: 
Starting at line 129 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\BaseSrv.cpp
Starting at line 32 of D:\home\eCora_PM\PM\agent\agent\apps\Client\Core\ComSrv.cpp

    ACE_DEBUG((LM_DEBUG, "(%t) CComSrvBase::svc() typeid: %s\n", typeid_name.c_str()));

    while (1)
    {
        if (m_activation_queue.is_empty() && (flags() & fSHUTDOWN) != 0)
        {
            ACE_DEBUG((LM_WARNING, "(%t) CBaseSrv::svc() tipeid %s "
                " activation queue is empty or shutdown\n", typeid_name.c_str()));
            break;
        }

        if (flags() & fSUSPEND)
        {
            ACE_DEBUG((LM_WARNING, "(%t) CBaseSrv::svc() typeid: %s "
                " activation queue suspend\n", typeid_name.c_str()));
            break;
        }

        ACE_Time_Value t = wait_time + ACE_OS::gettimeofday();
        ACE_Method_Request* mr = activation_dequeue(&t);    

        if (0 != mr)
        {
=====================================================================
Found a 18 line (108 tokens) duplication in the following files: 
Starting at line 787 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\CheckRequirements.cpp
Starting at line 624 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\HandleAccounts.cpp

        while (SUCCEEDED(ADsEnumerateNext(pEnum, 1, &var, &lFetch)) && 1 == lFetch)
        {
            if (pChild)
            {
                pChild->Release();
                pChild = NULL;
            }
            hr = V_DISPATCH(&var)->QueryInterface(IID_IADs, (void**)&pChild);
            if (SUCCEEDED(hr))
            {
                BSTR groupName;
                long lowerBound, upperBound;
                void HUGEP *pArray;

                hr = pChild->Get(L"objectSid", &varSid);
                if (FAILED(hr))
                {
                    GetADSIErrorMessage(hr, errorMsg);
=====================================================================
Found a 22 line (108 tokens) duplication in the following files: 
Starting at line 89 of D:\home\eCora_PM\PM\NetDiscover\DiscoverForm.ui.h
Starting at line 140 of D:\home\eCora_PM\PM\NetDiscover\DiscoverForm.ui.h
Starting at line 566 of D:\home\eCora_PM\PM\NetDiscover\DiscoverForm.ui.h

    QListViewItemIterator listIterator(ListViewIpRange);
    vector<QListViewItem*> removeVector;
    QListViewItem* pItemToHighlight = 0;
    while (listIterator.current())
    {
        if (listIterator.current()->isSelected())
        {
            removeVector.push_back(listIterator.current());
        }
        else
        {
            if (!pItemToHighlight && removeVector.size())
            {
                pItemToHighlight = listIterator.current();
            }
        }
        ++listIterator;
    }

    vector<QListViewItem*>::iterator iter;
    for (iter = removeVector.begin(); iter != removeVector.end(); ++iter)
    {
=====================================================================
Found a 24 line (107 tokens) duplication in the following files: 
Starting at line 740 of D:\home\eCora_PM\PM\winPushActions\DelayTaskAction.cpp
Starting at line 863 of D:\home\eCora_PM\PM\winPushActions\DelayTaskAction.cpp

    xml::Node* delayCommandData = new xml::Node(wsCommand);
    delayCommand->push_back(delayCommandData);

    xml::Node* delayWhen = new xml::Node(L"when");
    delayRoot->push_back(delayWhen);

    xml::Data* delayWhenData = new xml::Data(installTime); 
    delayWhen->push_back(delayWhenData);

    ecwofstream stackWos("dynamicJobData.xml");
    if (!stackWos) 
    {
        m_message = L"Failed to create dynamicJobData.xml";
        log(L"delayAgentTask", Log::Error, m_message);
        return false;
    }

    stackWos << L"<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n";
    delayDoc.write(stackWos);
    delayDoc.clear();
    //////////////////////////////////////////////////////////////////////////

    m_message = L"Success: " + taskName;
    log(L"scheduleForRebootAgent", Log::Info, m_message);
=====================================================================
Found a 26 line (107 tokens) duplication in the following files: 
Starting at line 31 of D:\home\eCora_PM\PM\patchRepository\RepositorySettings.cpp
Starting at line 62 of D:\home\eCora_PM\PM\patchRepository\RepositorySettings.cpp

    m_patchSystemType(patchSystemType),
    m_isNew(false),
    m_credentialsEntered(false)
{
    if (services)
    {
        services->QueryInterface(IID_ISettings, (void**)&m_pISettings);
        services->QueryInterface(IID_IEncryption, (void**)&m_encryption);

        if (!m_pISettings || !m_encryption)
        {
            wstring message = L"Unable to get repository settings.";
            throw GenericException(__FILE__, __LINE__, L"RepositorySettings", 
                                L"", message);
        }
    }
    else
    {
        wstring message = L"Unable to get repository settings - services not available.";
        throw GenericException(__FILE__, __LINE__, L"RepositorySettings", 
                                L"", message);
    }

}

RepositorySettings::RepositorySettings(IUnknown* services) :
=====================================================================
Found a 37 line (107 tokens) duplication in the following files: 
Starting at line 95 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.h
Starting at line 36 of D:\home\eCora_PM\PM\patchRepository\WinSolRepoSettings.h

class SolRepoSettings;

/**
 * Provides widget to edit repository settings from tab in settings dialog
 * WinSolRepoSettings replaces RepositorySettingsQT object that manipulated
 * both Windows and Solaris repository settings. WinSolRepoSettings holds 
 * keeps the interface of RepositorySettingsQT but holds two widgets 
 * (WinRepoSettings and SolRepoSettings) to enable to manipulate those 
 * settings separately
 */
class WinSolRepoSettings : public QWidget
{
    Q_OBJECT

  public:

    /**
     * Create a repository settings widget
     *
     * @param parent the parent widget
     */
    WinSolRepoSettings(QWidget* parent, IUnknown* services,
        QWidget* winWidget = 0, QWidget* solWidget = 0);
    WinSolRepoSettings(RepositorySettingsDlgQT* parent, IUnknown* services,
        QWidget* winWidget = 0, QWidget* solWidget = 0);
    ~WinSolRepoSettings();

    // initialize the settings in the widgets
    void init();
    void qtInit();
    // user clicks ok, so save settings
    bool save();
    // check that settings are valid
    bool checkValidity();
    void setServices(IUnknown* services) { m_services = services; }
    void dsnChanged();
    wstring getHostName(const wstring repType);
=====================================================================
Found a 22 line (107 tokens) duplication in the following files: 
Starting at line 404 of D:\home\eCora_PM\PM\patchManager\SettingsDlg.cpp
Starting at line 709 of D:\home\eCora_PM\PM\patchManager\SettingsDlg.cpp

    }
    catch (GenericException& e)
    {
        log(L"patchManager", Log::User, L"Error - SettingsDlg::accept: " + e.message());
        QMessageBox::warning(this, QObject::tr("Warning"), ws2qs(e.message()), QObject::tr("&OK"));
        return;
    }
    catch (...)
    {
        log(L"patchManager", Log::User, L"Error - SettingsDlg::accept - top level");
        QMessageBox::warning(this, QObject::tr("Warning"), tr("An error occured while saving the settings"),
                             QObject::tr("&OK"));
        return;
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Repository
//
///////////////////////////////////////////////////////////////////////////
void SettingsDlg::acceptRepository() throw()
=====================================================================
Found a 10 line (107 tokens) duplication in the following files: 
Starting at line 301 of D:\home\eCora_PM\PM\patchManager\DbVersionChecker.cpp
Starting at line 317 of D:\home\eCora_PM\PM\patchManager\DbVersionChecker.cpp

DbVersionChecker::versionGreaterEqual(wstring v1, wstring v2)
{
    int major1 = wstring2int(v1.substr(0, v1.find(L".")));
    int minor1 = wstring2int(v1.substr(v1.find(L".") + 1));
    int major2 = wstring2int(v2.substr(0, v2.find(L".")));
    int minor2 = wstring2int(v2.substr(v2.find(L".") + 1));

    if (major2 > major1)
	return true;
    if (major2 == major1 && (minor2 > minor1 || minor2 == minor1))
=====================================================================
Found a 10 line (107 tokens) duplication in the following files: 
Starting at line 73 of D:\home\eCora_PM\PM\network\PtyConnection.cpp
Starting at line 334 of D:\home\eCora_PM\PM\unix-collector\UnixConnection.cc

    possible.push_back(pair<bstring, int>("AME:", USER));
 
    // Various ways of prompting for a password:
    possible.push_back(pair<bstring, int>("word:", PASSWORD));
    possible.push_back(pair<bstring, int>("WORD:", PASSWORD));
    possible.push_back(pair<bstring, int>("phrase:", PASSWORD));
    possible.push_back(pair<bstring, int>("PHRASE:", PASSWORD));
    possible.push_back(pair<bstring, int>("passphrase", PASSWORD));

    possible.push_back(pair<bstring, int>("ogin incorr", FAILURE));
=====================================================================
Found a 29 line (107 tokens) duplication in the following files: 
Starting at line 58 of D:\home\eCora_PM\PM\alerts\monitor\directory.cpp
Starting at line 259 of D:\home\eCora_PM\PM\alerts\upgrade\main.cpp

wstring installationDirectory()
{
    // Return installation directory
    wstring keyName = baseRegistryKeyName();

    wstring value;
    try 
    {
	getKeyValue(HKEY_LOCAL_MACHINE, keyName, L"InstallationPath", value);
    }
    catch (GenericException&)
    {
	value = L"c:\\";
	return value;
	//throw GenericException(
	    //__FILE__, __LINE__, L"WindowsOS::installationDirectory", L"",
	    //L"Could not find installation directory in the registry. "
	    //L"Please re-run the setup program.");
    }

    wstring::size_type index;
    while ((index = value.find(L'\\')) != wstring::npos)
	value[index] = L'/';
    
    if (value[value.size() - 1] == L'/')
	value = value.substr(0, value.size() - 1);

    return value;
}
=====================================================================
Found a 25 line (107 tokens) duplication in the following files: 
Starting at line 163 of D:\home\eCora_PM\PM\agentInstaller\SmsInstaller.cpp
Starting at line 94 of D:\home\eCora_PM\PM\winAnalyzer\SmsAnalyzer.cpp

	assert(bSeek);

	iProductDest->getPatches()->copyAll(iProductSource->getPatches(), true);

        moreProducts = iProductDest->next();
    }

    daoBase::IGenericDao* genericDao = iDaoFactoryDest->getIGenericDao();
    genericDao->setDaoId(L"IAction");

    daoBase::CriteriaBase allActionsCriteria(L"AllActions");
    genericDao->load(&allActionsCriteria);
    genericDao->clear();

    // set the window system extension node as persistent
    iScanDest->getSystem()->getWindowsSystemExtension()->setPersistent(true);

    // change the job type into patch analysis
    iScanDest->setType(pmServices::ScanResources::patchAnalysisJobType());

    // save the new content as input for Patch Analysis module
    iScanDest->save();
}

void
=====================================================================
Found a 19 line (106 tokens) duplication in the following files: 
Starting at line 74 of D:\home\eCora_PM\PM\winPushActions\AppendToFileAction.cpp
Starting at line 72 of D:\home\eCora_PM\PM\winPushActions\CreateFileAction.cpp

        if (!WriteFile(hFile, ws2utf8s(text).c_str(), ws2utf8s(text).size(), &numWritten, 0))
        {
            m_message = L"Failed: " + fileName + L": " + 
                windowsUtils::formatMsg(GetLastError());
            return onFail(env);
        }
        if (!CloseHandle(hFile))
        {
            m_message = L"Failed: " + fileName + L": " + 
                windowsUtils::formatMsg(GetLastError());
            return onFail(env);
        } 
    }
    m_message = L"Success: " + fileName;

    return onSuccess(env);
}

actionsInterpreter::ActionResult
=====================================================================
Found a 22 line (106 tokens) duplication in the following files: 
Starting at line 1447 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 1390 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

    if (!g_App->isArchiveMode() && !g_App->isPurgeMode())
    {
        log(L"patchManager", Log::Debug, L"unloadScans() works (GUI mode)");
        bool unloadedScans = false;
        /*GUI mode*/
        vector<wstring>::iterator it = wsScanIds.begin();
        for (; it != wsScanIds.end(); it++)
        {
            if (g_App->isScanLoaded(*it))
            {
                inGuiThread(intercept::memberFunction(*g_App, &ApplicationWindow::unloadScan, *it));
                unloadedScans = true;
            }
        }

        if (unloadedScans)
        {
            g_App->unloadScanPostOp();
        }
    }

    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::unloadScans, exiting");
=====================================================================
Found a 23 line (106 tokens) duplication in the following files: 
Starting at line 512 of D:\home\eCora_PM\PM\daoXmlImpl\XmlDaoBase.cpp
Starting at line 305 of D:\home\eCora_PM\PM\pmDaoXmlImpl\XmlDaoBase.cpp

    m_entities.push_back(newEntity);

    m_crtEntity = m_entities.end();
    --m_crtEntity;

    return newEntity;
}

void
XmlDaoBase::addRelatedEntity(QDomElement& relEntity, const wstring& daoId)
{
    wstring relEntContainerTagName = getRelEntContainerTagName(daoId);
    if (relEntContainerTagName == qs2ws(relEntity.tagName()))
    {
        assert(m_crtEntity != m_entities.end());
        m_crtEntity->appendChild(relEntity);

        return;
    }

    QDomElement relEntityContainer = m_crtEntity->namedItem(ws2qs(relEntContainerTagName)).toElement();
    if (relEntityContainer.isNull())
    {
=====================================================================
Found a 12 line (106 tokens) duplication in the following files: 
Starting at line 122 of D:\home\eCora_PM\PM\customPatch\ExportWizard.cpp
Starting at line 70 of D:\home\eCora_PM\PM\customPatch\ImportWizard.cpp

    setNextEnabled(page(0), false); // BUG FIX #25588 by Yug
    connect(m_listTree, SIGNAL(spacePressed(QListViewItem *)),
        this, SLOT(onItemClick(QListViewItem *)));
    connect(m_listTree, SIGNAL(pressed(QListViewItem *)),
        this, SLOT(onItemClick(QListViewItem *)));
    connect(m_listTree, SIGNAL(selectionChanged(QListViewItem *)),
        this, SLOT(onItemClick(QListViewItem *)));
    connect(m_table, SIGNAL(valueChanged(int, int)),
        this, SLOT(onValueChanged(int, int)));
}

void ImportWizard::keyPressEvent(QKeyEvent * e)
=====================================================================
Found a 25 line (106 tokens) duplication in the following files: 
Starting at line 90 of D:\home\eCora_PM\PM\agent\agent\Library\Common\CommandLine.cpp
Starting at line 94 of D:\home\eCora_PM\PM\agent\agent\Library\PsExecLib\CommandLine.cpp

    return _T("");
}


void CommandLine::setParam(const tstring& key, const tstring& value)
{
    ParamPair pair(key, value);

    if (!pair.first.empty())
        m_cont.push_back(pair);
}


tstring CommandLine::asString()
{
    tstring res;
    if (!m_prname.empty())
        res = m_prname;

    ParamCont::const_iterator ci = m_cont.begin();
    ParamCont::const_iterator end = m_cont.end();

    for (; ci != end; ++ci)
    {
        res += _T(" ");
=====================================================================
Found a 16 line (105 tokens) duplication in the following files: 
Starting at line 65 of D:\home\eCora_PM\PM\policyManager\PolicyDisplayQT.cpp
Starting at line 130 of D:\home\eCora_PM\PM\policyManager\PolicyDisplayQT.cpp

    m_listView->clear();
    // load the policies from the disk
    m_pm->loadPolicy();

    // populate the list view
    PolicyManager::POLICYLIST::iterator it = m_pm->m_policyList.begin();
    for (; it != m_pm->m_policyList.end(); ++it)
    {
	QPolicyListItem* item = new QPolicyListItem(m_listView, 
	    (*it).second->name(), (*it).second->description(),
	    (*it).second->policyId());

	item->setPixmap(0, *m_pm->policyPixmap());

	m_listView->insertItem(item);
    }
=====================================================================
Found a 28 line (105 tokens) duplication in the following files: 
Starting at line 535 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\UnixComputer.cpp
Starting at line 852 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\UnixComputer.cpp

    sd.write(wos);

    try
    {

#ifdef _DEBUG
        wstring dumpFileName =  L"pushactions.xml";

        wofstream dumpFile;
        dumpFile.open(ws2utf8s(dumpFileName).c_str(), (ios::in | ios::out | ios::trunc));

        if (dumpFile.is_open())
            actionSeqDoc.write(dumpFile);
#endif
        actionsInterpreter()->loadActionSequence(actionSeqDoc);
    }
    catch (GenericException& e)
    {
        wstring message = L"Failed to create push actions: " + e.message();
        setStatus(pmPushBaseModel::IComputer::PushFailure, message);
        return 0;
    }

    return id; // the number of push actions
}

void
UnixComputer::setTransferOnly(bool b)
=====================================================================
Found a 16 line (105 tokens) duplication in the following files: 
Starting at line 129 of D:\home\eCora_PM\PM\patchRepository\ValidationManager.cpp
Starting at line 204 of D:\home\eCora_PM\PM\patchRepository\ValidationManager.cpp

ValidationManager::validateSize(Patch* patch)
{
    bool valid = false;
    try
    {
	if (!m_storage->isConnectionAlive())
	    m_storage->connect();

        vector<PatchLocation*>& locs = patch->getLocations();
	bool anyInvalid = (locs.size() > 0 ? false : true);
	for (int i = 0; i < locs.size(); ++i)
	{
	    wstring relFile = patch->relativePath() + L"/" + locs[i]->filename();

	    // not necessarily a size in database for every patch
	    if (locs[i]->size() == 0)
=====================================================================
Found a 26 line (105 tokens) duplication in the following files: 
Starting at line 31 of D:\home\eCora_PM\PM\patchRepository\RepositorySettings.cpp
Starting at line 88 of D:\home\eCora_PM\PM\patchRepository\RepositorySettings.cpp

    m_enabled(true),
    m_isNew(false),
    m_credentialsEntered(false)
{
    if (services)
    {
        services->QueryInterface(IID_ISettings, (void**)&m_pISettings);
        services->QueryInterface(IID_IEncryption, (void**)&m_encryption);

        if (!m_pISettings || !m_encryption)
        {
            wstring message = L"Unable to get repository settings.";
            throw GenericException(__FILE__, __LINE__, L"RepositorySettings", 
                                L"", message);
        }
    }
    else
    {
        wstring message = L"Unable to get repository settings - services not available.";
        throw GenericException(__FILE__, __LINE__, L"RepositorySettings", 
                                L"", message);
    }

}

RepositorySettings::~RepositorySettings()
=====================================================================
Found a 23 line (105 tokens) duplication in the following files: 
Starting at line 608 of D:\home\eCora_PM\PM\idb\DbRelation.cpp
Starting at line 703 of D:\home\eCora_PM\PM\idb\DbRelation.cpp

            QString qsRightClass = m_pCursor->value(AS_RIGHTCLASS).toString();

            DbContainer* pObjContainer = m_objContainer.find(qsRightClass);
            if (0 == pObjContainer)
            {
                pObjContainer = new DbContainer(m_pDataBase);
                pObjContainer->registerObjectType(qsRightClass);
                m_objContainer.insert(qsRightClass, pObjContainer);
            }

            com::IDbObject* pObject = m_pDataBase->getRegisteredObject(qsRightClass)->clone(false);
            if (S_OK == pObjContainer->retrieveObject(qsRightObject, pObject))
            {
                result.insert(iPos++, pObject);
            }
            else
            {
                delete pObject;
            }
        }
    }

    {
=====================================================================
Found a 17 line (105 tokens) duplication in the following files: 
Starting at line 724 of D:\home\eCora_PM\PM\hostManager\ObjectView.cpp
Starting at line 781 of D:\home\eCora_PM\PM\hostManager\ObjectView.cpp

    for (idx = 0; idx < iSelections; ++idx)
    { 
        QTableSelection selection = EsDataTableObject->selection(idx);

        iTopRow = selection.topRow();
        iBottomRow = selection.bottomRow();

        for (int iter = iTopRow; iter <= iBottomRow; ++iter)
        { 
            // get device key
            if (deviceCursor->seek(iter))
            { 
                QString qsKey = deviceCursor->value(0).toString();
                //extract device key
                TDevice device(m_pServices);
                HRESULT hr = m_pDbContainer->retrieveObject(qsKey, (IUnknown*)&device);
                _IfFailHrRet(hr);
=====================================================================
Found a 8 line (105 tokens) duplication in the following files: 
Starting at line 198 of D:\home\eCora_PM\PM\fksec\main.cpp
Starting at line 215 of D:\home\eCora_PM\PM\fksec\main.cpp

	out << _T( "after normalize(), canonicalize(): " ) << al0 << std::endl;

	ac0.SetMask( 0x01 ); al0.AddAce( 0, (const void *) ac0 );
	ac0.SetMask( 0x02 ); al0.AddAce( 0, ac0 );
	al0.AddAce( 0, ACCESS_ALLOWED_ACE_TYPE, 0, 0, 0x04, (PSID) guest );
	al0.AddAce( 0, ACCESS_DENIED_ACE_TYPE, 0, 0, 0x08, GUEST );
	al0.AddAce( 0, SYSTEM_AUDIT_ACE_TYPE, 0, 0, 0x10, guest );
	al0.canonicalize();
=====================================================================
Found a 8 line (105 tokens) duplication in the following files: 
Starting at line 190 of D:\home\eCora_PM\PM\fksec\main.cpp
Starting at line 206 of D:\home\eCora_PM\PM\fksec\main.cpp

	out << _T( "after canonicalize(): " ) << al0 << std::endl;

	ac0.SetMask( 0x01 ); al0.AddAce( 0, (const void *) ac0 );
	ac0.SetMask( 0x02 ); al0.AddAce( 0, ac0 );
	al0.AddAce( 0, ACCESS_ALLOWED_ACE_TYPE, 0, 0, 0x04, (PSID) guest );
	al0.AddAce( 0, ACCESS_DENIED_ACE_TYPE, 0, 0, 0x08, GUEST );
	al0.AddAce( 0, SYSTEM_AUDIT_ACE_TYPE, 0, 0, 0x10, guest );
	al0.normalize();
=====================================================================
Found a 12 line (105 tokens) duplication in the following files: 
Starting at line 595 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\CheckRequirements.cpp
Starting at line 138 of D:\home\eCora_PM\PM\_RC\ReportingCenter\ReportingCenter\EcoraRCSetup\NewSetupActions\HandleIIS.cpp

            memset((void*)&scriptMap, 0, sizeof(scriptMap));
            if (tmpBuf == NULL || ((SysStringLen(V_BSTR(&varItem)) + 1) * sizeof(WCHAR)) > LocalSize(tmpBuf))
            {
                if (tmpBuf != NULL)
                {
                    LocalFree(tmpBuf);
                    tmpBuf = NULL;
                }
                tmpBuf = (LPWSTR)LocalAlloc(LPTR, (SysStringLen(V_BSTR(&varItem)) + 1) * sizeof(WCHAR));
                if (NULL == tmpBuf)
                {
                    ReportError(hInstall, __FILE__, __LINE__, _T("Can't allocate temporary buffer. Error %ld"), GetLastError());
=====================================================================
Found a 24 line (104 tokens) duplication in the following files: 
Starting at line 58 of D:\home\eCora_PM\PM\xml\schema\Choice.cc
Starting at line 58 of D:\home\eCora_PM\PM\xml\schema\Sequence.cc

Sequence::Sequence(
    const wstring& tag,
    const list<xml::Attribute*>& attributes,
    const list<xml::Object*>& objects) :
    Node(tag, attributes, objects),
    m_id(0),
    m_maxOccurs(0),
    m_minOccurs(0)
{
    wcerr << L"<choice>" << endl;

    try
    {
	m_id = loadID(L"id");
	m_maxOccurs = loadNonNegativeInteger(L"maxOccurs", 1, true);
	m_minOccurs = loadNonNegativeInteger(L"minOccurs", 1);
    }
    catch (...)
    {
	throwFromConstructor();
    }

    wstring error;
    const_iterator i;
=====================================================================
Found a 21 line (104 tokens) duplication in the following files: 
Starting at line 145 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\Task.cpp
Starting at line 229 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\Task.cpp

Task::prepareForRollback(int* id, const wstring& netDir, xml::Node* actionSeq)
{
    using namespace winPushActions;

    wstring taskDir = netDir + dir() + L"\\";

    QFile f;
    m_totalTaskDiskBytes = 0;

    HRESULT hr;
    com::ISettings* settings = 0;
    hr = appIface()->QueryInterface(IID_ISettings, reinterpret_cast<void**>(&settings));
    if (FAILED(hr))    
    {
        throw GenericException(__FILE__, __LINE__, L"Task::prepareForPush", 
                                L"", L"Failed to obtain an interface to the Settings.");        
    }


    
    actionSeq->push_back(CreateDirectoryAction::representation((*id)++, netDir, dir(), false));
=====================================================================
Found a 25 line (104 tokens) duplication in the following files: 
Starting at line 1217 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 1145 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::viewArchive");
    try
    {
        retrieveSettings();
        //obtian PatchManagerDSN
        sql::DsnQTSettings pmDsnQTSettings;
        getPMDSN(&pmDsnQTSettings, this);
        
        //obtain source and archive databases
        QSqlDatabase *pDBFrom, *pDBTo;
        m_dsn->readDsn();
        
        Databaser databaser(&pmDsnQTSettings, m_dsn->dsnSettings());
        databaser.getDatabases(pDBFrom, pDBTo);

        ArchiveIndexWnd archiveIndexWnd(g_App->services(), this, pDBFrom, pDBTo);
        {
            WAIT_CURSOR();
            archiveIndexWnd.init();
        }
        archiveIndexWnd.exec();
    }
    catch (GenericException& ex)
    {
        QMessageBox::critical(this, "Analysis Results",
=====================================================================
Found a 18 line (104 tokens) duplication in the following files: 
Starting at line 1059 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingDlg.cpp
Starting at line 947 of D:\home\eCora_PM\PM\pmArchivePurge\ArchivingPurgingSettingsDlg.cpp

    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::appendGroups");

    QDomElement groupsNode = root.ownerDocument().createElement(SelectedGroups);
    root.appendChild(groupsNode);

    QDictIterator<com::IDbObject> itrGroups(groups);
    while (itrGroups.current())
    {
        QString qsKey = itrGroups.currentKey();
        if (qsKey.length())
        {
            QDomElement element = root.ownerDocument().createElement(GroupTagName);
            element.setAttribute(GroupID, qsKey);
            groupsNode.appendChild(element);
        }
        ++itrGroups;
    }
    log(L"patchManager", Log::Debug, L"ArchivingPurgingSettingsDlg::appendGroups, exiting");
=====================================================================
Found a 33 line (104 tokens) duplication in the following files: 
Starting at line 268 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h
Starting at line 607 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h
Starting at line 702 of D:\home\eCora_PM\PM\patchRepository\RepositoryWindowsStorageUnitTest.h

    void testDirWithDirOnlyFilter()
    {
    /** scenario:
        1. create _empty_ storage
        2. add _one_ directory there
        3. get directory content and make sure
            there is three directories (. .. and added)
            (set Dirs filter)
        4. remove this directory
        */

        TS_ASSERT_THROWS_NOTHING(load());
        WindowsStorage storage(m_resources[WindowsStoragePathExistTest],
            g_App->services());

        // make sure environment set up for test
        try
        {
            storage.connect();
            if (storage.exists())
            {
                QDir d(QDir::convertSeparators(ws2qs(
                    m_resources[WindowsStoragePathExistTest])));
                d.rmdir(d.path());
            }
        }
        catch (GenericException&)
        {
            TS_FAIL("Couldn't set up environment for test.");
        }

        TS_ASSERT_THROWS_NOTHING(storage.create());
        TS_ASSERT_EQUALS(storage.exists(), true);
=====================================================================
Found a 16 line (104 tokens) duplication in the following files: 
Starting at line 2715 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 1166 of D:\home\eCora_PM\PM\patchRepository\RepositorySettingsQT.cpp

	    WindowsStorage tempDownloadTest(qs2ws(m_downloadDir->text()), m_services);
    	    repoTest.connect();
	    tempDownloadTest.connect();

	    com::ISettings* iSet = 0;
	    if (m_services)
	    {
		HRESULT hr = m_services->QueryInterface(IID_ISettings, (void**)&iSet);

		wstring source = iSet->setting(L"root") + L"/bin/EcoraRepoTest.txt";
		if (tempDownloadTest.fileExists(L"EcoraRepoTest.txt"))
		    tempDownloadTest.deleteFile(L"EcoraRepoTest.txt");

		repoTest.addFile(source, L"EcoraRepoTest.txt", 0, 0);
		if (tempDownloadTest.fileExists(L"EcoraRepoTest.txt"))
		{
=====================================================================
Found a 14 line (104 tokens) duplication in the following files: 
Starting at line 568 of D:\home\eCora_PM\PM\patchManager\SystemInfo.cpp
Starting at line 900 of D:\home\eCora_PM\PM\patchManager\SystemInfo.cpp

    for (; itPatch != end(); ++itPatch)
    {
        if (rule == policyManager::DisplayStatus::POLICY_PATCH_MUST_INSTALL &&
            (*itPatch)->isFound() == false && (*itPatch)->doesPatchApply())
            result |= pmUI::PolicyPropagationConstraints::PATCH_AVAILABLE_FOR_PUSH;

        if (rule == policyManager::DisplayStatus::POLICY_PATCH_MUST_NOT_INSTALL &&
            (*itPatch)->isFound() == true && (*itPatch)->doesPatchApply())
        {
            result |= ((result & pmUI::PolicyPropagationConstraints::PATCH_AVAILABLE_FOR_PUSH) ?
            pmUI::PolicyPropagationConstraints::MORE_PATCH_AVAILABLE_FOR_ROLLBACK :
            pmUI::PolicyPropagationConstraints::PATCH_AVAILABLE_FOR_ROLLBACK);
        }
    }
=====================================================================
Found a 15 line (104 tokens) duplication in the following files: 
Starting at line 509 of D:\home\eCora_PM\PM\patchManager\SettingsDlg.cpp
Starting at line 708 of D:\home\eCora_PM\PM\patchManager\SettingsDlg.cpp

        }
    }
    catch (GenericException& e)
    {
        log(L"patchManager", Log::User, L"Error - SettingsDlg::accept: " + e.message());
        QMessageBox::warning(this, QObject::tr("Warning"), ws2qs(e.message()), QObject::tr("&OK"));
        return;
    }
    catch (...)
    {
        log(L"patchManager", Log::User, L"Error - SettingsDlg::accept - top level");
        QMessageBox::warning(this, QObject::tr("Warning"), tr("An error occured while saving the settings"),
                             QObject::tr("&OK"));
        return;
    }
=====================================================================
Found a 16 line (104 tokens) duplication in the following files: 
Starting at line 337 of D:\home\eCora_PM\PM\alerts\alertsUI\BrowserQT.cc
Starting at line 737 of D:\home\eCora_PM\PM\alerts\alertsUI\BrowserQT.cc

void TriggerBrowserQT::refreshList()
{
    wstring selectedItem;
    QListViewItem* item = firstSelectedItem();
    if (item != 0)
	selectedItem = qs2ws(item->text(0));
    QListViewItem* newSelection = 0;

    map<wstring, bool> expand;
    QListViewItem* parent = m_browserList->firstChild(); 
    while (parent != 0)
    {
	expand.insert(make_pair(qs2ws(parent->text(0)), parent->isOpen()));
	parent = parent->nextSibling();
    }
    m_browserList->clear();
=====================================================================
Found a 15 line (104 tokens) duplication in the following files: 
Starting at line 536 of D:\home\eCora_PM\PM\adsi\ecoraAds.cpp
Starting at line 1563 of D:\home\eCora_PM\PM\adsi\ecoraAds.cpp

	}

	if (!saPropertyList.GetSize() ||
	    saPropertyList.In(_T("ObjectClass")))
	{
	    CComBSTR bstrClass;
	    if (S_OK == pNode->get_Class(&bstrClass))
		LogMessage(_T("ObjectClass^%s"), (BSTR&)bstrClass, dnformat);
	}

	if (!saPropertyList.GetSize() || saPropertyList.In(_T("Schema")))
	{
	    CComBSTR bstrSchema;
	    if (S_OK == pNode->get_Schema(&bstrSchema))
		LogMessage(_T("Schema^%s"), (BSTR&)bstrSchema, dnformat);
=====================================================================
Found a 11 line (103 tokens) duplication in the following files: 
Starting at line 353 of D:\home\eCora_PM\PM\policyManager\PolicyCreateQT.cpp
Starting at line 433 of D:\home\eCora_PM\PM\policyManager\PolicyCreateQT.cpp

            ProductContainer::iterator itProduct = m_pPatchesSelection->m_productList.begin();
            for (; itProduct != m_pPatchesSelection->m_productList.end(); ++itProduct)
            {	
                ProductVersionContainer::iterator itVersion = (*itProduct)->beginVersion();
                for (; itVersion != (*itProduct)->endVersion(); ++itVersion)
                {
                    PatchContainer::iterator itPatch = (*itVersion)->begin();
                    for (; itPatch != (*itVersion)->end(); ++itPatch)
                    {
                        if ((*itPatch)->selected())
                        {
=====================================================================
Found a 15 line (103 tokens) duplication in the following files: 
Starting at line 69 of D:\home\eCora_PM\PM\pmPushWinBaseImpl\OfficePatch.h
Starting at line 65 of D:\home\eCora_PM\PM\pmPushWinBaseImpl\SqlPatch.h

    wstring dir() const;
    wstring exeToLaunch() const;
    wstring switches() const;
    wstring qName() const;
    unsigned int timeout() const;
    unsigned int index() const;
    wstring wsIndex() const;
    void setTimeout(unsigned int v);
    void setExe(const wstring& e);
    void setQName(const wstring& v);
    void setSwitches(const wstring& v);
    void setReboot(bool v);
    void setIndex(int v);
    void setDir(const wstring& v);
    wstring systemScanKey() const;
=====================================================================
Found a 27 line (103 tokens) duplication in the following files: 
Starting at line 202 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\UnixComputer.cpp
Starting at line 316 of D:\home\eCora_PM\PM\pmPushWinLocalImpl\WinComputer.cpp

        setStatus(pmPushBaseModel::IComputer::PushFailure, result);
    }
    else if (ActionsInterpreter::CANCELED == state)
    {
        actionsInterpreter()->undoAll();

        setStatus(pmPushBaseModel::IComputer::PushFailure, L"Canceled");
    }
    else
    {
        if (transferOnly())
        {
            setStatus(pmPushBaseModel::IComputer::PushSuccess,
                L"Successfully transfered files.");
        }
        else if (task()->useRepository())
        {
            setStatus(pmPushBaseModel::IComputer::PushSuccess,
                L"Successfully scheduled job.");
        }
        else
        {
            setStatus(pmPushBaseModel::IComputer::PushSuccess,
                L"Successfully transfered files and scheduled job.");
        }
    }
}
=====================================================================
Found a 30 line (103 tokens) duplication in the following files: 
Starting at line 113 of D:\home\eCora_PM\PM\patchRepository\patchRepositoryActions\PatchRepositoryAction.cpp
Starting at line 158 of D:\home\eCora_PM\PM\unixPushActions\UnixPushAction.cpp

UnixPushAction::formatMsg(int error)
{
    
    PTSTR errorBuf;
    
    FormatMessage(
    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
    FORMAT_MESSAGE_FROM_SYSTEM | 
    FORMAT_MESSAGE_IGNORE_INSERTS, 
    0, 
    error, 
    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),   // Default language
    reinterpret_cast<PTSTR>(&errorBuf), 
    0, 
    0);
    
    wstring message;
    message = errorBuf;
    size_t size = message.size();
    if (size >= 2 && 
        L'\r' == message[size - 2] &&
        L'\n' == message[size - 1])
    {
        message.resize(size - 2);
    }

    LocalFree(errorBuf);
    return message;

}
=====================================================================
Found a 10 line (103 tokens) duplication in the following files: 
Starting at line 1343 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 154 of D:\home\eCora_PM\PM\patchRepository\WindowsStorage.cpp

	    if (RegQueryValueEx(openKeyMatch, shareName.c_str(), 0, 0, value, &len) == ERROR_SUCCESS)
	    {
		log(L"patchRepository", Log::Debug, L"Found share " << shareName);
		// the value returned from registry has multiple strings separated by "\0"
		wstring shareValue = wstring((LPWSTR)value);
		while (shareValue.size() < len / 2 - 2)
		    shareValue += L" " + wstring((LPWSTR)&value[(shareValue.size() + 1) * 2]);
		log(L"patchRepository", Log::Debug, L"Share value " << shareValue);

		wstring localPath = shareValue.substr(shareValue.find(L"Path=") + 5);
=====================================================================
Found a 13 line (103 tokens) duplication in the following files: 
Starting at line 404 of D:\home\eCora_PM\PM\patchManager\SettingsDlg.cpp
Starting at line 510 of D:\home\eCora_PM\PM\patchManager\SettingsDlg.cpp

    }
    catch (GenericException& e)
    {
        log(L"patchManager", Log::User, L"Error - SettingsDlg::accept: " + e.message());
        QMessageBox::warning(this, QObject::tr("Warning"), ws2qs(e.message()), QObject::tr("&OK"));
        return;
    }
    catch (...)
    {
        log(L"patchManager", Log::User, L"Error - SettingsDlg::accept - top level");
        QMessageBox::warning(this, QObject::tr("Warning"), tr("An error occured while saving the settings"), QObject::tr("&OK"));
        return;
    }
=====================================================================
Found a 21 line (103 tokens) duplication in the following files: 
Starting at line 3056 of D:\home\eCora_PM\PM\patchManager\App.cpp
Starting at line 841 of D:\home\eCora_PM\PM\patchManager\PatchMeisterLicense.cc

    HRESULT hr = g_App->services()->QueryInterface(IID_IAppDatabase, (void**)&pDb);
    if (!SUCCEEDED(hr))
    {
        return false;
    }

    CComPtr<com::IDbContainer> pDbContainer;
    hr = pDb->getDbContainer(&pDbContainer);
    if (!SUCCEEDED(hr))
    {
        return false;
    }
    pDb->Release();

    hr = pDbContainer->registerObjectType((IUnknown*)&idb::WindowsDevice());
    if (!SUCCEEDED(hr))
    {
        return false;
    }

    idb::WindowsDevice dev(g_App->services());
=====================================================================
Found a 8 line (103 tokens) duplication in the following files: 
Starting at line 174 of D:\home\eCora_PM\PM\fksec\main.cpp
Starting at line 182 of D:\home\eCora_PM\PM\fksec\main.cpp

	out << _T( "after DeleteAces( (PSID) guest ): " ) << al0 << std::endl;

	ac0.SetMask( 0x01 ); al0.AddAce( 0, (const void *) ac0 );
	ac0.SetMask( 0x02 ); al0.AddAce( 0, ac0 );
	al0.AddAce( 0, ACCESS_ALLOWED_ACE_TYPE, 0, 0, 0x04, (PSID) guest );
	al0.AddAce( 0, ACCESS_DENIED_ACE_TYPE, 0, 0, 0x08, GUEST );
	al0.AddAce( 0, SYSTEM_AUDIT_ACE_TYPE, 0, 0, 0x10, guest );
	al0.DeleteAcesForSid( GUEST );
=====================================================================
Found a 11 line (103 tokens) duplication in the following files: 
Starting at line 189 of D:\home\eCora_PM\PM\ecoraStyle\ESListView.cpp
Starting at line 336 of D:\home\eCora_PM\PM\ecoraStyle\EcoraStyle.cpp

    float colorMod[3] =
        {
            aColor.red() - bColor.red(),
            aColor.green() - bColor.green(),
            aColor.blue() - bColor.blue()
        };
    float colorDiff[3] = { colorMod[0] / gradient, colorMod[1] / gradient, colorMod[2] / gradient };

    for (int x = r.left(); x <= r.right(); ++x)
    {
        float d = abs(x - ref.x());
=====================================================================
Found a 9 line (102 tokens) duplication in the following files: 
Starting at line 1722 of D:\home\eCora_PM\PM\utils\intercept.h
Starting at line 1745 of D:\home\eCora_PM\PM\utils\intercept.h

    return new MemberFunctionCapture8<R, C, F, P1, P2, P3, P4, P5, P6, P7, P8>(
        o, f, p1, p2, p3, p4, p5, p6, p7, p8);
}


template<class C, typename F,
    typename P1, typename P2, typename P3,
    typename P4, typename P5, typename P6, typename P7, typename P8>
inline VoidMemberFunctionCapture8<C, F, P1, P2, P3, P4, P5, P6, P7, P8>*
=====================================================================
Found a 11 line (102 tokens) duplication in the following files: 
Starting at line 119 of D:\home\eCora_PM\PM\pmPush\Computer.cpp
Starting at line 83 of D:\home\eCora_PM\PM\remoteModel\RemoteComputer.cpp

    for (it = task()->begin(); task()->end() != it; ++it)
    {
        IPatch* patch = *it;
        if (patch->status() == pmPushBaseModel::IPatch::Ok)
        {
            vector<AnnotatedAction*> prepareActions;
            vector<AnnotatedAction*> installActions;

            ActionSequence::iterator ait;
            ActionSequence* prepare = patch->prepareActions() ? dynamic_cast<ActionSequence*>(patch->prepareActions()) : 0;
            ActionSequence* install = patch->installActions() ? dynamic_cast<ActionSequence*>(patch->installActions()) : 0;
=====================================================================
Found a 25 line (102 tokens) duplication in the following files: 
Starting at line 357 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\UnixComputer.cpp
Starting at line 852 of D:\home\eCora_PM\PM\pmPushUnixLocalImpl\UnixComputer.cpp

    sd.write(wos);

    try
    {

#ifdef _DEBUG
        wstring dumpFileName =  L"pushactions.xml";

        wofstream dumpFile;
        dumpFile.open(ws2utf8s(dumpFileName).c_str(), (ios::in | ios::out | ios::trunc));

        if (dumpFile.is_open())
            actionSeqDoc.write(dumpFile);
#endif
        actionsInterpreter()->loadActionSequence(actionSeqDoc);
    }
    catch (GenericException& e)
    {
        wstring message = L"Failed to create push actions: " + e.message();
        setStatus(pmPushBaseModel::IComputer::PushFailure, message);
        return 0;
    }

    return id; // the number of push actions
}
=====================================================================
Found a 20 line (102 tokens) duplication in the following files: 
Starting at line 308 of D:\home\eCora_PM\PM\patchRepository\DownloadDialog.cpp
Starting at line 208 of D:\home\eCora_PM\PM\patchRepository\ValidationDialog.cpp

    : ValidationDialogUI(parent, "download2", true, 0),
    m_services(services),
    m_rejectSem(1)
{
    if (parent != 0)
    {
	if (parent->icon() != 0)
	    setIcon(*(parent->icon()));
    }
    else
	setIcon(pmServices::Icons::getIcon(pmServices::Icons::Wrench));

    ui::help::InlineHelp tips;
    if (check_patchRepository_InlineHelpVar())
    {
        tips.loadDataF(g_patchRepository_inlineHelp);
    }

    tips.setHelp(m_cancelButton, L"Button: Cancel");
    tips.setHelp(m_totalProgress, L"Total Progress");
=====================================================================
Found a 23 line (102 tokens) duplication in the following files: 
Starting at line 88 of D:\home\eCora_PM\PM\patchManager\SystemTabBuilder.cpp
Starting at line 174 of D:\home\eCora_PM\PM\patchManager\SystemTabBuilder.cpp

    m_listview->addColumn(QObject::tr("Installed"), 150);
	//g_GlobalConst.hostComputerColumnWidth(0));

    m_listview->addColumn(QObject::tr("Risk"), 100);

    m_listview->addColumn(QObject::tr("Application"), 150);
	//g_GlobalConst.hostComputerColumnWidth(1));

    m_listview->addColumn(QObject::tr("Patch Name"), 200);
	//g_GlobalConst.hostComputerColumnWidth(2));

    m_listview->addColumn(QObject::tr("Hotfix"), 100);
	//g_GlobalConst.hostComputerColumnWidth(3));

    m_listview->addColumn(QObject::tr("Bulletin"), 100);
	//g_GlobalConst.hostComputerColumnWidth(4));

    m_listview->setColumnAlignment(5, Qt::AlignCenter);
    m_listview->setAllColumnsShowFocus(TRUE);
    m_listview->setShowSortIndicator(TRUE);
}

void 
=====================================================================
Found a 21 line (102 tokens) duplication in the following files: 
Starting at line 624 of D:\home\eCora_PM\PM\patchManager\DisplayInfo.cpp
Starting at line 709 of D:\home\eCora_PM\PM\patchManager\DisplayInfo.cpp

                                    pmUI::ScanServicePackInfo& scanInfoServicePack,
                                    pmUI::PatchesMap& patchesMap,
                                    bool bNewRootFolder)
{
    Folder* fDateFolder = 0;
    if (bNewRootFolder)
    {   // timestamp node
        FolderBuilder<FolderInfoMetaLevel, pmUI::AdvInfo> fNTDate(0, 0,
            m_tabWidgetRight, timestamp, g_GlobalConst.metaDomainPixmap(),
            getCurrentScanId()); // BUGFIX 21511 by S.Vyazovetskov
        
        fDateFolder = fNTDate.getFolder();
        m_lstFolderPatches.push_back(fDateFolder);
    }
    else
    {
        if (m_lstFolderPatches.size() == 0) return; // should never happen
        fDateFolder = *(m_lstFolderPatches.rbegin());
    }

    typedef map<wstring, vector<pmUI::ServicePackInfo*> > CRITERIA_MAP;
=====================================================================
Found a 21 line (102 tokens) duplication in the following files: 
Starting at line 166 of D:\home\eCora_PM\PM\network\Ftp.cc
Starting at line 236 of D:\home\eCora_PM\PM\network\Http.cc

        *httpRes = new HttpResult(code, status, desc, fileTime);
    
    if (outputFile.empty() && content != 0)
    {
        fseek(bodyHandle, 0L, SEEK_SET);
        
        // Read the body of the file in the provided string.
        struct io_stat buf;
        io_fstat(fileno(bodyHandle), &buf);
        content->resize(buf.st_size);
        
        fread(&((*content)[0]), buf.st_size, 1, bodyHandle);
    }
    
    curl_easy_setopt(m_handle, CURLOPT_URL, 0);
    curl_easy_setopt(m_handle, CURLOPT_ERRORBUFFER, 0);
    
    return (status == Result::Success);
}

bool
=====================================================================
Found a 21 line (102 tokens) duplication in the following files: 
Starting at line 583 of D:\home\eCora_PM\PM\hostManager\ObjectView.cpp
Starting at line 756 of D:\home\eCora_PM\PM\hostManager\ObjectView.cpp

    WAIT_CURSOR();

    int iCounter = 0;
    QSqlCursor* deviceCursor = EsDataTableObject->sqlCursor();
    _IfNullPtrRet(deviceCursor);

    int iSelections = EsDataTableObject->numSelections();
    int iProgressSize = 0;

    // count progress bar size
    for (int idx = 0; idx < iSelections; ++idx, ++iCounter)
    { 
        QTableSelection selection = EsDataTableObject->selection(iCounter);
        int iTopRow = selection.topRow();
        int iBottomRow = selection.bottomRow();

        iProgressSize = iBottomRow - iTopRow  + 1;
    }

    m_pControl->setTotalSteps(iProgressSize);
    iProgressSize = 0;
=====================================================================
Found a 11 line (102 tokens) duplication in the following files: 
Starting at line 477 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp
Starting at line 527 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp

        m_app->m_regs[i] = cr;
        m_tableReg->setItem(num, 0,
            new ESTableItem(m_tableReg, QTableItem::Never, cr->m_registryKey));
        m_tableReg->setItem(num, 1,
            new ESTableItem(m_tableReg, QTableItem::Never, m_info->m_regTypes[cr->m_regType]));
        m_tableReg->setItem(num, 2,
            new ESTableItem(m_tableReg, QTableItem::Never, cr->m_value));
        QString data = cr->m_data;
        data = data.replace('\n', ' ');
        m_tableReg->setItem(num, 3,
            new QTableItem(m_tableReg, QTableItem::Never, data));
=====================================================================
Found a 48 line (102 tokens) duplication in the following files: 
Starting at line 18 of D:\home\eCora_PM\PM\NetDiscover\NetDiscoverUnitTest.h
Starting at line 59 of D:\home\eCora_PM\PM\unitTest\GreenYellowRed.h

    GreenYellowRed()
    {
        m_trigger = 1;
    }

    void test_Start_green()
    {
        wait();
    }

    void test_Green_again()
    {
        wait();
    }

    void test_Now_yellow()
    {
        TS_WARN("Yellow");
        wait();
    }

    void test_Cannot_go_back()
    {
        wait();
    }

    void test_Finally_red()
    {
        TS_FAIL("Red");
        wait();
    }

    void test_Cannot_go_back_to_yellow()
    {
        TS_WARN("Yellow?");
        wait();
    }

    void test_Cannot_go_back_to_green()
    {
        wait();
    }

  private:
    static int m_trigger;
};

static GreenYellowRed GreenYellowRedTrigger;
=====================================================================
Found a 21 line (101 tokens) duplication in the following files: 
Starting at line 59 of D:\home\eCora_PM\PM\unixPushActions\ChkExistingTaskAction.cpp
Starting at line 50 of D:\home\eCora_PM\PM\unixPushActions\RecordPendingTaskAction.cpp

        m_message = L"OK to schedule job.";
        return onSuccess(env, L"ChkExistingTaskAction", m_message);
    }
    catch (GenericException& g)
    {
        DisconnectAction da(env);
        da.disconnect(devicePK);
        m_message = g.message();
        return onFail(env, L"ChkExistingTaskAction", m_message);
    }
    catch (...)
    {
        DisconnectAction da(env);
        da.disconnect(devicePK);
        m_message = L"Caught exception in PushCleanupAction::execute.";
        return onFail(env, L"ChkExistingTaskAction", m_message);
    }
    return onSuccess(env, L"ChkExistingTaskAction", L"");
}

actionsInterpreter::ActionResult
=====================================================================
Found a 13 line (101 tokens) duplication in the following files: 
Starting at line 548 of D:\home\eCora_PM\PM\pmPush\LocalFactory.cpp
Starting at line 571 of D:\home\eCora_PM\PM\pmPush\LocalFactory.cpp

                L"location.languageFK='" + languageId + L"'";
            
            QSqlQuery query = m_dbManager->exec(queryStr);
            if (query.isActive() && query.first())
            {
                exception = qs2ws(query.value(0).toString());
                if (!exception.empty())
                {
                    throw GenericException(__FILE__, __LINE__, L"LocalFactory::newWindowsPatch", L"",
                        L"Database exception: " + exception);
                }
                fileName = qs2ws(query.value(1).toString());
                patchName = qs2ws(query.value(2).toString());
=====================================================================
Found a 16 line (101 tokens) duplication in the following files: 
Starting at line 56 of D:\home\eCora_PM\PM\patchRepository\ValidationManager.cpp
Starting at line 265 of D:\home\eCora_PM\PM\patchRepository\ValidationManager.cpp

ValidationManager::validateLastModified(Patch* patch) 
{
    bool valid = false;
    try
    {
        if (!m_storage->isConnectionAlive())
    	    m_storage->connect();
        
	vector<PatchLocation*>& locs = patch->getLocations();
	bool anyInvalid = (locs.size() > 0 ? false : true);
	for (int i = 0; i < locs.size(); ++i)
	{
	    wstring relFile = patch->relativePath() + L"/" + locs[i]->filename();

	    // not necessarily a lastModified in the database for every patch file
	    if (!locs[i]->lastModified().isValid())
=====================================================================
Found a 21 line (101 tokens) duplication in the following files: 
Starting at line 302 of D:\home\eCora_PM\PM\patchManager\WinSolRepoSettings.cpp
Starting at line 79 of D:\home\eCora_PM\PM\tools\misc\CurlExample.cc

    char error[CURL_ERROR_SIZE + 1];
    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, error);

    curl_easy_setopt(curl, CURLOPT_URL, url);

    FILE *header = tmpfile();
    curl_easy_setopt(curl, CURLOPT_WRITEHEADER, header);

    FILE *body = tmpfile();
    curl_easy_setopt(curl, CURLOPT_FILE, body);

    CURLcode result = curl_easy_perform(curl);

    fclose(body);

    if (result == 0)
    {
	char buf[1024];
	fseek(header, 0L, SEEK_SET);
	fread(buf, 1023, 1, header);
	code = curl_decode_header(buf, description);
=====================================================================
Found a 15 line (101 tokens) duplication in the following files: 
Starting at line 605 of D:\home\eCora_PM\PM\hostManager\ObjectView.cpp
Starting at line 991 of D:\home\eCora_PM\PM\hostManager\ObjectView.cpp

    for (int idx = 0; idx < iSelections; ++idx)
    { 
        QTableSelection selection = EsDataTableObject->selection(idx);

        int iTopRow = selection.topRow();
        int iBottomRow = selection.bottomRow();

        for (int iter = iTopRow; iter <= iBottomRow; ++iter)
        { 
            // get device key
            if (deviceCursor->seek(iter))
            { 
                QString qsKey = deviceCursor->value(0).toString();
                TDevice device(m_pServices);
                hr = m_pDbContainer->retrieveObject(qsKey, (IUnknown*)&device);
=====================================================================
Found a 8 line (101 tokens) duplication in the following files: 
Starting at line 174 of D:\home\eCora_PM\PM\fksec\main.cpp
Starting at line 190 of D:\home\eCora_PM\PM\fksec\main.cpp
Starting at line 198 of D:\home\eCora_PM\PM\fksec\main.cpp

	out << _T( "after normalize(): " ) << al0 << std::endl;

	ac0.SetMask( 0x01 ); al0.AddAce( 0, (const void *) ac0 );
	ac0.SetMask( 0x02 ); al0.AddAce( 0, ac0 );
	al0.AddAce( 0, ACCESS_ALLOWED_ACE_TYPE, 0, 0, 0x04, (PSID) guest );
	al0.AddAce( 0, ACCESS_DENIED_ACE_TYPE, 0, 0, 0x08, GUEST );
	al0.AddAce( 0, SYSTEM_AUDIT_ACE_TYPE, 0, 0, 0x10, guest );
	al0.canonicalize();
=====================================================================
Found a 15 line (101 tokens) duplication in the following files: 
Starting at line 500 of D:\home\eCora_PM\PM\customPatch\ApplicationProperties.cpp
Starting at line 859 of D:\home\eCora_PM\PM\customPatch\PatchProperties.cpp

void PatchProperties::editReg()
{
    int num = 0;
    while (!m_tableReg->isRowSelected(num))
        num++;
    QString regKey = m_tableReg->text(num, 0);
    int type = 0;
    QString s = m_tableReg->text(num, 1);
    while (s != m_info->m_regTypes[type])
    {
        type++;
    }
    QString value = m_tableReg->text(num, 2);
    QString data = m_tableReg->text(num, 3);
    for (int i = 0; i < m_newPatch->m_regs.size(); i++)
=====================================================================
Found a 23 line (101 tokens) duplication in the following files: 
Starting at line 409 of D:\home\eCora_PM\PM\alerts\alertsUI\BrowserQT.cc
Starting at line 796 of D:\home\eCora_PM\PM\alerts\alertsUI\BrowserQT.cc

	item->setText(3, ws2qs(triggerList[i]->getId()));
    }

    parent = m_browserList->firstChild(); 
    while (parent != 0)
    {
	map<wstring, bool>::iterator e;
	e = expand.find(qs2ws(parent->text(0)));
	
    // T: BUGFIX 24574
    if (e != expand.end())
    {
        parent->setOpen(e->second || m_defaultCfg);
    }
    else
    {
        parent->setOpen(false);
    }
    // T: END OF 24574
	parent = parent->nextSibling();
    }

    if (newSelection != 0)
=====================================================================
Found a 16 line (101 tokens) duplication in the following files: 
Starting at line 198 of D:\home\eCora_PM\PM\agent\agent\Library\XMLUtils\XMLPersistObj.h
Starting at line 218 of D:\home\eCora_PM\PM\agent\agent\Library\XMLUtils\XMLPersistObj.h

                void XMLSaveDynamic_(const tstring& xml_path, const tstring& name, Obj*& pobj)
            {
                using namespace XERCES_CPP_NAMESPACE;

                // Create document and save to it
                XERCES_CPP_NAMESPACE::DOMDocument* doc =
                    m_domImpl->createDocument(0, xmlutils::tstring2xmlstring(m_docName).c_str(), 0);
                assert(doc); // FIXME : in release should throw
                ScopeGuard doc_release = makeObjectGuard(*doc, XERCES_CPP_NAMESPACE::DOMDocument::release);

                doc->setActualEncoding(xmlutils::tstring2xmlstring(ECORA_TEXT("UTF-8")).c_str());
                DOMElement* root = doc->getDocumentElement();
                assert(root); // FIXME : in release should throw

                xmlutils::SaveContext<Traits> ctx(doc, root);
                xmlutils::XMLpersist_dynamic<TList>(&ctx, pobj, name, root);
=====================================================================
Found a 23 line (101 tokens) duplication in the following files: 
Starting at line 245 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketClient.cpp
Starting at line 240 of D:\home\eCora_PM\PM\agent\RemoteExec\RemoteTools\Win32Tools\SocketServer.cpp

CSocketServer::AllocateSocket(SOCKET theSocket)
{
    CCriticalSection::Owner lock(m_listManipulationSection);
    Socket* pSocket = 0;

    if (!m_freeList.Empty())
    {
        pSocket = m_freeList.PopNode();
        pSocket->Attach(theSocket);
        pSocket->AddRef();
    }
    else
    {
        pSocket = new Socket(*this, theSocket);
        OnConnectionCreated();
    }

    m_activeList.PushNode(pSocket);
    m_iocp.AssociateDevice(reinterpret_cast<HANDLE>(theSocket), (ULONG_PTR)pSocket);
    return pSocket;
}

void 
=====================================================================
Found a 18 line (100 tokens) duplication in the following files: 
Starting at line 42 of D:\home\eCora_PM\PM\winPushActions\CopyFileAction.cpp
Starting at line 79 of D:\home\eCora_PM\PM\winPushActions\CopyFileAction.cpp

    wstring::size_type it = m_src.rfind(L"\\");
    if (wstring::npos == it)
    {
        it = m_src.rfind(L"/");
    }

    wstring file = m_src.substr(it + 1, wstring::npos);

    if (m_dst.rfind(file) == wstring::npos)
    {
        if (m_dst.rfind(L"\\") != wstring::npos &&
            m_dst.rfind(L"\\") != m_dst.size() - 1)
        {
            m_dst += L"\\";
        }

        m_dst += file;
    }
=====================================================================
Found a 27 line (100 tokens) duplication in the following files: 
Starting at line 83 of D:\home\eCora_PM\PM\unixPushActions\TransferFileAction.cpp
Starting at line 94 of D:\home\eCora_PM\PM\unixPushActions\TransferInstallerAction.cpp

TransferInstallerAction::undo(actionsInterpreter::ExecEnvironment* env)
{
    using namespace actionsInterpreter;
    wstring installExecutable;
    wstring src, dst, devicePK;

    if (!getParameter(Source, src) ||
        !getParameter(Destination, dst) || 
        !getParameter(DevicePK, devicePK))
    {
        return ActionResult(ActionResult::ABORT);
    }
    
    try
    {
        connection(devicePK)->deleteFile(dst);
    }
    catch (...)
    {
        m_message =  L"Caught exception in TransferFileAction::undo";
        return onFail(env);
    }

    return onSuccess(env);
}

xml::Node*
=====================================================================
Found a 12 line (100 tokens) duplication in the following files: 
Starting at line 98 of D:\home\eCora_PM\PM\snoopy\simulation.cpp
Starting at line 118 of D:\home\eCora_PM\PM\snoopy\simulation.cpp

    real.erase(thirdpos);

    tstring::size_type secondpos = real.rfind(_T('_'));
    assert(secondpos != string::npos);
    second = _ttoi(real.substr(secondpos + 1).c_str());
    real.erase(secondpos);

    tstring::size_type firstpos = real.rfind(_T('_'));
    assert(firstpos != string::npos);
    first = _ttoi(real.substr(firstpos + 1).c_str());
    real.erase(firstpos);
}
=====================================================================
Found a 19 line (100 tokens) duplication in the following files: 
Starting at line 243 of D:\home\eCora_PM\PM\snoopy\BaseDomainContainer.h
Starting at line 272 of D:\home\eCora_PM\PM\snoopy\BaseDomainContainer.h

        for (it = domainList.begin(); it != domainList.end(); it++)
        {
            bool validDomain = false;
            CBaseDomainContainer::iterator domIt;
            for (domIt = begin(); domIt != end(); domIt++)
            {
                if (0 == wcsicmp(domIt->m_name.c_str(), it->m_domain.c_str()))
                {
                    validDomain = true;
                    domIt->SetSelected(true);
                    m_selectedDomainsCount++;
                }
            }
            if (!validDomain)
            {
                log(L"windows-collector", Log::Error, 
                    L"Invalid domain in the batch file: " << it->m_domain);
            }
        }
=====================================================================
Found a 9 line (100 tokens) duplication in the following files: 
Starting at line 115 of D:\home\eCora_PM\PM\policyManager\PatchesRulesQT.cpp
Starting at line 84 of D:\home\eCora_PM\PM\policyManager\PatchesSelectionQT.cpp

		m_listView, ws2qs((*itVersion)->versionId()));

	    PatchContainer::iterator itPatch = (*itVersion)->begin();
	    for (; itPatch != (*itVersion)->end(); ++itPatch)
	    {
		QString name = ws2qs((*itPatch)->nameExec());

		if ((*itPatch)->isServicePack() && (*itPatch)->spEncryption().empty() == false)
		    name += QString(" (") + ws2qs((*itPatch)->spEncryption()) + QString(")");
=====================================================================
Found a 19 line (100 tokens) duplication in the following files: 
Starting at line 539 of D:\home\eCora_PM\PM\pmPush\PushPackOps.cpp
Starting at line 562 of D:\home\eCora_PM\PM\pmPush\PushPackOps.cpp

InsertDbActivity::visit(pmPushBaseModel::IUnixPatch* p)
{
    if (p->status() != pmPushBaseModel::IPatch::Ok)
    {
        m_status = L"Fail";
        m_statusMsg = p->statusMessage() + L" As user " + m_pushUser;
    }
    try
    {
        m_lf->insertActivity(m_date, m_loggedInUser,
               m_status, m_statusMsg,
               p->primaryKey(), p->versionKey(),
               p->productKey(), p->systemScanKey());
    }
    catch (GenericException& e)
    {
        log(L"InsertDbActivity", Log::Error, e.message());
    }
}
=====================================================================
Found a 16 line (100 tokens) duplication in the following files: 
Starting at line 56 of D:\home\eCora_PM\PM\patchRepository\ValidationManager.cpp
Starting at line 129 of D:\home\eCora_PM\PM\patchRepository\ValidationManager.cpp

ValidationManager::validateMd5(Patch* patch)
{
    bool valid = false;
    try
    {
	if (!m_storage->isConnectionAlive())
	    m_storage->connect();

        vector<PatchLocation*>& locs = patch->getLocations();
	bool anyInvalid = (locs.size() > 0 ? false : true);
	for (int i = 0; i < locs.size(); ++i)
	{
	    wstring relFile = patch->relativePath() + L"/" + locs[i]->filename();

	    // not necessarily a checksum in database for every patch file
	    if (locs[i]->md5().size() == 0)
=====================================================================
Found a 13 line (100 tokens) duplication in the following files: 
Starting at line 495 of D:\home\eCora_PM\PM\ecoraStyle\EcoraStyle.cpp
Starting at line 514 of D:\home\eCora_PM\PM\ecoraStyle\EcoraStyle.cpp

        if (center.y() < head.y())
            dir = -1;

        for (int i = 0; i < size; ++i)
        {
            int upperThick(thick / 2);
            int lowerThick(0 - thick / 2 + (thick + 1) % 2);
            for (int j = lowerThick; j < upperThick; ++j)
            {
                if ((!i && j == lowerThick) || (i + 1 == size && j + 1 == upperThick))
                    continue;

                p->drawPoint(head.x() - i, head.y() + dir * (i + j));
=====================================================================
Found a 12 line (100 tokens) duplication in the following files: 
Starting at line 388 of D:\home\eCora_PM\PM\alerts\alertslib\mailer.cc
Starting at line 407 of D:\home\eCora_PM\PM\alerts\alertslib\mailer.cc

	commandline = std::string("MAIL FROM:<") + wstring2mbs(fromAddress).c_str() + ">\r\n";
	log(L"emailAlert", Log::Debug, L"Send " << mbs2wstring(commandline));
	len1 = send(s, commandline.c_str(), commandline.length(), MSG_DONTROUTE);
	len1 = recv(s, buff, 1024, 0);
	// std::cout << "buff\n" << buff << "\n";
	buff[len1] = '\0';
	returnstring = mbs2wstring(buff);
	log(L"emailAlert", Log::Debug, L"Receive " << returnstring);
	if (returnstring.substr(0, 3) != OK) {
		Closesocket(s);
		continue;
	}
