package com.glority.quality.metrics;

import java.io.File;
import java.io.FileInputStream;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.configuration.PropertiesConfiguration;
import org.apache.tools.ant.BuildException;

import com.glority.quality.Constants.MetricCompareMode;
import com.glority.quality.Constants.MetricResult;
import com.glority.quality.model.Metric;

/**
 * Base task of the metrics checkers All metrics checkers should extends from
 * this class This class introduced 2 attribute: 1. report path -- the path of
 * the report. Generally saying. We will analyze metrics from the reports
 * generated by different tools 2. threshold path -- the path where we kept the
 * threshold
 * 
 * @author XQS
 * 
 */
public abstract class MetricsCheckBaseTask extends MetricsBaseTask {
    protected String reportPath;
    protected String thresholdPath;

    /**
     * Main steps: 1. parse the report 2. check the thresholds.
     */
    public final void process() {
        parseReport();
        checkThreshold();
        updateQualityXML();
    }

    /**
     * To update quality.xml.
     */
    public void updateQualityXML() {
        updateQualityXML(getMetrics());
    }

    /**
     * The class extends from this class should implement this API. this
     * function should parse the report from report path
     * 
     */
    public abstract void parseReport();

    /**
     * The class extends from this class should implement this API. this will:
     * 1. gather the metrics from the parsed report 2. set the metrics result
     * properly base on the metric logic
     * 
     * @return
     */
    public abstract List<Metric> getMetrics();

    /**
     * review all metrics get from getMetrics, it will 1. make a success/ fail
     * call base all the metrics. 2. update the threshold file if the metrics is
     * newer or better
     * 
     */
    public void checkThreshold() {
        List<Metric> metrics = getMetrics();
        boolean isFail = false;
        for (Iterator<Metric> mit = metrics.iterator(); mit.hasNext();) {
            Metric m = (Metric) mit.next();
            logMetric(m);
            if (m.getResult() == MetricResult.METRIC_FAIL
                    || m.getResult() == MetricResult.METRIC_NOTRUN) {
                isFail = true;
            }
            // Update the threshold when the metrics is success. or the metrics
            // is no need to check
            if (m.getResult() == MetricResult.METRIC_SUCCESS
                    || m.getResult() == MetricResult.METRIC_NOCHECK
                    || m.getResult() == MetricResult.METRIC_NULL) {
                try {
                    updateThreshold(m.getName(), m.getNewValue());
                } catch (Exception e) {
                    // TODO: should we throw other exception when failed to
                    // update threshold?
                    isFail = true;
                }
            }
        }
        if (isFailOnError() && isFail) {
            throw new BuildException("Metics check failed");
        }
    }

    /**
     * Print the metrics info to console.
     * 
     * @param m
     */
    private void logMetric(Metric m) {
        getProject().log(
                "Metric " + m.getName() + " for type " + m.getType()
                        + " has result " + m.getResult()
                        + " the old value is: " + m.getOldValue()
                        + " the new value is: " + m.getNewValue());
    }

    public String getReportPath() {
        return reportPath;
    }

    public void setReportPath(String reportPath) {
        this.reportPath = reportPath;
    }

    public String getThresholdPath() {
        return thresholdPath;
    }

    public void setThresholdPath(String thresholdPath) {
        this.thresholdPath = thresholdPath;
    }

    private PropertiesConfiguration getThreshHoldProps() throws Exception {
        File thFile = new File(thresholdPath);
        PropertiesConfiguration props = new PropertiesConfiguration();
        if (thFile.exists()) {
            props.load(new FileInputStream(thFile));
        }
        return props;
    }

    private void saveProps(PropertiesConfiguration props) throws Exception {
        File thFile = new File(thresholdPath);
        props.save(thFile);
    }

    /**
     * Get the threshold of the given metric. return null if the threshold is
     * not found.
     * 
     * @param thresholdName
     * @return
     */
    public String getThreshold(String thresholdName) {
        try {
            PropertiesConfiguration props = getThreshHoldProps();
            return props.getString(thresholdName);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Update the new value to threshold file.
     * 
     * @param thresholdName
     *            -- the name of the metric
     * @param thresholdVaule
     *            -- the new value of the metric
     * @throws Exception
     */
    public void updateThreshold(String thresholdName, String thresholdVaule)
            throws Exception {
        PropertiesConfiguration props = getThreshHoldProps();
        props.setProperty(thresholdName, thresholdVaule);
        saveProps(props);
    }

    /**
     * Check whether the given string is a int number. Make sure there is no
     * exception thrown
     * 
     * @param value
     * @return
     */
    public boolean isInt(String value) {
        try {
            Integer.parseInt(value);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Check whether the given string is a float number. Make sure there is no
     * exception thrown
     * 
     * @param value
     * @return
     */
    public boolean isFloat(String value) {
        try {
            Float.parseFloat(value);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    public MetricResult checkMetric(int oldValue, int newValue,
            MetricCompareMode mode) {
        if (oldValue == newValue) {
            return MetricResult.METRIC_NOCHANGE;
        }
        int modeFlag = 1;
        if (mode == MetricCompareMode.SMALLER_BETTER) {
            modeFlag = -1;
        }
        int compareResult = 1;
        if (oldValue > newValue) {
            compareResult = -1;
        }

        if (modeFlag * compareResult > 0) {
            return MetricResult.METRIC_SUCCESS;
        }

        return MetricResult.METRIC_FAIL;
    }

    public MetricResult checkMetric(float oldValue, float newValue,
            MetricCompareMode mode) {
        if (oldValue == newValue) {
            return MetricResult.METRIC_NOCHANGE;
        }
        int modeFlag = 1;
        if (mode == MetricCompareMode.SMALLER_BETTER) {
            modeFlag = -1;
        }
        int compareResult = 1;
        if (oldValue > newValue) {
            compareResult = -1;
        }

        if (modeFlag * compareResult > 0) {
            return MetricResult.METRIC_SUCCESS;
        }

        return MetricResult.METRIC_FAIL;
    }
}
