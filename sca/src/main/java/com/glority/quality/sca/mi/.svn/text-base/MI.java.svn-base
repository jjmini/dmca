package com.glority.quality.sca.mi;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.ParserRuleReturnScope;
import org.antlr.runtime.Token;
import org.apache.tools.ant.BuildException;

import com.glority.quality.sca.mi.parser.CppMIParser;
import com.glority.quality.sca.antlr.LanguageParserFactory.LanguageEnum;
import com.glority.quality.sca.mi.metrics.FileMetrics;
import com.glority.quality.sca.mi.metrics.FunctionMetrics;
import com.glority.quality.sca.mi.metrics.MIMetrics;
import com.glority.quality.sca.mi.metrics.ProjectMetrics;
import com.glority.quality.sca.mi.parser.IMISourceCodeParser;
import com.glority.quality.sca.mi.parser.MIParserFactory;
import com.glority.quality.sca.mi.report.HTMLReport;
import com.glority.quality.sca.mi.report.XMLReport;

/**
 * This class is use to collect static code analysis metrics include: Line of
 * code Line of comments Maintainablity index Code complecity.
 * 
 * This is based on grammar parser. We should be able to add more analysis if we
 * want from here.
 * 
 * @author XQS
 * 
 */
public class MI {
    private static final int WORSTFUNCTIONNUM = 100;
    private List<File> reportList = new ArrayList<File>();
    private static final int THIRD_POSITION = 3;
    private static final int FOURTH_POSITION = 4;
    private static final int FIFTH_POSITION = 5;
    private static final int SIXTH_POSITION = 6;
    private static final int SEVENTH_POSITION = 7;
    private static final int EIGHTH_POSITION = 8;
    private static final int NINTH_POSITION = 9;
    private static final int TENTH_POSITION = 10;

    /**
     * run mi task.
     * 
     * @param listOfFileList
     *            :a list of List<File> to run project slicly, generated by
     *            FileFilterToPiece
     * @param lang
     * @param reportPath
     * @throws IOException
     */
    public void runMI(List<List<File>> listOfFileList, LanguageEnum lang, String reportPath) throws IOException {
        if (listOfFileList.size() == 1) {
            ProjectMetrics pmi = calculateMI(listOfFileList.get(0), lang);
            generateReport(pmi, lang, reportPath);
        } else {
            for (int i = 0; i < listOfFileList.size(); i++) {
                String subReportPath = reportPath + File.separator + "temp-" + i;
                File reportDir = new File(subReportPath);
                if (!reportDir.isDirectory()) {
                    reportDir.mkdir();
                }
                ProjectMetrics pmi = calculateMI(listOfFileList.get(i), lang);
                writeCompleteReport(pmi, lang, subReportPath);
            }
            mergeReport(lang, reportPath);
            deleteTempReports();
        }
    }

    private void writeCompleteReport(ProjectMetrics pmi, LanguageEnum lang, String reportPath) {
        String reportFile = reportPath + File.separator + "mi.txt";
        OutputStream os = null;
        try {
            os = new FileOutputStream(reportFile);
            os.write((pmi.getLoc() + " " + pmi.getLom() + " " + pmi.getAvgLoc() + " " + pmi.getAvgLom() + " "
                    + pmi.getAvgHalsteadVolume() + " " + pmi.getAvgCcVolume() + " " + pmi.getMi() + " " + pmi.getCmi()
                    + " " + pmi.getTotalFunctions() + "\n").getBytes());
            for (FileMetrics fm : pmi.getFiles()) {
                os.write(("fmi {" + fm.getFilePath() + "} " + fm.getLoc() + " " + fm.getLom() + " " + fm.getAvgLoc()
                        + " " + fm.getAvgLom() + " " + fm.getAvgHalsteadVolume() + " " + fm.getAvgCcVolume() + " "
                        + fm.getMi() + " " + fm.getCmi() + "\n").getBytes());
                for (FunctionMetrics ffm : fm.getFunctions()) {
                    os.write(("fun {" + formatString(ffm.getFunctionName()) + "} " + ffm.getLoc() + " " + ffm.getLom()
                            + " " + ffm.getHn1() + " " + ffm.getHn2() + " " + ffm.gethN1() + " " + ffm.gethN2() + " "
                            + ffm.getAvgHalsteadVolume() + " " + ffm.getAvgCcVolume() + " " + ffm.getMi() + " "
                            + ffm.getCmi() + "\n").getBytes());
                }
            }
            os.close();
            reportList.add(new File(reportFile));
        } catch (Exception e) {
            e.printStackTrace();
            throw new BuildException(e.getMessage());
        }
    }

    private ProjectMetrics mergerPmi() throws IOException {
        ProjectMetrics pmi = new ProjectMetrics();
        float[] locs = new float[reportList.size()];
        float[] loms = new float[reportList.size()];
        float[] avgHalsteadVolume = new float[reportList.size()];
        float[] avgCcVolume = new float[reportList.size()];
        int[] functionNums = new int[reportList.size()];
        for (int i = 0; i < reportList.size(); i++) {
            FileInputStream fin = new FileInputStream(reportList.get(i));
            BufferedReader br = new BufferedReader(new InputStreamReader(fin));
            String firstLine = br.readLine();
            String[] s = firstLine.split(" ");
            locs[i] = Float.parseFloat(s[0]);
            loms[i] = Float.parseFloat(s[1]);
            avgHalsteadVolume[i] = Float.parseFloat(s[FOURTH_POSITION]);
            avgCcVolume[i] = Float.parseFloat(s[FIFTH_POSITION]);
            functionNums[i] = Integer.parseInt(s[EIGHTH_POSITION]);
        }
        pmi.setLoc(sum(locs));
        pmi.setLom(sum(loms));
        pmi.setTotalFunctions(sum(functionNums));
        pmi.setAvgHalsteadVolume(productSum(avgHalsteadVolume, functionNums) / sum(functionNums));
        pmi.setAvgCcVolume(productSum(avgCcVolume, functionNums) / sum(functionNums));
        pmi.straightGetMI();
        return pmi;
    }

    private void mergeReport(LanguageEnum lang, String reportPath) throws IOException {
        int fileNum = 0;
        ProjectMetrics pmi = mergerPmi();
        XMLReport xr = new XMLReport(pmi, lang, reportPath);
        xr.writeReport();
        String reportFile = reportPath + File.separator + "mi.html";
        OutputStream os = new FileOutputStream(reportFile);
        HTMLReport hr = new HTMLReport(pmi, lang, reportPath);
        hr.initMergeReport("mi", os);
        FileMetrics fm = null;
        for (File report : reportList) {
            FileInputStream fin = new FileInputStream(report);
            BufferedReader br = new BufferedReader(new InputStreamReader(fin));
            String line = null;
            while ((line = br.readLine()) != null) {
                if ("fmi".equals(line.substring(0, THIRD_POSITION))) {
                    if (fileNum > 0) {
                        hr.mergeReport("mi", fm, os);
                    }
                    fm = new FileMetrics();
                    fm.setFileOrder(fileNum);
                    fm.setFilePath(line.substring(line.indexOf("{") + 1, line.lastIndexOf("}")));
                    String[] s = line.substring(line.lastIndexOf("}") + 1).split(" ");
                    fm.setLoc(Float.parseFloat(s[1].trim()));
                    fm.setLom(Float.parseFloat(s[2].trim()));
                    fm.setAvgHalsteadVolume(Float.parseFloat(s[FIFTH_POSITION].trim()));
                    fm.setAvgCcVolume(Float.parseFloat(s[SIXTH_POSITION].trim()));
                    fm.setMi(Float.parseFloat(s[SEVENTH_POSITION].trim()));
                    fm.setCmi(Float.parseFloat(s[EIGHTH_POSITION].trim()));
                    fileNum++;
                } else if ("fun".equals(line.substring(0, THIRD_POSITION))) {
                    FunctionMetrics ffm = new FunctionMetrics();
                    ffm.setFunctionName(line.substring(line.indexOf("{") + 1, line.lastIndexOf("}")));
                    String[] s = line.substring(line.lastIndexOf("}") + 1).split(" ");
                    ffm.setLoc(Float.parseFloat(s[1].trim()));
                    ffm.setLom(Float.parseFloat(s[2].trim()));
                    ffm.setHn1(Integer.parseInt(s[THIRD_POSITION].trim()));
                    ffm.setHn2(Integer.parseInt(s[FOURTH_POSITION].trim()));
                    ffm.sethN1(Integer.parseInt(s[FIFTH_POSITION].trim()));
                    ffm.sethN2(Integer.parseInt(s[SIXTH_POSITION].trim()));
                    ffm.setAvgHalsteadVolume(Float.parseFloat(s[SEVENTH_POSITION].trim()));
                    ffm.setAvgCcVolume(Float.parseFloat(s[EIGHTH_POSITION].trim()));
                    ffm.setMi(Float.parseFloat(s[NINTH_POSITION].trim()));
                    ffm.setCmi(Float.parseFloat(s[TENTH_POSITION].trim()));
                    fm.addFunction(ffm);
                }
            }
            fin.close();
        }
        os.write("</table>".getBytes());
        os.write("</body>".getBytes());
    }

    private void deleteTempReports() {
        for (File report : reportList) {
            if (report.exists()) {
                report.delete();
                File dir = report.getParentFile();
                if (dir.exists()) {
                    dir.delete();
                }
            }
        }
    }

    private void generateReport(ProjectMetrics pmi, LanguageEnum lang, String reportPath) {
        XMLReport xr = new XMLReport(pmi, lang, reportPath);
        HTMLReport hr = new HTMLReport(pmi, lang, reportPath);
        xr.writeReport();
        hr.writeReport("mi");
        hr.writeReport("sorted");
        hr.writeBadReport("mi");
        hr.writeWorstFunctionsReport(hr.getTotalSortedFunctions(), WORSTFUNCTIONNUM);
    }

    private ProjectMetrics calculateMI(List<File> fileList, LanguageEnum lang) {
        ProjectMetrics pmi = new ProjectMetrics();
        for (int i = 0; i < fileList.size(); i++) {
            File f = (File) fileList.get(i);
            FileMetrics fmi = processFile(f, lang);
            pmi.addFile(fmi);
        }
        pmi.calculateMI();
        return pmi;
    }

    private FileMetrics processFile(File f, LanguageEnum lang) {
        FileMetrics fmi = new FileMetrics();
        fmi.setFilePath(f.getPath());
        IMISourceCodeParser miParser = MIParserFactory.getInstance().getMIParser(f, lang);
        miParser.getAST();
        CommonTokenStream ts = (CommonTokenStream) miParser.getTokenStream();
        countLines(miParser, ts.getTokens(), fmi);
        if (lang == LanguageEnum.CPP) {
            CppMIParser parser = (CppMIParser) miParser;
            try {
                parser.functionDeclaration();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        List<ParserRuleReturnScope> functions = miParser.getFunctions();
        for (Iterator<ParserRuleReturnScope> it = functions.iterator(); it.hasNext();) {
            ParserRuleReturnScope rs = (ParserRuleReturnScope) it.next();
            List<Token> functionTokens = ts.getTokens(((Token) rs.getStart()).getTokenIndex(),
                    ((Token) rs.getStop()).getTokenIndex());
            List functionComments = miParser.getFunctionComments(rs);
            // Add the comments above the function as the comment of the
            // function
            functionTokens.addAll(0, functionComments);
            fmi.addFunction(getFunctionMetrics(miParser, functionTokens));
        }
        fmi.calculateMI();
        return fmi;
    }

    /**
     * Get the MI metrics of the given function tokens.
     * 
     * @param miParser
     * @param tokens
     * @return
     */
    private FunctionMetrics getFunctionMetrics(IMISourceCodeParser miParser, List<Token> tokens) {
        FunctionMetrics fmi = new FunctionMetrics();
        // Get lines of code and comments
        countLines(miParser, tokens, fmi);
        int n1 = 0, n2 = 0, hN1 = 0, hN2 = 0, cc = 0;
        Set<Integer> n1Set = new HashSet<Integer>(); // The set of operators
                                                     // types
        Set<Integer> n2Set = new HashSet<Integer>(); // The set of operand types
        boolean isFunctionHeadPassed = false;
        String functionHead = "";
        for (int i = 0; i < tokens.size() - 1; i++) {
            Token t = (Token) tokens.get(i);
            if (miParser.isComment(t)) {
                continue;
            } else if (miParser.isCC(t)) {
                cc++;
            }
            if (miParser.isOperator(t)) {
                hN1++;
                if (!n1Set.contains(t.getType())) {
                    n1++;
                    n1Set.add(t.getType());
                }

            } else if (miParser.isOperand(t)) {
                hN2++;
                if (!n2Set.contains(t.getType())) {
                    n2++;
                    n2Set.add(t.getType());
                }
            }
            if (!isFunctionHeadPassed) {
                // Name need be improved. Add space properly
                functionHead += t.getText() + " ";

                if (miParser.isFunctionHeadEnd(t)) {
                    isFunctionHeadPassed = true;
                }
            }
        }
        fmi.sethN1(hN1);
        fmi.sethN2(hN2);
        fmi.setHn1(n1);
        fmi.setHn2(n2);
        fmi.setFunctionName(functionHead.replaceAll("\n", " "));
        fmi.setAvgCcVolume(cc);
        fmi.calculateMI();
        return fmi;
    }

    /**
     * Count lines of code and lines of comments of a source file. Note: 1. if
     * there both comment and code in the same line. we will count it as 1 line
     * code and 1 line comment. So the totalLoc + totalLom sometime will larger
     * than real lines of the code
     * 
     * @param miParser
     * @param ts
     * @param mi
     */
    private void countLines(IMISourceCodeParser miParser, List<Token> tokens, MIMetrics mi) {
        if (tokens.size() == 1) {
            return;
        }
        Token t = null, nt = null;
        // Get the line number of the last token
        int lastNum = 1;
        Token lastToken = (Token) tokens.get(tokens.size() - lastNum);
        while (lastToken.getType() == -1) {
            lastNum++;
            lastToken = (Token) tokens.get(tokens.size() - lastNum);
        }
        Token firstTokn = (Token) tokens.get(0);
        int totalLines = lastToken.getLine() - firstTokn.getLine() + countLines(lastToken.getText());
        int totalLoc = 0;
        int totalLom = 0;
        for (int i = 0; i <= tokens.size() - 2; i++) {
            t = (Token) tokens.get(i);
            nt = (Token) tokens.get(i + 1);
            if (miParser.isComment(t)) {
                totalLom += countLines(t.getText());
            }
            // If the comment and code are in the same line, treat 2 lines
            if ((t.getLine() == nt.getLine()) && (miParser.isComment(t) != miParser.isComment(nt))) {
                totalLines++;
            }
        }
        // Count last token
        if (miParser.isComment(lastToken)) {
            totalLom += countLines(lastToken.getText());
        }
        totalLoc = totalLines - totalLom;
        mi.setLoc(totalLoc);
        mi.setLom(totalLom);
    }

    private int countLines(String s) {
        if (s == null) {
            return 0;
        } else {
            String[] lines = s.split("\n");
            return lines.length;
        }
    }

    private float sum(float[] s) {
        float sum = 0;
        for (int i = 0; i < s.length; i++) {
            sum += s[i];
        }
        return sum;
    }

    private int sum(int[] s) {
        int sum = 0;
        for (int i = 0; i < s.length; i++) {
            sum += s[i];
        }
        return sum;
    }

    private float productSum(float[] s, int[] f) {
        float sum = 0;
        for (int i = 0; i < s.length; i++) {
            sum += s[i] * f[i];
        }
        return sum;
    }

    private String formatString(String s) {
        String t = "";
        Pattern p = Pattern.compile("\r|\n|\t");
        Matcher m = p.matcher(s);
        t = m.replaceAll(" ");
        return t;
    }
}
